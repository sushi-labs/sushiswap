{"version":3,"names":["react","cloneNode","jsxExpressionContainer","variableDeclaration","variableDeclarator","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","violation","constantViolations","mutableBinding","stop","bindings","PathHoister","constructor","scopes","attachAfter","isCompatibleScope","key","Object","keys","bindingIdentifierEquals","identifier","getCompatibleScopes","indexOf","getAttachmentPath","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","bindingParentPath","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","bodies","get","i","length","_blockHoist","getNextScopeAttachmentParent","Array","isArray","container","isStatement","constant","run","traverse","attachTo","getFunctionParent","uid","generateUidIdentifier","declarator","insertFn","attached","isVariableDeclarator","isJSXElement","children","replaceWith"],"sources":["../../../src/path/lib/hoister.ts"],"sourcesContent":["import { react } from \"@babel/types\";\nimport {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../../scope\";\nimport type NodePath from \"../index\";\nimport type Binding from \"../../scope/binding\";\nimport type { Visitor } from \"../../types\";\n\nconst referenceVisitor: Visitor<PathHoister> = {\n  // This visitor looks for bindings to establish a topmost scope for hoisting.\n  ReferencedIdentifier(path, state) {\n    // Don't hoist regular JSX identifiers ('div', 'span', etc).\n    // We do have to consider member expressions for hoisting (e.g. `this.component`)\n    if (\n      path.isJSXIdentifier() &&\n      react.isCompatTag(path.node.name) &&\n      !path.parentPath.isJSXMemberExpression()\n    ) {\n      return;\n    }\n\n    // If the identifier refers to `this`, we need to break on the closest non-arrow scope.\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n      do {\n        if (\n          scope.path.isFunction() &&\n          !scope.path.isArrowFunctionExpression()\n        ) {\n          break;\n        }\n      } while ((scope = scope.parent));\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    // direct references that we need to track to hoist this to the highest scope we can\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    // we can handle reassignments only if they happen in the same scope as the declaration\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    // this binding isn't accessible from the parent scope so we can safely ignore it\n    // eg. it's in a closure etc\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n\n    state.bindings[path.node.name] = binding;\n  },\n};\n\nexport default class PathHoister<T extends t.Node = t.Node> {\n  breakOnScopePaths: NodePath[];\n  bindings: { [k: string]: Binding };\n  mutableBinding: boolean;\n  private scopes: Scope[];\n  scope: Scope;\n  private path: NodePath<T>;\n  private attachAfter: boolean;\n\n  constructor(path: NodePath<T>, scope: Scope) {\n    // Storage for scopes we can't hoist above.\n    this.breakOnScopePaths = [];\n    // Storage for bindings that may affect what path we can hoist to.\n    this.bindings = {};\n    // \"true\" if the current path contains a reference to a binding whose\n    // value can change and thus can't be safely hoisted.\n    this.mutableBinding = false;\n    // Storage for eligible scopes.\n    this.scopes = [];\n    // Our original scope and path.\n    this.scope = scope;\n    this.path = path;\n    // By default, we attach as far up as we can; but if we're trying\n    // to avoid referencing a binding, we may have to go after.\n    this.attachAfter = false;\n  }\n\n  // A scope is compatible if all required bindings are reachable.\n  isCompatibleScope(scope: Scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Look through all scopes and push compatible ones.\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      // deopt: These scopes are set in the visitor on const violations\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while ((scope = scope.parent));\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n    if (!path) return;\n\n    let targetScope = path.scope;\n\n    // don't allow paths that have their own lexical environments to pollute\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    // avoid hoisting to a scope that contains bindings that are executed after our attachment path\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        // check binding is a direct child of this paths scope\n        if (!targetScope.hasOwnBinding(name)) continue;\n\n        const binding = this.bindings[name];\n\n        // allow parameter references and expressions in params (like destructuring rest)\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        // For each binding, get its attachment parent. This gives us an idea of where we might\n        // introduce conflicts.\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        // If the binding's attachment appears at or after our attachment point, then we move after it.\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          // We also move past any constant violations.\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n\n    const scope = scopes.pop();\n    // deopt: no compatible scopes\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        // deopt: should ignore this scope since it's ourselves\n        if (this.scope === scope) return;\n\n        // needs to be attached to the body\n        const bodies = scope.path.get(\"body\").get(\"body\") as NodePath[];\n        for (let i = 0; i < bodies.length; i++) {\n          // Don't attach to something that's going to get hoisted,\n          // like a default parameter\n          // @ts-expect-error todo(flow->ts): avoid mutating the node, introducing new fields\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n        // deopt: If here, no attachment path found\n      } else {\n        // doesn't need to be be attached to this scope\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  // Find an attachment for this path.\n  getAttachmentParentForPath(path: NodePath) {\n    do {\n      if (\n        // Beginning of the scope\n        !path.parentPath ||\n        // Has siblings and is a statement\n        (Array.isArray(path.container) && path.isStatement())\n      ) {\n        return path;\n      }\n    } while ((path = path.parentPath));\n  }\n\n  // Returns true if a scope has param bindings.\n  hasOwnParamBindings(scope: Scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n\n      const binding = this.bindings[name];\n      // Ensure constant; without it we could place behind a reassignment\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n\n    if (this.mutableBinding) return;\n\n    this.getCompatibleScopes();\n\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n\n    // don't bother hoisting to the same function as this will cause multiple branches to be\n    // evaluated more than once leading to a bad optimisation\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n\n    // generate declaration and insert it to our point\n    let uid: t.Identifier | t.JSXExpressionContainer =\n      attachTo.scope.generateUidIdentifier(\"ref\");\n\n    // @ts-expect-error todo(flow->ts): more specific type for this.path\n    const declarator = variableDeclarator(uid, this.path.node);\n\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([\n      attachTo.isVariableDeclarator()\n        ? declarator\n        : variableDeclaration(\"var\", [declarator]),\n    ]);\n\n    const parent = this.path.parentPath;\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with\n      // an expression container\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n\n    return attachTo.isVariableDeclarator()\n      ? attached.get(\"init\")\n      : attached.get(\"declarations.0.init\");\n  }\n}\n"],"mappings":";;;;;;;AAAA;;;;EAASA;;;EAEPC,S;EACAC,sB;EACAC,mB;EACAC;;AAQF,MAAMC,gBAAsC,GAAG;EAE7CC,oBAAoB,CAACC,IAAD,EAAOC,KAAP,EAAc;IAGhC,IACED,IAAI,CAACE,eAAL,MACAT,KAAK,CAACU,WAAN,CAAkBH,IAAI,CAACI,IAAL,CAAUC,IAA5B,CADA,IAEA,CAACL,IAAI,CAACM,UAAL,CAAgBC,qBAAhB,EAHH,EAIE;MACA;IACD;;IAGD,IAAIP,IAAI,CAACI,IAAL,CAAUC,IAAV,KAAmB,MAAvB,EAA+B;MAC7B,IAAIG,KAAK,GAAGR,IAAI,CAACQ,KAAjB;;MACA,GAAG;QACD,IACEA,KAAK,CAACR,IAAN,CAAWS,UAAX,MACA,CAACD,KAAK,CAACR,IAAN,CAAWU,yBAAX,EAFH,EAGE;UACA;QACD;MACF,CAPD,QAOUF,KAAK,GAAGA,KAAK,CAACG,MAPxB;;MAQA,IAAIH,KAAJ,EAAWP,KAAK,CAACW,iBAAN,CAAwBC,IAAxB,CAA6BL,KAAK,CAACR,IAAnC;IACZ;;IAGD,MAAMc,OAAO,GAAGd,IAAI,CAACQ,KAAL,CAAWO,UAAX,CAAsBf,IAAI,CAACI,IAAL,CAAUC,IAAhC,CAAhB;IACA,IAAI,CAACS,OAAL,EAAc;;IAGd,KAAK,MAAME,SAAX,IAAwBF,OAAO,CAACG,kBAAhC,EAAoD;MAClD,IAAID,SAAS,CAACR,KAAV,KAAoBM,OAAO,CAACd,IAAR,CAAaQ,KAArC,EAA4C;QAC1CP,KAAK,CAACiB,cAAN,GAAuB,IAAvB;QACAlB,IAAI,CAACmB,IAAL;QACA;MACD;IACF;;IAID,IAAIL,OAAO,KAAKb,KAAK,CAACO,KAAN,CAAYO,UAAZ,CAAuBf,IAAI,CAACI,IAAL,CAAUC,IAAjC,CAAhB,EAAwD;IAExDJ,KAAK,CAACmB,QAAN,CAAepB,IAAI,CAACI,IAAL,CAAUC,IAAzB,IAAiCS,OAAjC;EACD;;AA7C4C,CAA/C;;AAgDe,MAAMO,WAAN,CAA6C;EAS1DC,WAAW,CAACtB,IAAD,EAAoBQ,KAApB,EAAkC;IAAA,KAR7CI,iBAQ6C;IAAA,KAP7CQ,QAO6C;IAAA,KAN7CF,cAM6C;IAAA,KALrCK,MAKqC;IAAA,KAJ7Cf,KAI6C;IAAA,KAHrCR,IAGqC;IAAA,KAFrCwB,WAEqC;IAE3C,KAAKZ,iBAAL,GAAyB,EAAzB;IAEA,KAAKQ,QAAL,GAAgB,EAAhB;IAGA,KAAKF,cAAL,GAAsB,KAAtB;IAEA,KAAKK,MAAL,GAAc,EAAd;IAEA,KAAKf,KAAL,GAAaA,KAAb;IACA,KAAKR,IAAL,GAAYA,IAAZ;IAGA,KAAKwB,WAAL,GAAmB,KAAnB;EACD;;EAGDC,iBAAiB,CAACjB,KAAD,EAAe;IAC9B,KAAK,MAAMkB,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAY,KAAKR,QAAjB,CAAlB,EAA8C;MAC5C,MAAMN,OAAO,GAAG,KAAKM,QAAL,CAAcM,GAAd,CAAhB;;MACA,IAAI,CAAClB,KAAK,CAACqB,uBAAN,CAA8BH,GAA9B,EAAmCZ,OAAO,CAACgB,UAA3C,CAAL,EAA6D;QAC3D,OAAO,KAAP;MACD;IACF;;IAED,OAAO,IAAP;EACD;;EAGDC,mBAAmB,GAAG;IACpB,IAAIvB,KAAK,GAAG,KAAKR,IAAL,CAAUQ,KAAtB;;IACA,GAAG;MACD,IAAI,KAAKiB,iBAAL,CAAuBjB,KAAvB,CAAJ,EAAmC;QACjC,KAAKe,MAAL,CAAYV,IAAZ,CAAiBL,KAAjB;MACD,CAFD,MAEO;QACL;MACD;;MAGD,IAAI,KAAKI,iBAAL,CAAuBoB,OAAvB,CAA+BxB,KAAK,CAACR,IAArC,KAA8C,CAAlD,EAAqD;QACnD;MACD;IACF,CAXD,QAWUQ,KAAK,GAAGA,KAAK,CAACG,MAXxB;EAYD;;EAEDsB,iBAAiB,GAAG;IAClB,IAAIjC,IAAI,GAAG,KAAKkC,kBAAL,EAAX;;IACA,IAAI,CAAClC,IAAL,EAAW;IAEX,IAAImC,WAAW,GAAGnC,IAAI,CAACQ,KAAvB;;IAGA,IAAI2B,WAAW,CAACnC,IAAZ,KAAqBA,IAAzB,EAA+B;MAC7BmC,WAAW,GAAGnC,IAAI,CAACQ,KAAL,CAAWG,MAAzB;IACD;;IAGD,IAAIwB,WAAW,CAACnC,IAAZ,CAAiBoC,SAAjB,MAAgCD,WAAW,CAACnC,IAAZ,CAAiBS,UAAjB,EAApC,EAAmE;MACjE,KAAK,MAAMJ,IAAX,IAAmBsB,MAAM,CAACC,IAAP,CAAY,KAAKR,QAAjB,CAAnB,EAA+C;QAE7C,IAAI,CAACe,WAAW,CAACE,aAAZ,CAA0BhC,IAA1B,CAAL,EAAsC;QAEtC,MAAMS,OAAO,GAAG,KAAKM,QAAL,CAAcf,IAAd,CAAhB;;QAGA,IAAIS,OAAO,CAACwB,IAAR,KAAiB,OAAjB,IAA4BxB,OAAO,CAACd,IAAR,CAAauC,SAAb,KAA2B,QAA3D,EAAqE;UACnE;QACD;;QAID,MAAMC,iBAAiB,GAAG,KAAKC,0BAAL,CAAgC3B,OAAO,CAACd,IAAxC,CAA1B;;QAGA,IAAIwC,iBAAiB,CAACd,GAAlB,IAAyB1B,IAAI,CAAC0B,GAAlC,EAAuC;UACrC,KAAKF,WAAL,GAAmB,IAAnB;UACAxB,IAAI,GAAGc,OAAO,CAACd,IAAf;;UAGA,KAAK,MAAM0C,aAAX,IAA4B5B,OAAO,CAACG,kBAApC,EAAwD;YACtD,IAAI,KAAKwB,0BAAL,CAAgCC,aAAhC,EAA+ChB,GAA/C,GAAqD1B,IAAI,CAAC0B,GAA9D,EAAmE;cACjE1B,IAAI,GAAG0C,aAAP;YACD;UACF;QACF;MACF;IACF;;IAED,OAAO1C,IAAP;EACD;;EAEDkC,kBAAkB,GAAG;IACnB,MAAMX,MAAM,GAAG,KAAKA,MAApB;IAEA,MAAMf,KAAK,GAAGe,MAAM,CAACoB,GAAP,EAAd;IAEA,IAAI,CAACnC,KAAL,EAAY;;IAEZ,IAAIA,KAAK,CAACR,IAAN,CAAWS,UAAX,EAAJ,EAA6B;MAC3B,IAAI,KAAKmC,mBAAL,CAAyBpC,KAAzB,CAAJ,EAAqC;QAEnC,IAAI,KAAKA,KAAL,KAAeA,KAAnB,EAA0B;QAG1B,MAAMqC,MAAM,GAAGrC,KAAK,CAACR,IAAN,CAAW8C,GAAX,CAAe,MAAf,EAAuBA,GAAvB,CAA2B,MAA3B,CAAf;;QACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACG,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;UAItC,IAAIF,MAAM,CAACE,CAAD,CAAN,CAAU3C,IAAV,CAAe6C,WAAnB,EAAgC;UAChC,OAAOJ,MAAM,CAACE,CAAD,CAAb;QACD;MAEF,CAdD,MAcO;QAEL,OAAO,KAAKG,4BAAL,EAAP;MACD;IACF,CAnBD,MAmBO,IAAI1C,KAAK,CAACR,IAAN,CAAWoC,SAAX,EAAJ,EAA4B;MACjC,OAAO,KAAKc,4BAAL,EAAP;IACD;EACF;;EAEDA,4BAA4B,GAAG;IAC7B,MAAM1C,KAAK,GAAG,KAAKe,MAAL,CAAYoB,GAAZ,EAAd;IACA,IAAInC,KAAJ,EAAW,OAAO,KAAKiC,0BAAL,CAAgCjC,KAAK,CAACR,IAAtC,CAAP;EACZ;;EAGDyC,0BAA0B,CAACzC,IAAD,EAAiB;IACzC,GAAG;MACD,IAEE,CAACA,IAAI,CAACM,UAAN,IAEC6C,KAAK,CAACC,OAAN,CAAcpD,IAAI,CAACqD,SAAnB,KAAiCrD,IAAI,CAACsD,WAAL,EAJpC,EAKE;QACA,OAAOtD,IAAP;MACD;IACF,CATD,QASUA,IAAI,GAAGA,IAAI,CAACM,UATtB;EAUD;;EAGDsC,mBAAmB,CAACpC,KAAD,EAAe;IAChC,KAAK,MAAMH,IAAX,IAAmBsB,MAAM,CAACC,IAAP,CAAY,KAAKR,QAAjB,CAAnB,EAA+C;MAC7C,IAAI,CAACZ,KAAK,CAAC6B,aAAN,CAAoBhC,IAApB,CAAL,EAAgC;MAEhC,MAAMS,OAAO,GAAG,KAAKM,QAAL,CAAcf,IAAd,CAAhB;MAEA,IAAIS,OAAO,CAACwB,IAAR,KAAiB,OAAjB,IAA4BxB,OAAO,CAACyC,QAAxC,EAAkD,OAAO,IAAP;IACnD;;IACD,OAAO,KAAP;EACD;;EAEDC,GAAG,GAAG;IACJ,KAAKxD,IAAL,CAAUyD,QAAV,CAAmB3D,gBAAnB,EAAqC,IAArC;IAEA,IAAI,KAAKoB,cAAT,EAAyB;IAEzB,KAAKa,mBAAL;IAEA,MAAM2B,QAAQ,GAAG,KAAKzB,iBAAL,EAAjB;IACA,IAAI,CAACyB,QAAL,EAAe;IAIf,IAAIA,QAAQ,CAACC,iBAAT,OAAiC,KAAK3D,IAAL,CAAU2D,iBAAV,EAArC,EAAoE;IAGpE,IAAIC,GAA4C,GAC9CF,QAAQ,CAAClD,KAAT,CAAeqD,qBAAf,CAAqC,KAArC,CADF;IAIA,MAAMC,UAAU,GAAGjE,kBAAkB,CAAC+D,GAAD,EAAM,KAAK5D,IAAL,CAAUI,IAAhB,CAArC;IAEA,MAAM2D,QAAQ,GAAG,KAAKvC,WAAL,GAAmB,aAAnB,GAAmC,cAApD;IACA,MAAM,CAACwC,QAAD,IAAaN,QAAQ,CAACK,QAAD,CAAR,CAAmB,CACpCL,QAAQ,CAACO,oBAAT,KACIH,UADJ,GAEIlE,mBAAmB,CAAC,KAAD,EAAQ,CAACkE,UAAD,CAAR,CAHa,CAAnB,CAAnB;IAMA,MAAMnD,MAAM,GAAG,KAAKX,IAAL,CAAUM,UAAzB;;IACA,IAAIK,MAAM,CAACuD,YAAP,MAAyB,KAAKlE,IAAL,CAAUqD,SAAV,KAAwB1C,MAAM,CAACP,IAAP,CAAY+D,QAAjE,EAA2E;MAGzEP,GAAG,GAAGjE,sBAAsB,CAACiE,GAAD,CAA5B;IACD;;IAED,KAAK5D,IAAL,CAAUoE,WAAV,CAAsB1E,SAAS,CAACkE,GAAD,CAA/B;IAEA,OAAOF,QAAQ,CAACO,oBAAT,KACHD,QAAQ,CAAClB,GAAT,CAAa,MAAb,CADG,GAEHkB,QAAQ,CAAClB,GAAT,CAAa,qBAAb,CAFJ;EAGD;;AA5MyD"}