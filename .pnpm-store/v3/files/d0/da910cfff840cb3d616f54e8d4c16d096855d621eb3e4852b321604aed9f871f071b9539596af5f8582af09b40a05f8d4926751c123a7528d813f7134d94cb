{"version":3,"names":["helperIDs","WeakMap","addCreateSuperHelper","file","has","t","cloneNode","clone","get","addHelper","id","scope","generateUidIdentifier","set","fn","helper","CREATE_SUPER","GET_PROTOTYPE_OF","POSSIBLE_CONSTRUCTOR_RETURN","path","unshiftContainer","registerDeclaration","template","statement"],"sources":["../src/inline-createSuper-helpers.ts"],"sourcesContent":["import { template, types as t, type File } from \"@babel/core\";\n\nconst helperIDs = new WeakMap();\n\nexport default function addCreateSuperHelper(file: File) {\n  if (helperIDs.has(file)) {\n    // TODO: Only use t.cloneNode in Babel 8\n    // t.cloneNode isn't supported in every version\n    return (t.cloneNode || t.clone)(helperIDs.get(file));\n  }\n\n  try {\n    return file.addHelper(\"createSuper\");\n  } catch {\n    // Babel <7.9.0 doesn't support the helper.\n  }\n\n  const id = file.scope.generateUidIdentifier(\"createSuper\");\n  helperIDs.set(file, id);\n\n  const fn = helper({\n    CREATE_SUPER: id,\n    GET_PROTOTYPE_OF: file.addHelper(\"getPrototypeOf\"),\n    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper(\"possibleConstructorReturn\"),\n  });\n\n  file.path.unshiftContainer(\"body\", [fn]);\n  file.scope.registerDeclaration(file.path.get(\"body.0\"));\n\n  return t.cloneNode(id);\n}\n\nconst helper = template.statement`\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n`;\n"],"mappings":";;;;;;;AAAA;;AAEA,MAAMA,SAAS,GAAG,IAAIC,OAAJ,EAAlB;;AAEe,SAASC,oBAAT,CAA8BC,IAA9B,EAA0C;EACvD,IAAIH,SAAS,CAACI,GAAV,CAAcD,IAAd,CAAJ,EAAyB;IAGvB,OAAO,CAACE,WAAA,CAAEC,SAAF,IAAeD,WAAA,CAAEE,KAAlB,EAAyBP,SAAS,CAACQ,GAAV,CAAcL,IAAd,CAAzB,CAAP;EACD;;EAED,IAAI;IACF,OAAOA,IAAI,CAACM,SAAL,CAAe,aAAf,CAAP;EACD,CAFD,CAEE,gBAAM,CAEP;;EAED,MAAMC,EAAE,GAAGP,IAAI,CAACQ,KAAL,CAAWC,qBAAX,CAAiC,aAAjC,CAAX;EACAZ,SAAS,CAACa,GAAV,CAAcV,IAAd,EAAoBO,EAApB;EAEA,MAAMI,EAAE,GAAGC,MAAM,CAAC;IAChBC,YAAY,EAAEN,EADE;IAEhBO,gBAAgB,EAAEd,IAAI,CAACM,SAAL,CAAe,gBAAf,CAFF;IAGhBS,2BAA2B,EAAEf,IAAI,CAACM,SAAL,CAAe,2BAAf;EAHb,CAAD,CAAjB;EAMAN,IAAI,CAACgB,IAAL,CAAUC,gBAAV,CAA2B,MAA3B,EAAmC,CAACN,EAAD,CAAnC;EACAX,IAAI,CAACQ,KAAL,CAAWU,mBAAX,CAA+BlB,IAAI,CAACgB,IAAL,CAAUX,GAAV,CAAc,QAAd,CAA/B;EAEA,OAAOH,WAAA,CAAEC,SAAF,CAAYI,EAAZ,CAAP;AACD;;AAED,MAAMK,MAAM,GAAGO,cAAA,CAASC,SAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAvCA"}