{"version":3,"file":"index.js","sources":["../src/util.ts","../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { Scope, NodePath } from \"@babel/traverse\";\nimport type { TraversalAncestors } from \"@babel/types\";\n\nfunction isPureVoid(node: t.Node) {\n  return (\n    t.isUnaryExpression(node) &&\n    node.operator === \"void\" &&\n    t.isPureish(node.argument)\n  );\n}\n\nexport function unshiftForXStatementBody(\n  statementPath: NodePath<t.ForXStatement>,\n  newStatements: t.Statement[],\n) {\n  statementPath.ensureBlock();\n  const { scope, node } = statementPath;\n  const bodyScopeBindings = statementPath.get(\"body\").scope.bindings;\n  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(\n    name => scope.hasBinding(name),\n  );\n\n  if (hasShadowedBlockScopedBindings) {\n    // handle shadowed variables referenced in computed keys:\n    // var a = 0;for (const { #x: x, [a++]: y } of z) { const a = 1; }\n    node.body = t.blockStatement([...newStatements, node.body]);\n  } else {\n    node.body.body.unshift(...newStatements);\n  }\n}\n\n/**\n * Test if an ArrayPattern's elements contain any RestElements.\n */\n\nfunction hasArrayRest(pattern: t.ArrayPattern) {\n  return pattern.elements.some(elem => t.isRestElement(elem));\n}\n\n/**\n * Test if an ObjectPattern's properties contain any RestElements.\n */\n\nfunction hasObjectRest(pattern: t.ObjectPattern) {\n  return pattern.properties.some(prop => t.isRestElement(prop));\n}\n\ninterface UnpackableArrayExpression extends t.ArrayExpression {\n  elements: (null | t.Expression)[];\n}\n\nconst STOP_TRAVERSAL = {};\n\ninterface ArrayUnpackVisitorState {\n  deopt: boolean;\n  bindings: Record<string, t.Identifier>;\n}\n\n// NOTE: This visitor is meant to be used via t.traverse\nconst arrayUnpackVisitor = (\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: ArrayUnpackVisitorState,\n) => {\n  if (!ancestors.length) {\n    // Top-level node: this is the array literal.\n    return;\n  }\n\n  if (\n    t.isIdentifier(node) &&\n    t.isReferenced(node, ancestors[ancestors.length - 1].node) &&\n    state.bindings[node.name]\n  ) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\n\nexport type DestructuringTransformerNode =\n  | t.VariableDeclaration\n  | t.ExpressionStatement\n  | t.ReturnStatement;\n\ninterface DestructuringTransformerOption {\n  blockHoist?: number;\n  operator?: t.AssignmentExpression[\"operator\"];\n  nodes?: DestructuringTransformerNode[];\n  kind?: t.VariableDeclaration[\"kind\"];\n  scope: Scope;\n  arrayLikeIsIterable: boolean;\n  iterableIsArray: boolean;\n  objectRestNoSymbols: boolean;\n  useBuiltIns: boolean;\n  addHelper: File[\"addHelper\"];\n}\nexport class DestructuringTransformer {\n  private blockHoist: number;\n  private operator: t.AssignmentExpression[\"operator\"];\n  arrayRefSet: Set<string>;\n  private nodes: DestructuringTransformerNode[];\n  private scope: Scope;\n  private kind: t.VariableDeclaration[\"kind\"];\n  private iterableIsArray: boolean;\n  private arrayLikeIsIterable: boolean;\n  private objectRestNoSymbols: boolean;\n  private useBuiltIns: boolean;\n  private addHelper: File[\"addHelper\"];\n  constructor(opts: DestructuringTransformerOption) {\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n\n  getExtendsHelper() {\n    return this.useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : this.addHelper(\"extends\");\n  }\n\n  buildVariableAssignment(\n    id: t.AssignmentExpression[\"left\"],\n    init: t.Expression,\n  ) {\n    let op = this.operator;\n    if (t.isMemberExpression(id)) op = \"=\";\n\n    let node: t.ExpressionStatement | t.VariableDeclaration;\n\n    if (op) {\n      node = t.expressionStatement(\n        t.assignmentExpression(\n          op,\n          id,\n          t.cloneNode(init) || this.scope.buildUndefinedNode(),\n        ),\n      );\n    } else {\n      let nodeInit: t.Expression;\n\n      if (this.kind === \"const\" && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = t.cloneNode(init);\n      }\n\n      node = t.variableDeclaration(this.kind, [\n        t.variableDeclarator(id, nodeInit),\n      ]);\n    }\n\n    //@ts-expect-error(todo): document block hoist property\n    node._blockHoist = this.blockHoist;\n\n    return node;\n  }\n\n  buildVariableDeclaration(id: t.Identifier, init: t.Expression) {\n    const declar = t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.cloneNode(id), t.cloneNode(init)),\n    ]);\n    // @ts-expect-error todo(flow->ts): avoid mutations\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n\n  push(id: t.LVal, _init: t.Expression | null) {\n    const init = t.cloneNode(_init);\n    if (t.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (t.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (t.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n\n  toArray(node: t.Expression, count?: boolean | number) {\n    if (\n      this.iterableIsArray ||\n      (t.isIdentifier(node) && this.arrayRefSet.has(node.name))\n    ) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n\n  pushAssignmentPattern(\n    { left, right }: t.AssignmentPattern,\n    valueRef: t.Expression | null,\n  ) {\n    // handle array init with void 0. This also happens when\n    // the value was originally a hole.\n    // const [x = 42] = [void 0,];\n    // -> const x = 42;\n    if (isPureVoid(valueRef)) {\n      this.push(left, right);\n      return;\n    }\n\n    // we need to assign the current value of the assignment to avoid evaluating\n    // it more than once\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n    const tempConditional = t.conditionalExpression(\n      t.binaryExpression(\n        \"===\",\n        t.cloneNode(tempId),\n        this.scope.buildUndefinedNode(),\n      ),\n      right,\n      t.cloneNode(tempId),\n    );\n\n    if (t.isPattern(left)) {\n      let patternId;\n      let node;\n\n      if (this.kind === \"const\" || this.kind === \"let\") {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n\n        node = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(tempId), tempConditional),\n        );\n      }\n\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n\n  pushObjectRest(\n    pattern: t.ObjectPattern,\n    objRef: t.Expression,\n    spreadProp: t.RestElement,\n    spreadPropIndex: number,\n  ) {\n    const value = buildObjectExcludingKeys(\n      pattern.properties.slice(0, spreadPropIndex) as t.ObjectProperty[],\n      objRef,\n      this.scope,\n      name => this.addHelper(name),\n      this.objectRestNoSymbols,\n      this.useBuiltIns,\n    );\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n\n  pushObjectProperty(prop: t.ObjectProperty, propRef: t.Expression) {\n    if (t.isLiteral(prop.key)) prop.computed = true;\n\n    const pattern = prop.value as t.LVal;\n    const objRef = t.memberExpression(\n      t.cloneNode(propRef),\n      prop.key,\n      prop.computed,\n    );\n\n    if (t.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n\n  pushObjectPattern(pattern: t.ObjectPattern, objRef: t.Expression) {\n    // https://github.com/babel/babel/issues/681\n\n    if (!pattern.properties.length) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(\n            this.addHelper(\"objectDestructuringEmpty\"),\n            isPureVoid(objRef) ? [] : [objRef],\n          ),\n        ),\n      );\n      return;\n    }\n\n    // if we have more than one properties in this pattern and the objectRef is a\n    // member expression then we need to assign it to a temporary variable so it's\n    // only evaluated once\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    // Replace impure computed key expressions if we have a rest parameter\n    if (hasObjectRest(pattern)) {\n      let copiedPattern: t.ObjectPattern;\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (t.isRestElement(prop)) {\n          break;\n        }\n        const key = prop.key;\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(\n            //@ts-expect-error PrivateName has been handled by destructuring-private\n            this.buildVariableDeclaration(name, key),\n          );\n          if (!copiedPattern) {\n            copiedPattern = pattern = {\n              ...pattern,\n              properties: pattern.properties.slice(),\n            };\n          }\n          copiedPattern.properties[i] = {\n            ...prop,\n            key: name,\n          };\n        }\n      }\n    }\n\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n      if (t.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n\n  canUnpackArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: t.Expression,\n  ): arr is UnpackableArrayExpression {\n    // not an array so there's no way we can deal with this\n    if (!t.isArrayExpression(arr)) return false;\n\n    // pattern has less elements than the array and doesn't have a rest so some\n    // elements wont be evaluated\n    if (pattern.elements.length > arr.elements.length) return;\n    if (\n      pattern.elements.length < arr.elements.length &&\n      !hasArrayRest(pattern)\n    ) {\n      return false;\n    }\n\n    for (const elem of pattern.elements) {\n      // deopt on holes\n      if (!elem) return false;\n\n      // deopt on member expressions as they may be included in the RHS\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    for (const elem of arr.elements) {\n      // deopt on spread elements\n      if (t.isSpreadElement(elem)) return false;\n\n      // deopt call expressions as they might change values of LHS variables\n      if (t.isCallExpression(elem)) return false;\n\n      // deopt on member expressions as they may be getter/setters and have side-effects\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    // deopt on reference to left side identifiers\n    const bindings = t.getBindingIdentifiers(pattern);\n    const state: ArrayUnpackVisitorState = { deopt: false, bindings };\n\n    try {\n      t.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n\n    return !state.deopt;\n  }\n\n  pushUnpackedArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: UnpackableArrayExpression,\n  ) {\n    const holeToUndefined = (el: t.Expression) =>\n      el ?? this.scope.buildUndefinedNode();\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (t.isRestElement(elem)) {\n        this.push(\n          elem.argument,\n          t.arrayExpression(arr.elements.slice(i).map(holeToUndefined)),\n        );\n      } else {\n        this.push(elem, holeToUndefined(arr.elements[i]));\n      }\n    }\n  }\n\n  pushArrayPattern(pattern: t.ArrayPattern, arrayRef: t.Expression | null) {\n    if (arrayRef === null) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(this.addHelper(\"objectDestructuringEmpty\"), []),\n        ),\n      );\n      return;\n    }\n    if (!pattern.elements) return;\n\n    // optimise basic array destructuring of an array expression\n    //\n    // we can't do this to a pattern of unequal size to it's right hand\n    // array expression as then there will be values that wont be evaluated\n    //\n    // eg: let [a, b] = [1, 2];\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      return this.pushUnpackedArrayPattern(pattern, arrayRef);\n    }\n\n    // if we have a rest then we need all the elements so don't tell\n    // `scope.toArray` to only get a certain amount\n\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n\n    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n    // return a locally bound identifier if it's been inferred to be an array,\n    // otherwise it'll be a call to a helper that will ensure it's one\n\n    const toArray = this.toArray(arrayRef, count);\n\n    if (t.isIdentifier(toArray)) {\n      // we've been given an identifier so it must have been inferred to be an\n      // array\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    //\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n\n      // hole\n      if (!elem) continue;\n\n      let elemRef;\n\n      if (t.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = t.callExpression(\n          t.memberExpression(elemRef, t.identifier(\"slice\")),\n          [t.numericLiteral(i)],\n        );\n\n        // set the element to the rest element argument since we've dealt with it\n        // being a rest already\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n\n  init(pattern: t.LVal, ref: t.Expression) {\n    // trying to destructure a value that we can't evaluate more than once so we\n    // need to save it to a variable\n\n    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, t.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n\n    this.push(pattern, ref);\n\n    return this.nodes;\n  }\n}\n\ninterface ExcludingKey {\n  key: t.Expression | t.PrivateName;\n  computed: boolean;\n}\n\nexport function buildObjectExcludingKeys<T extends ExcludingKey>(\n  excludedKeys: T[],\n  objRef: t.Expression,\n  scope: Scope,\n  addHelper: File[\"addHelper\"],\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n): t.CallExpression {\n  // get all the keys that appear in this object before the current spread\n\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n    if (t.isIdentifier(key) && !prop.computed) {\n      keys.push(t.stringLiteral(key.name));\n    } else if (t.isTemplateLiteral(key)) {\n      keys.push(t.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (t.isLiteral(key)) {\n      // @ts-expect-error todo(flow->ts) NullLiteral\n      keys.push(t.stringLiteral(String(key.value)));\n    } else if (t.isPrivateName(key)) {\n      // private key is not enumerable\n    } else {\n      keys.push(t.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n\n  let value;\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : addHelper(\"extends\");\n    value = t.callExpression(extendsHelper, [\n      t.objectExpression([]),\n      t.sequenceExpression([\n        t.callExpression(addHelper(\"objectDestructuringEmpty\"), [\n          t.cloneNode(objRef),\n        ]),\n        t.cloneNode(objRef),\n      ]),\n    ]);\n  } else {\n    let keyExpression: t.Expression = t.arrayExpression(keys);\n\n    if (!allLiteral) {\n      keyExpression = t.callExpression(\n        t.memberExpression(keyExpression, t.identifier(\"map\")),\n        [addHelper(\"toPropertyKey\")],\n      );\n    } else if (!hasTemplateLiteral && !t.isProgram(scope.block)) {\n      // Hoist definition of excluded keys, so that it's not created each time.\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\",\n      });\n\n      keyExpression = t.cloneNode(id);\n    }\n\n    value = t.callExpression(\n      addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`),\n      [t.cloneNode(objRef), keyExpression],\n    );\n  }\n  return value;\n}\n\nexport function convertVariableDeclaration(\n  path: NodePath<t.VariableDeclaration>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope } = path;\n\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n\n    const patternId = declar.init;\n    const pattern = declar.id;\n\n    const destructuring: DestructuringTransformer =\n      new DestructuringTransformer({\n        // @ts-expect-error(todo): avoid internal properties access\n        blockHoist: node._blockHoist,\n        nodes: nodes,\n        scope: scope,\n        kind: node.kind,\n        iterableIsArray,\n        arrayLikeIsIterable,\n        useBuiltIns,\n        objectRestNoSymbols,\n        addHelper,\n      });\n\n    if (t.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n\n      if (+i !== node.declarations.length - 1) {\n        // we aren't the last declarator so let's just make the\n        // last transformed node inherit from us\n        t.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(\n        t.inherits(\n          destructuring.buildVariableAssignment(pattern, patternId),\n          declar,\n        ),\n      );\n    }\n  }\n\n  const inForInit = t.isForStatement(path.parent, { init: node });\n\n  let tail: t.VariableDeclaration | null = null;\n  const nodesOut = [];\n  for (const node of nodes) {\n    if (t.isVariableDeclaration(node)) {\n      if (tail !== null) {\n        // Create a single compound declarations\n        tail.declarations.push(...node.declarations);\n        continue;\n      } else {\n        // Make sure the original node kind is used for each compound declaration\n        node.kind = nodeKind;\n        tail = node;\n      }\n    } else {\n      tail = null;\n    }\n    // Propagate the original declaration node's location\n    if (!node.loc) {\n      node.loc = nodeLoc;\n    }\n    nodesOut.push(\n      inForInit && node.type === \"ExpressionStatement\" ? node.expression : node,\n    );\n  }\n\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n  scope.crawl();\n}\n\nexport function convertAssignmentExpression(\n  path: NodePath<t.AssignmentExpression>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope, parentPath } = path;\n\n  const nodes: DestructuringTransformerNode[] = [];\n\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper,\n  });\n\n  let ref: t.Identifier | void;\n  if (\n    (!parentPath.isExpressionStatement() &&\n      !parentPath.isSequenceExpression()) ||\n    path.isCompletionRecord()\n  ) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n    nodes.push(\n      t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]),\n    );\n\n    if (t.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n\n  destructuring.init(node.left, ref || node.right);\n\n  if (ref) {\n    if (parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(t.blockStatement([]));\n      nodes.push(t.returnStatement(t.cloneNode(ref)));\n    } else {\n      nodes.push(t.expressionStatement(t.cloneNode(ref)));\n    }\n  }\n\n  path.replaceWithMultiple(nodes);\n  scope.crawl();\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport {\n  DestructuringTransformer,\n  convertVariableDeclaration,\n  convertAssignmentExpression,\n  unshiftForXStatementBody,\n  type DestructuringTransformerNode,\n} from \"./util\";\nexport { buildObjectExcludingKeys, unshiftForXStatementBody } from \"./util\";\nimport type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a VariableDeclaration's declarations contains any Patterns.\n */\n\nfunction variableDeclarationHasPattern(node: t.VariableDeclaration) {\n  for (const declar of node.declarations) {\n    if (t.isPattern(declar.id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n  useBuiltIns?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { useBuiltIns = false } = options;\n\n  const iterableIsArray = (api.assumption(\"iterableIsArray\") ??\n    options.loose ??\n    false) as boolean;\n  const arrayLikeIsIterable = (options.allowArrayLike ??\n    api.assumption(\"arrayLikeIsIterable\") ??\n    false) as boolean;\n  const objectRestNoSymbols = (api.assumption(\"objectRestNoSymbols\") ??\n    options.loose ??\n    false) as boolean;\n\n  return {\n    name: \"transform-destructuring\",\n\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n        path.scope.crawl();\n      },\n\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const left = node.left;\n\n        if (t.isPattern(left)) {\n          // for ({ length: k } in { abc: 3 });\n\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const statementBody = path.node.body.body;\n          const nodes = [];\n          // todo: the completion of a for statement can only be observed from\n          // a do block (or eval that we don't support),\n          // but the new do-expression proposal plans to ban iteration ends in the\n          // do block, maybe we can get rid of this\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          nodes.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", left, t.cloneNode(temp)),\n            ),\n          );\n\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) return;\n\n        const pattern = left.declarations[0].id;\n        if (!t.isPattern(pattern)) return;\n\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = t.variableDeclaration(left.kind, [\n          t.variableDeclarator(key, null),\n        ]);\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n\n        destructuring.init(pattern, key);\n\n        unshiftForXStatementBody(path, nodes);\n        scope.crawl();\n      },\n\n      CatchClause({ node, scope }) {\n        const pattern = node.param;\n        if (!t.isPattern(pattern)) return;\n\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n        destructuring.init(pattern, ref);\n\n        node.body.body = [...nodes, ...node.body.body];\n        scope.crawl();\n      },\n\n      AssignmentExpression(path, state) {\n        if (!t.isPattern(path.node.left)) return;\n        convertAssignmentExpression(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n\n      VariableDeclaration(path, state) {\n        const { node, parent } = path;\n        if (t.isForXStatement(parent)) return;\n        if (!parent || !path.container) return; // i don't know why this is necessary - TODO\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n    },\n  };\n});\n"],"names":["isPureVoid","node","t","isUnaryExpression","operator","isPureish","argument","unshiftForXStatementBody","statementPath","newStatements","ensureBlock","scope","bodyScopeBindings","get","bindings","hasShadowedBlockScopedBindings","Object","keys","some","name","hasBinding","body","blockStatement","unshift","hasArrayRest","pattern","elements","elem","isRestElement","hasObjectRest","properties","prop","STOP_TRAVERSAL","arrayUnpackVisitor","ancestors","state","length","isIdentifier","isReferenced","deopt","DestructuringTransformer","constructor","opts","blockHoist","arrayRefSet","nodes","kind","iterableIsArray","arrayLikeIsIterable","objectRestNoSymbols","useBuiltIns","addHelper","Set","getExtendsHelper","memberExpression","identifier","buildVariableAssignment","id","init","op","isMemberExpression","expressionStatement","assignmentExpression","cloneNode","buildUndefinedNode","nodeInit","variableDeclaration","variableDeclarator","_blockHoist","buildVariableDeclaration","declar","push","_init","isObjectPattern","pushObjectPattern","isArrayPattern","pushArrayPattern","isAssignmentPattern","pushAssignmentPattern","toArray","count","has","left","right","valueRef","tempId","generateUidIdentifierBasedOnNode","tempConditional","conditionalExpression","binaryExpression","isPattern","patternId","generateUidIdentifier","pushObjectRest","objRef","spreadProp","spreadPropIndex","value","buildObjectExcludingKeys","slice","pushObjectProperty","propRef","isLiteral","key","computed","callExpression","isStatic","temp","copiedPattern","i","isPure","canUnpackArrayPattern","arr","isArrayExpression","isSpreadElement","isCallExpression","getBindingIdentifiers","traverse","e","pushUnpackedArrayPattern","holeToUndefined","el","arrayExpression","map","arrayRef","add","elemRef","numericLiteral","ref","memo","maybeGenerateMemoised","excludedKeys","allLiteral","hasTemplateLiteral","stringLiteral","isTemplateLiteral","String","isPrivateName","extendsHelper","objectExpression","sequenceExpression","keyExpression","isProgram","block","programScope","getProgramParent","convertVariableDeclaration","path","nodeKind","nodeLoc","loc","declarations","destructuring","inherits","inForInit","isForStatement","parent","tail","nodesOut","isVariableDeclaration","type","expression","replaceWith","replaceWithMultiple","crawl","convertAssignmentExpression","parentPath","isExpressionStatement","isSequenceExpression","isCompletionRecord","isArrowFunctionExpression","returnStatement","variableDeclarationHasPattern","declare","api","options","assertVersion","assumption","loose","allowArrayLike","visitor","ExportNamedDeclaration","declaration","specifiers","getOuterBindingIdentifiers","exportSpecifier","insertAfter","exportNamedDeclaration","ForXStatement","statementBody","CatchClause","param","AssignmentExpression","VariableDeclaration","isForXStatement","container"],"mappings":"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"}