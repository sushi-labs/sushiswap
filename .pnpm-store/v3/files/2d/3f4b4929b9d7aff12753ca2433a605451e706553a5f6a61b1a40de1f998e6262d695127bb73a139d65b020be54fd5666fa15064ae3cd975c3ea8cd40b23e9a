import EventEmitter from "eventemitter3";
import WalletConnect from "@walletconnect/client";
import QRCodeModal from "@walletconnect/qrcode-modal";
import { IJsonRpcConnection } from "@walletconnect/jsonrpc-types";
import { formatJsonRpcError } from "@walletconnect/jsonrpc-utils";
export class SignerConnection extends IJsonRpcConnection {
    constructor(opts) {
        super();
        this.events = new EventEmitter();
        this.accounts = [];
        this.chainId = 1;
        this.pending = false;
        this.bridge = "https://bridge.walletconnect.org";
        this.qrcode = true;
        this.qrcodeModalOptions = undefined;
        this.opts = opts;
        this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
        this.wc = this.register(opts);
    }
    get connected() {
        return typeof this.wc !== "undefined" && this.wc.connected;
    }
    get connecting() {
        return this.pending;
    }
    get connector() {
        this.wc = this.register(this.opts);
        return this.wc;
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async open(chainId) {
        if (this.connected) {
            this.onOpen();
            return;
        }
        return new Promise((resolve, reject) => {
            this.on("error", err => {
                reject(err);
            });
            this.on("open", () => {
                resolve();
            });
            this.create(chainId);
        });
    }
    async close() {
        if (typeof this.wc === "undefined")
            return;
        if (this.wc.connected) {
            this.wc.killSession();
        }
        this.onClose();
    }
    async send(payload) {
        this.wc = this.register(this.opts);
        if (!this.connected)
            await this.open();
        this.sendPayload(payload)
            .then((res) => this.events.emit("payload", res))
            .catch(e => this.events.emit("payload", formatJsonRpcError(payload.id, e.message)));
    }
    register(opts) {
        if (this.wc)
            return this.wc;
        this.opts = opts || this.opts;
        this.bridge = (opts === null || opts === void 0 ? void 0 : opts.connector)
            ? opts.connector.bridge
            : (opts === null || opts === void 0 ? void 0 : opts.bridge) || "https://bridge.walletconnect.org";
        this.qrcode = typeof (opts === null || opts === void 0 ? void 0 : opts.qrcode) === "undefined" || opts.qrcode !== false;
        this.chainId = typeof (opts === null || opts === void 0 ? void 0 : opts.chainId) !== "undefined" ? opts.chainId : this.chainId;
        this.qrcodeModalOptions = opts === null || opts === void 0 ? void 0 : opts.qrcodeModalOptions;
        const connectorOpts = {
            bridge: this.bridge,
            qrcodeModal: this.qrcode ? QRCodeModal : undefined,
            qrcodeModalOptions: this.qrcodeModalOptions,
            storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
            signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
            clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta,
        };
        this.wc =
            typeof (opts === null || opts === void 0 ? void 0 : opts.connector) !== "undefined" ? opts.connector : new WalletConnect(connectorOpts);
        if (typeof this.wc === "undefined") {
            throw new Error("Failed to register WalletConnect connector");
        }
        if (this.wc.accounts.length) {
            this.accounts = this.wc.accounts;
        }
        if (this.wc.chainId) {
            this.chainId = this.wc.chainId;
        }
        this.registerConnectorEvents();
        return this.wc;
    }
    onOpen(wc) {
        this.pending = false;
        if (wc) {
            this.wc = wc;
        }
        this.events.emit("open");
    }
    onClose() {
        this.pending = false;
        if (this.wc) {
            this.wc = undefined;
        }
        this.events.emit("close");
    }
    onError(payload, message = "Failed or Rejected Request", code = -32000) {
        const errorPayload = {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            error: { code, message },
        };
        this.events.emit("payload", errorPayload);
        return errorPayload;
    }
    create(chainId) {
        this.wc = this.register(this.opts);
        this.chainId = chainId || this.chainId;
        if (this.connected || this.pending)
            return;
        this.pending = true;
        this.registerConnectorEvents();
        this.wc
            .createSession({ chainId: this.chainId })
            .then(() => this.events.emit("created"))
            .catch((e) => this.events.emit("error", e));
    }
    registerConnectorEvents() {
        this.wc = this.register(this.opts);
        this.wc.on("connect", (err) => {
            var _a, _b;
            if (err) {
                this.events.emit("error", err);
                return;
            }
            this.accounts = ((_a = this.wc) === null || _a === void 0 ? void 0 : _a.accounts) || [];
            this.chainId = ((_b = this.wc) === null || _b === void 0 ? void 0 : _b.chainId) || this.chainId;
            this.onOpen();
        });
        this.wc.on("disconnect", (err) => {
            if (err) {
                this.events.emit("error", err);
                return;
            }
            this.onClose();
        });
        this.wc.on("modal_closed", () => {
            this.events.emit("error", new Error("User closed modal"));
        });
        this.wc.on("session_update", (error, payload) => {
            const { accounts, chainId } = payload.params[0];
            if (!this.accounts || (accounts && this.accounts !== accounts)) {
                this.accounts = accounts;
                this.events.emit("accountsChanged", accounts);
            }
            if (!this.chainId || (chainId && this.chainId !== chainId)) {
                this.chainId = chainId;
                this.events.emit("chainChanged", chainId);
            }
        });
    }
    async sendPayload(payload) {
        this.wc = this.register(this.opts);
        try {
            const response = await this.wc.unsafeSend(payload);
            return this.sanitizeResponse(response);
        }
        catch (error) {
            return this.onError(payload, error.message);
        }
    }
    sanitizeResponse(response) {
        return typeof response.error !== "undefined" &&
            typeof response.error.code === "undefined"
            ? formatJsonRpcError(response.id, response.error.message)
            : response;
    }
}
export default SignerConnection;
//# sourceMappingURL=index.js.map