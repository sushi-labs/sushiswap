{"version":3,"names":["FUNCTION_TYPES","arrowFunctionExpression","assignmentExpression","awaitExpression","blockStatement","callExpression","cloneNode","expressionStatement","identifier","inheritLeadingComments","inheritTrailingComments","inheritsComments","isExpression","isProgram","isStatement","removeComments","returnStatement","toSequenceExpression","validate","yieldExpression","replaceWithMultiple","nodes","resync","_verifyNodeList","node","length","pathCache","get","parent","delete","container","key","paths","insertAfter","requeue","remove","replaceWithSourceString","replacement","ast","parse","err","loc","message","codeFrameColumns","start","line","column","code","expressionAST","program","body","expression","traverse","removeProperties","replaceWith","replacementPath","removed","Error","NodePath","Array","isArray","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","parentPath","isExportDefaultDeclaration","replaceExpressionWithStatements","oldNode","_replaceWith","type","setScope","ReferenceError","inList","debug","set","nodesAsSequenceExpression","scope","functionParent","getFunctionParent","isParentAsync","is","isParentGenerator","callee","hoistVariables","id","push","completionRecords","getCompletionRecords","path","isExpressionStatement","loop","findParent","isLoop","uid","getData","generateDeclaredUidIdentifier","pushContainer","setData","name","arrowFunctionToExpression","newCallee","needToAwaitFunction","hasType","needToYieldFunction","replaceInline","_containerInsertAfter"],"sources":["../../src/path/replacement.ts"],"sourcesContent":["// This file contains methods responsible for replacing a node with another.\n\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport traverse from \"../index\";\nimport NodePath from \"./index\";\nimport { path as pathCache } from \"../cache\";\nimport { parse } from \"@babel/parser\";\nimport {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport hoistVariables from \"@babel/helper-hoist-variables\";\n\n/**\n * Replace a node with an array of multiple. This method performs the following steps:\n *\n *  - Inherit the comments of first provided node with that of the current node.\n *  - Insert the provided nodes after the current node.\n *  - Remove the current node.\n */\n\nexport function replaceWithMultiple(\n  this: NodePath,\n  nodes: t.Node | t.Node[],\n): NodePath[] {\n  this.resync();\n\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  pathCache.get(this.parent)?.delete(this.node);\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n  return paths;\n}\n\n/**\n * Parse a string as an expression and replace the current node with the result.\n *\n * NOTE: This is typically not a good idea to use. Building source strings when\n * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's\n * easier to use, your transforms will be extremely brittle.\n */\n\nexport function replaceWithSourceString(this: NodePath, replacement: string) {\n  this.resync();\n  let ast: t.File;\n\n  try {\n    replacement = `(${replacement})`;\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    ast = parse(replacement);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message +=\n        \" - make sure this is an expression.\\n\" +\n        codeFrameColumns(replacement, {\n          start: {\n            line: loc.line,\n            column: loc.column + 1,\n          },\n        });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n    throw err;\n  }\n\n  const expressionAST = (ast.program.body[0] as t.ExpressionStatement)\n    .expression;\n  traverse.removeProperties(expressionAST);\n  return this.replaceWith(expressionAST);\n}\n\n/**\n * Replace the current node with another.\n */\n\nexport function replaceWith<R extends t.Node>(\n  this: NodePath,\n  replacementPath: R | NodePath<R>,\n): [NodePath<R>] {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  let replacement: t.Node =\n    replacementPath instanceof NodePath\n      ? replacementPath.node\n      : replacementPath;\n\n  if (!replacement) {\n    throw new Error(\n      \"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\",\n    );\n  }\n\n  if (this.node === replacement) {\n    return [this as NodePath<R>];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\n      \"You can only replace a Program root node with another Program node\",\n    );\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\",\n    );\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\",\n    );\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement) &&\n      !this.parentPath.isExportDefaultDeclaration()\n    ) {\n      // replacing a statement with an expression so wrap it in an expression statement\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement)\n    ) {\n      // replacing an expression with a statement so let's explode it\n      return this.replaceExpressionWithStatements([replacement]) as [\n        NodePath<R>,\n      ];\n    }\n  }\n\n  const oldNode = this.node;\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  // replace the node\n  this._replaceWith(replacement);\n  this.type = replacement.type;\n\n  // potentially create new scope\n  this.setScope();\n\n  // requeue for visiting\n  this.requeue();\n\n  return [\n    nodePath ? (this.get(nodePath) as NodePath<R>) : (this as NodePath<R>),\n  ];\n}\n\n/**\n * Description\n */\n\nexport function _replaceWith(this: NodePath, node: t.Node) {\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    // @ts-expect-error todo(flow->ts): check if validate accepts a numeric key\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key as string, node);\n  }\n\n  this.debug(`Replace with ${node?.type}`);\n  pathCache.get(this.parent)?.set(node, this).delete(this.node);\n\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = node;\n}\n\n/**\n * This method takes an array of statements nodes and then explodes it\n * into expressions. This method retains completion records which is\n * extremely important to retain original semantics.\n */\n\nexport function replaceExpressionWithStatements(\n  this: NodePath,\n  nodes: Array<t.Statement>,\n) {\n  this.resync();\n\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent?.is(\"async\");\n  const isParentGenerator = functionParent?.is(\"generator\");\n\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n\n  this.replaceWith(callExpression(container, []));\n  // replaceWith changes the type of \"this\", but it isn't trackable by TS\n  type ThisType = NodePath<\n    t.CallExpression & {\n      callee: t.ArrowFunctionExpression & { body: t.BlockStatement };\n    }\n  >;\n\n  // hoist variable declaration in do block\n  // `(do { var x = 1; x;})` -> `var x; (() => { x = 1; return x; })()`\n  const callee = (this as ThisType).get(\"callee\");\n  hoistVariables(\n    callee.get(\"body\"),\n    (id: t.Identifier) => {\n      this.scope.push({ id });\n    },\n    \"var\",\n  );\n\n  // add implicit returns to all ending expression statements\n  const completionRecords: Array<NodePath> = (this as ThisType)\n    .get(\"callee\")\n    .getCompletionRecords();\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n\n    const loop = path.findParent(path => path.isLoop());\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee\n          .get(\"body\")\n          .pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path\n        .get(\"expression\")\n        .replaceWith(\n          assignmentExpression(\"=\", cloneNode(uid), path.node.expression),\n        );\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n  callee.arrowFunctionToExpression();\n  // Fixme: we can not `assert this is NodePath<t.FunctionExpression>` in `arrowFunctionToExpression`\n  // because it is not a class method known at compile time.\n  const newCallee = callee as unknown as NodePath<t.FunctionExpression>;\n\n  // (() => await xxx)() -> await (async () => await xxx)();\n  const needToAwaitFunction =\n    isParentAsync &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"AwaitExpression\",\n      FUNCTION_TYPES,\n    );\n  const needToYieldFunction =\n    isParentGenerator &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"YieldExpression\",\n      FUNCTION_TYPES,\n    );\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n    // yield* will await the generator return result\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression((this as ThisType).node));\n    }\n  }\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression((this as ThisType).node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nexport function replaceInline(this: NodePath, nodes: t.Node | Array<t.Node>) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n      const paths = this._containerInsertAfter(nodes);\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}\n"],"mappings":"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"}