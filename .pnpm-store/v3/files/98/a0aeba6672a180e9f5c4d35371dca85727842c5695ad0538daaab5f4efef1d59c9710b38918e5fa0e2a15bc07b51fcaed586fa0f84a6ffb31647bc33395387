{"version":3,"file":"index.js","sources":["../src/shouldStoreRHSInTemporaryVariable.ts","../src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\n\nconst {\n  isObjectProperty,\n  isArrayPattern,\n  isObjectPattern,\n  isAssignmentPattern,\n  isRestElement,\n  isIdentifier,\n} = t;\n/**\n * This is a helper function to determine if we should create an intermediate variable\n * such that the RHS of an assignment is not duplicated.\n *\n * See https://github.com/babel/babel/pull/13711#issuecomment-914388382 for discussion\n * on further optimizations.\n */\nexport default function shouldStoreRHSInTemporaryVariable(\n  node: t.LVal,\n): boolean {\n  if (isArrayPattern(node)) {\n    const nonNullElements = node.elements.filter(element => element !== null);\n    if (nonNullElements.length > 1) return true;\n    else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);\n  } else if (isObjectPattern(node)) {\n    const { properties } = node;\n    if (properties.length > 1) return true;\n    else if (properties.length === 0) return false;\n    else {\n      const firstProperty = properties[0];\n      if (isObjectProperty(firstProperty)) {\n        // the value of the property must be an LVal\n        return shouldStoreRHSInTemporaryVariable(firstProperty.value as t.LVal);\n      } else {\n        return shouldStoreRHSInTemporaryVariable(firstProperty);\n      }\n    }\n  } else if (isAssignmentPattern(node)) {\n    return shouldStoreRHSInTemporaryVariable(node.left);\n  } else if (isRestElement(node)) {\n    if (isIdentifier(node.argument)) return true;\n    return shouldStoreRHSInTemporaryVariable(node.argument);\n  } else {\n    // node is Identifier or MemberExpression\n    return false;\n  }\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxObjectRestSpread from \"@babel/plugin-syntax-object-rest-spread\";\nimport { types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nimport { convertFunctionParams } from \"@babel/plugin-transform-parameters\";\nimport { isRequired } from \"@babel/helper-compilation-targets\";\nimport compatData from \"@babel/compat-data/corejs2-built-ins\";\nimport shouldStoreRHSInTemporaryVariable from \"./shouldStoreRHSInTemporaryVariable\";\n\nconst { isAssignmentPattern, isObjectProperty } = t;\n// @babel/types <=7.3.3 counts FOO as referenced in var { x: FOO }.\n// We need to detect this bug to know if \"unused\" means 0 or 1 references.\nif (!process.env.BABEL_8_BREAKING) {\n  const node = t.identifier(\"a\");\n  const property = t.objectProperty(t.identifier(\"key\"), node);\n  const pattern = t.objectPattern([property]);\n\n  // eslint-disable-next-line no-var\n  var ZERO_REFS = t.isReferenced(node, property, pattern) ? 1 : 0;\n}\n\ntype Param = NodePath<t.Function[\"params\"][number]>;\nexport interface Options {\n  useBuiltIns?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const targets = api.targets();\n  const supportsObjectAssign = !isRequired(\"es6.object.assign\", targets, {\n    compatData,\n  });\n\n  const { useBuiltIns = supportsObjectAssign, loose = false } = opts;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n\n  const ignoreFunctionLength = api.assumption(\"ignoreFunctionLength\") ?? loose;\n  const objectRestNoSymbols = api.assumption(\"objectRestNoSymbols\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n  const setSpreadProperties = api.assumption(\"setSpreadProperties\") ?? loose;\n\n  function getExtendsHelper(\n    file: PluginPass,\n  ): t.MemberExpression | t.Identifier {\n    return useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : file.addHelper(\"extends\");\n  }\n\n  function hasRestElement(path: Param) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      foundRestElement = true;\n      restElement.stop();\n    });\n    return foundRestElement;\n  }\n\n  function hasObjectPatternRestElement(path: NodePath): boolean {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      if (restElement.parentPath.isObjectPattern()) {\n        foundRestElement = true;\n        restElement.stop();\n      }\n    });\n    return foundRestElement;\n  }\n\n  function visitRestElements(\n    path: NodePath,\n    visitor: (path: NodePath<t.RestElement>) => any,\n  ) {\n    path.traverse({\n      Expression(path) {\n        const { parent, key } = path;\n        if (\n          (isAssignmentPattern(parent) && key === \"right\") ||\n          (isObjectProperty(parent) && parent.computed && key === \"key\")\n        ) {\n          path.skip();\n        }\n      },\n      RestElement: visitor,\n    });\n  }\n\n  function hasSpread(node: t.ObjectExpression): boolean {\n    for (const prop of node.properties) {\n      if (t.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // returns an array of all keys of an object, and a status flag indicating if all extracted keys\n  // were converted to stringLiterals or not\n  // e.g. extracts {keys: [\"a\", \"b\", \"3\", ++x], allLiteral: false }\n  // from ast of {a: \"foo\", b, 3: \"bar\", [++x]: \"baz\"}\n  function extractNormalizedKeys(node: t.ObjectPattern) {\n    // RestElement has been removed in createObjectRest\n    const props = node.properties as t.ObjectProperty[];\n    const keys: t.Expression[] = [];\n    let allLiteral = true;\n    let hasTemplateLiteral = false;\n\n    for (const prop of props) {\n      if (t.isIdentifier(prop.key) && !prop.computed) {\n        // since a key {a: 3} is equivalent to {\"a\": 3}, use the latter\n        keys.push(t.stringLiteral(prop.key.name));\n      } else if (t.isTemplateLiteral(prop.key)) {\n        keys.push(t.cloneNode(prop.key));\n        hasTemplateLiteral = true;\n      } else if (t.isLiteral(prop.key)) {\n        keys.push(\n          t.stringLiteral(\n            String(\n              // @ts-expect-error prop.key can not be a NullLiteral\n              prop.key.value,\n            ),\n          ),\n        );\n      } else {\n        // @ts-expect-error private name has been handled by destructuring-private\n        keys.push(t.cloneNode(prop.key));\n        allLiteral = false;\n      }\n    }\n\n    return { keys, allLiteral, hasTemplateLiteral };\n  }\n\n  // replaces impure computed keys with new identifiers\n  // and returns variable declarators of these new identifiers\n  function replaceImpureComputedKeys(\n    properties: NodePath<t.ObjectProperty>[],\n    scope: Scope,\n  ) {\n    const impureComputedPropertyDeclarators: t.VariableDeclarator[] = [];\n    for (const propPath of properties) {\n      // PrivateName is handled in destructuring-private plugin\n      const key = propPath.get(\"key\") as NodePath<t.Expression>;\n      if (propPath.node.computed && !key.isPure()) {\n        const name = scope.generateUidBasedOnNode(key.node);\n        const declarator = t.variableDeclarator(t.identifier(name), key.node);\n        impureComputedPropertyDeclarators.push(declarator);\n        key.replaceWith(t.identifier(name));\n      }\n    }\n    return impureComputedPropertyDeclarators;\n  }\n\n  function removeUnusedExcludedKeys(path: NodePath<t.ObjectPattern>): void {\n    const bindings = path.getOuterBindingIdentifierPaths();\n\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n      if (\n        path.scope.getBinding(bindingName).references >\n          (process.env.BABEL_8_BREAKING ? 0 : ZERO_REFS) ||\n        !bindingParentPath.isObjectProperty()\n      ) {\n        return;\n      }\n      bindingParentPath.remove();\n    });\n  }\n\n  //expects path to an object pattern\n  function createObjectRest(\n    path: NodePath<t.ObjectPattern>,\n    file: PluginPass,\n    objRef: t.Identifier | t.MemberExpression,\n  ): [t.VariableDeclarator[], t.LVal, t.CallExpression] {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n    t.assertRestElement(last.node);\n    const restElement = t.cloneNode(last.node);\n    last.remove();\n\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(\n      path.get(\"properties\") as NodePath<t.ObjectProperty>[],\n      path.scope,\n    );\n    const { keys, allLiteral, hasTemplateLiteral } = extractNormalizedKeys(\n      path.node,\n    );\n\n    if (keys.length === 0) {\n      return [\n        impureComputedPropertyDeclarators,\n        restElement.argument,\n        t.callExpression(getExtendsHelper(file), [\n          t.objectExpression([]),\n          t.sequenceExpression([\n            t.callExpression(file.addHelper(\"objectDestructuringEmpty\"), [\n              t.cloneNode(objRef),\n            ]),\n            t.cloneNode(objRef),\n          ]),\n        ]),\n      ];\n    }\n\n    let keyExpression;\n    if (!allLiteral) {\n      // map to toPropertyKey to handle the possible non-string values\n      keyExpression = t.callExpression(\n        t.memberExpression(t.arrayExpression(keys), t.identifier(\"map\")),\n        [file.addHelper(\"toPropertyKey\")],\n      );\n    } else {\n      keyExpression = t.arrayExpression(keys);\n\n      if (!hasTemplateLiteral && !t.isProgram(path.scope.block)) {\n        // Hoist definition of excluded keys, so that it's not created each time.\n        const program = path.findParent(path => path.isProgram());\n        const id = path.scope.generateUidIdentifier(\"excluded\");\n\n        program.scope.push({\n          id,\n          init: keyExpression,\n          kind: \"const\",\n        });\n\n        keyExpression = t.cloneNode(id);\n      }\n    }\n\n    return [\n      impureComputedPropertyDeclarators,\n      restElement.argument,\n      t.callExpression(\n        file.addHelper(\n          `objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`,\n        ),\n        [t.cloneNode(objRef), keyExpression],\n      ),\n    ];\n  }\n\n  function replaceRestElement(\n    parentPath: NodePath<t.Function | t.CatchClause>,\n    paramPath: NodePath<\n      t.Function[\"params\"][number] | t.AssignmentPattern[\"left\"]\n    >,\n    container?: t.VariableDeclaration[],\n  ): void {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n\n    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n\n    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n\n      const declar = t.variableDeclaration(\"let\", [\n        t.variableDeclarator(paramPath.node, uid),\n      ]);\n\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        parentPath.get(\"body\").unshiftContainer(\"body\", declar);\n      }\n      paramPath.replaceWith(t.cloneNode(uid));\n    }\n  }\n\n  return {\n    name: \"proposal-object-rest-spread\",\n    inherits: syntaxObjectRestSpread.default,\n\n    visitor: {\n      // function a({ b, ...c }) {}\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set<number>();\n        const idsInRestParams = new Set();\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n          if (hasRestElement(param)) {\n            paramsWithRestElement.add(i);\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n\n        // if true, a parameter exists that has an id in its initializer\n        // that is also an id bound in a rest parameter\n        // example: f({...R}, a = R)\n        let idInRest = false;\n\n        const IdentifierHandler = function (\n          path: NodePath<t.Identifier>,\n          functionScope: Scope,\n        ) {\n          const name = path.node.name;\n          if (\n            path.scope.getBinding(name) === functionScope.getBinding(name) &&\n            idsInRestParams.has(name)\n          ) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n\n        let i: number;\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(param, path.scope);\n            } else {\n              param.traverse(\n                {\n                  \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                  \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler,\n                },\n                path.scope,\n              );\n            }\n          }\n        }\n\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(path, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = (idx: number) =>\n            idx >= i - 1 || paramsWithRestElement.has(idx);\n          convertFunctionParams(\n            path,\n            ignoreFunctionLength,\n            shouldTransformParam,\n            replaceRestElement,\n          );\n        }\n      },\n\n      // adapted from transform-destructuring/src/index.js#pushObjectRest\n      // const { a, ...b } = c;\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n\n        let insertionPath = path;\n        const originalPath = path;\n\n        visitRestElements(path.get(\"id\"), path => {\n          if (!path.parentPath.isObjectPattern()) {\n            // Return early if the parent is not an ObjectPattern, but\n            // (for example) an ArrayPattern or Function, because that\n            // means this RestElement is an not an object property.\n            return;\n          }\n\n          if (\n            // skip single-property case, e.g.\n            // const { ...x } = foo();\n            // since the RHS will not be duplicated\n            shouldStoreRHSInTemporaryVariable(originalPath.node.id) &&\n            !t.isIdentifier(originalPath.node.init)\n          ) {\n            // const { a, ...b } = foo();\n            // to avoid calling foo() twice, as a first step convert it to:\n            // const _foo = foo(),\n            //       { a, ...b } = _foo;\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(\n              originalPath.node.init,\n              \"ref\",\n            );\n            // insert _foo = foo()\n            originalPath.insertBefore(\n              t.variableDeclarator(initRef, originalPath.node.init),\n            );\n            // replace foo() with _foo\n            originalPath.replaceWith(\n              t.variableDeclarator(originalPath.node.id, t.cloneNode(initRef)),\n            );\n\n            return;\n          }\n\n          let ref = originalPath.node.init;\n          const refPropertyPath: NodePath<t.ObjectProperty>[] = [];\n          let kind;\n\n          path.findParent((path: NodePath): boolean => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = (path.parentPath as NodePath<t.VariableDeclaration>).node\n                .kind;\n              return true;\n            }\n          });\n\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(\n            refPropertyPath,\n            path.scope,\n          );\n          refPropertyPath.forEach(prop => {\n            const { node } = prop;\n            ref = t.memberExpression(\n              ref,\n              t.cloneNode(node.key),\n              node.computed || t.isLiteral(node.key),\n            );\n          });\n\n          //@ts-expect-error: findParent can not apply assertions on result shape\n          const objectPatternPath: NodePath<t.ObjectPattern> = path.findParent(\n            path => path.isObjectPattern(),\n          );\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(\n              objectPatternPath,\n              file,\n              ref as t.MemberExpression,\n            );\n\n          if (pureGetters) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n\n          t.assertIdentifier(argument);\n\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n\n          insertionPath = insertionPath.insertAfter(\n            t.variableDeclarator(argument, callExpression),\n          )[0] as NodePath<t.VariableDeclarator>;\n\n          path.scope.registerBinding(kind, insertionPath);\n\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath\n              .findParent(\n                path => path.isObjectProperty() || path.isVariableDeclarator(),\n              )\n              .remove();\n          }\n        });\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      // export var { a, ...b } = c;\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n\n        const hasRest = declaration\n          .get(\"declarations\")\n          .some(path => hasObjectPatternRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(true))) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n      },\n\n      // try {} catch ({a, ...b}) {}\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(path, paramPath);\n      },\n\n      // ({a, ...b} = c);\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {\n          const nodes = [];\n\n          const refName = path.scope.generateUidBasedOnNode(\n            path.node.right,\n            \"ref\",\n          );\n\n          nodes.push(\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(t.identifier(refName), path.node.right),\n            ]),\n          );\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(leftPath, file, t.identifier(refName));\n\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(\n              t.variableDeclaration(\"var\", impureComputedPropertyDeclarators),\n            );\n          }\n\n          const nodeWithoutSpread = t.cloneNode(path.node);\n          nodeWithoutSpread.right = t.identifier(refName);\n          nodes.push(t.expressionStatement(nodeWithoutSpread));\n          nodes.push(\n            t.toStatement(\n              t.assignmentExpression(\"=\", argument, callExpression),\n            ),\n          );\n          nodes.push(t.expressionStatement(t.identifier(refName)));\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const leftPath = path.get(\"left\");\n        const left = node.left;\n\n        if (!hasObjectPatternRestElement(leftPath)) {\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) {\n          // for ({a, ...b} of []) {}\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const body = path.node.body;\n\n          if (body.body.length === 0 && path.isCompletionRecord()) {\n            body.body.unshift(\n              t.expressionStatement(scope.buildUndefinedNode()),\n            );\n          }\n\n          body.body.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", left, t.cloneNode(temp)),\n            ),\n          );\n        } else {\n          // for (var {a, ...b} of []) {}\n          const pattern = left.declarations[0].id;\n\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = t.variableDeclaration(left.kind, [\n            t.variableDeclarator(key, null),\n          ]);\n\n          path.ensureBlock();\n          const body = node.body as t.BlockStatement;\n\n          body.body.unshift(\n            t.variableDeclaration(node.left.kind, [\n              t.variableDeclarator(pattern, t.cloneNode(key)),\n            ]),\n          );\n        }\n      },\n\n      // [{a, ...b}] = c;\n      ArrayPattern(path) {\n        const objectPatterns: t.VariableDeclarator[] = [];\n\n        visitRestElements(path, path => {\n          if (!path.parentPath.isObjectPattern()) {\n            // Return early if the parent is not an ObjectPattern, but\n            // (for example) an ArrayPattern or Function, because that\n            // means this RestElement is an not an object property.\n            return;\n          }\n\n          const objectPattern = path.parentPath;\n\n          const uid = path.scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push(t.variableDeclarator(objectPattern.node, uid));\n\n          objectPattern.replaceWith(t.cloneNode(uid));\n          path.skip();\n        });\n\n        if (objectPatterns.length > 0) {\n          const statementPath = path.getStatementParent();\n          const statementNode = statementPath.node;\n          const kind =\n            statementNode.type === \"VariableDeclaration\"\n              ? statementNode.kind\n              : \"var\";\n          statementPath.insertAfter(\n            t.variableDeclaration(kind, objectPatterns),\n          );\n        }\n      },\n\n      // var a = { ...b, ...c }\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n\n        let helper: t.Identifier | t.MemberExpression;\n        if (setSpreadProperties) {\n          helper = getExtendsHelper(file);\n        } else {\n          try {\n            helper = file.addHelper(\"objectSpread2\");\n          } catch {\n            // TODO: This is needed to workaround https://github.com/babel/babel/issues/10187\n            // and https://github.com/babel/babel/issues/10179 for older @babel/core versions\n            // where #10187 isn't fixed.\n            this.file.declarations[\"objectSpread2\"] = null;\n\n            // objectSpread2 has been introduced in v7.5.0\n            // We have to maintain backward compatibility.\n            helper = file.addHelper(\"objectSpread\");\n          }\n        }\n\n        let exp: t.CallExpression = null;\n        let props: t.ObjectMember[] = [];\n\n        function make() {\n          const hadProps = props.length > 0;\n          const obj = t.objectExpression(props);\n          props = [];\n\n          if (!exp) {\n            exp = t.callExpression(helper, [obj]);\n            return;\n          }\n\n          // When we can assume that getters are pure and don't depend on\n          // the order of evaluation, we can avoid making multiple calls.\n          if (pureGetters) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n            return;\n          }\n\n          exp = t.callExpression(t.cloneNode(helper), [\n            exp,\n            // If we have static props, we need to insert an empty object\n            // because the odd arguments are copied with [[Get]], not\n            // [[GetOwnProperty]]\n            ...(hadProps ? [t.objectExpression([]), obj] : []),\n          ]);\n        }\n\n        for (const prop of path.node.properties) {\n          if (t.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n\n        if (props.length) make();\n\n        path.replaceWith(exp);\n      },\n    },\n  };\n});\n"],"names":["isObjectProperty","isArrayPattern","isObjectPattern","isAssignmentPattern","isRestElement","isIdentifier","t","shouldStoreRHSInTemporaryVariable","node","nonNullElements","elements","filter","element","length","properties","firstProperty","value","left","argument","identifier","property","objectProperty","pattern","objectPattern","ZERO_REFS","isReferenced","declare","api","opts","assertVersion","targets","supportsObjectAssign","isRequired","compatData","useBuiltIns","loose","Error","ignoreFunctionLength","assumption","objectRestNoSymbols","pureGetters","setSpreadProperties","getExtendsHelper","file","memberExpression","addHelper","hasRestElement","path","foundRestElement","visitRestElements","restElement","stop","hasObjectPatternRestElement","parentPath","visitor","traverse","Expression","parent","key","computed","skip","RestElement","hasSpread","prop","isSpreadElement","extractNormalizedKeys","props","keys","allLiteral","hasTemplateLiteral","push","stringLiteral","name","isTemplateLiteral","cloneNode","isLiteral","String","replaceImpureComputedKeys","scope","impureComputedPropertyDeclarators","propPath","get","isPure","generateUidBasedOnNode","declarator","variableDeclarator","replaceWith","removeUnusedExcludedKeys","bindings","getOuterBindingIdentifierPaths","Object","forEach","bindingName","bindingParentPath","getBinding","references","remove","createObjectRest","objRef","last","assertRestElement","callExpression","objectExpression","sequenceExpression","keyExpression","arrayExpression","isProgram","block","program","findParent","id","generateUidIdentifier","init","kind","replaceRestElement","paramPath","container","i","uid","declar","variableDeclaration","ensureBlock","unshiftContainer","inherits","syntaxObjectRestSpread","default","Function","params","paramsWithRestElement","Set","idsInRestParams","param","add","getBindingIdentifiers","idInRest","IdentifierHandler","functionScope","has","isReferencedIdentifier","isBindingIdentifier","shouldTransformParam","idx","convertFunctionParams","VariableDeclarator","insertionPath","originalPath","initRef","generateUidIdentifierBasedOnNode","insertBefore","ref","refPropertyPath","unshift","isVariableDeclarator","impureObjRefComputedDeclarators","objectPatternPath","assertIdentifier","insertAfter","registerBinding","ExportNamedDeclaration","declaration","isVariableDeclaration","hasRest","some","specifiers","getOuterBindingIdentifiers","exportSpecifier","exportNamedDeclaration","CatchClause","AssignmentExpression","leftPath","nodes","refName","right","nodeWithoutSpread","expressionStatement","toStatement","assignmentExpression","replaceWithMultiple","ForXStatement","temp","body","isCompletionRecord","buildUndefinedNode","declarations","ArrayPattern","objectPatterns","statementPath","getStatementParent","statementNode","type","ObjectExpression","helper","exp","make","hadProps","obj","arguments"],"mappings":"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"}