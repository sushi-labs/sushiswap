var j=(r,e,t)=>{if(!e.has(r))throw TypeError("Cannot "+t)};var s=(r,e,t)=>(j(r,e,"read from private field"),t?t.call(r):e.get(r)),l=(r,e,t)=>{if(e.has(r))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(r):e.set(r,t)},o=(r,e,t,i)=>(j(r,e,"write to private field"),i?i.call(r,t):e.set(r,t),t),x=(r,e,t,i)=>({set _(a){o(r,e,a,t)},get _(){return s(r,e,i)}}),P=(r,e,t)=>(j(r,e,"access private method"),t);var f,b,v,u,h,n,g,p,T,m,D;function L(r=!1){let e=0,t={resolve:()=>{},reject:()=>{},state:r?"resolved":"pending",currentUid:e};function i(d,c){return(...S)=>{if(t.currentUid===d)return c(...S)}}let a={promise:r?Promise.resolve():new Promise((d,c)=>{Object.assign(t,{resolve:i(e,d),reject:i(e,c)})})};return{get promise(){return a.promise},resolve(d){return t.resolve(d)},reject(d){return t.reject(d)},reset(){t.state!=="pending"&&(t.currentUid=++e,a.promise=r?Promise.resolve():new Promise((d,c)=>{Object.assign(t,{resolve:i(e,d),reject:i(e,c)})}))}}}const y=class{constructor(e,t){l(this,m);l(this,v,void 0);l(this,u,void 0);l(this,h,void 0);l(this,n,void 0);l(this,g,void 0);l(this,p,void 0);l(this,T,void 0);o(this,v,x(y,b)._++),o(this,u,new Set),o(this,h,new Set),o(this,p,t!=null?t:"<unknown>"),o(this,n,"pending"),o(this,T,e)}static create(e,t){let i=new y(e,t);return s(this,f).add(i),i}add(e){s(this,n)==="settled"&&o(this,n,"resolved"),s(this,h).add(e),s(e,u).add(this)}remove(e){s(this,h).delete(e),s(e,u).delete(this)}get settled(){return s(this,n)==="settled"?!0:s(this,n)==="resolved"&&Array.from(s(this,h)).every(e=>e.settled)}resolve(e){s(this,n)==="settled"||s(this,n)==="resolved"||(o(this,g,e),o(this,n,"resolved"),P(this,m,D).call(this))}reset(){o(this,n,"pending")}static debugAll(e="	"){let t=new Set;for(const a of s(this,f))s(a,u).size===0&&t.add(a);let i="";for(const a of t)i+=a.debugDescription(e)+`
`;return i}debugDescription(e="	"){const t=[];for(const i of this.debugLines(e))t.push(i);return t.join(`
`)}*debugLines(e,t=0){yield`${e.repeat(t)}<Node ${s(this,v)}: '${s(this,p)}'> [${s(this,n)}]`;for(const d of s(this,h))yield*d.debugLines(e,t+1)}};let w=y;f=new WeakMap,b=new WeakMap,v=new WeakMap,u=new WeakMap,h=new WeakMap,n=new WeakMap,g=new WeakMap,p=new WeakMap,T=new WeakMap,m=new WeakSet,D=function(){this.settled&&(o(this,n,"settled"),s(this,T).call(this,s(this,g))),s(this,u).forEach(e=>{var t;return P(t=e,m,D).call(t)})},l(w,f,new Set),l(w,b,1);export{w as DeferredNode,L as defer};
