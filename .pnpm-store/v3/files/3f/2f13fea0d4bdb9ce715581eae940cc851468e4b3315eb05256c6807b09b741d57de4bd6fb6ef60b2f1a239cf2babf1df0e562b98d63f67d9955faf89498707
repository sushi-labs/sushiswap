{"version":3,"names":["hasExports","metadata","isSideEffectImport","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","validateImportInteropOption","importInterop","Error","resolveImportInterop","filename","normalizeModuleAndLoadMetadata","programPath","exportName","initializeReexports","lazy","esNamespaceOnly","scope","generateUidIdentifier","name","stringSpecifiers","Set","nameAnonymousExports","local","getModuleMetadata","removeModuleDeclarations","values","next","value","resolvedInterop","interop","exportNameListName","getExportSpecifierName","path","isIdentifier","node","isStringLiteral","stringValue","isIdentifierName","add","type","assertExportSpecifier","isExportSpecifier","isExportNamespaceSpecifier","buildCodeFrameError","localData","getLocalExportMetadata","sourceData","Map","getData","sourceNode","data","get","basename","extname","loc","set","forEach","child","isImportDeclaration","spec","isImportDefaultSpecifier","localName","reexport","delete","names","isImportNamespaceSpecifier","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportDefaultDeclaration","needsDefault","needsNamed","test","Array","isArray","indexOf","bindingKindLookup","kind","declaration","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","Object","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","push","exported","splitExportDeclaration","remove","_blockHoist","replaceWith"],"sources":["../src/normalize-and-load-metadata.ts"],"sourcesContent":["import { basename, extname } from \"path\";\nimport type * as t from \"@babel/types\";\n\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface ModuleMetadata {\n  exportName: string;\n  // The name of the variable that will reference an object containing export names.\n  exportNameListName: null | string;\n  hasExports: boolean;\n  // Lookup from local binding to export information.\n  local: Map<string, LocalExportMetadata>;\n  // Lookup of source file to source file metadata.\n  source: Map<string, SourceModuleMetadata>;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n}\n\nexport type InteropType =\n  | \"default\" // Babel interop for default-only imports\n  | \"namespace\" // Babel interop for namespace or default+named imports\n  | \"node-default\" // Node.js interop for default-only imports\n  | \"node-namespace\" // Node.js interop for namespace or default+named imports\n  | \"none\"; // No interop, or named-only imports\n\nexport type ImportInterop =\n  | \"none\"\n  | \"babel\"\n  | \"node\"\n  | ((source: string, filename?: string) => \"none\" | \"babel\" | \"node\");\n\nexport type Lazy = boolean | string[] | ((source: string) => boolean);\n\nexport interface SourceModuleMetadata {\n  // A unique variable name to use for this namespace object. Centralized for simplicity.\n  name: string;\n  loc: t.SourceLocation | undefined | null;\n  interop: InteropType;\n  // Local binding to reference from this source namespace. Key: Local name, value: Import name\n  imports: Map<string, string>;\n  // Local names that reference namespace object.\n  importsNamespace: Set<string>;\n  // Reexports to create for namespace. Key: Export name, value: Import name\n  reexports: Map<string, string>;\n  // List of names to re-export namespace as.\n  reexportNamespace: Set<string>;\n  // Tracks if the source should be re-exported.\n  reexportAll: null | {\n    loc: t.SourceLocation | undefined | null;\n  };\n  lazy?: Lazy;\n}\n\nexport interface LocalExportMetadata {\n  names: Array<string>; // names of exports,\n  kind: \"import\" | \"hoisted\" | \"block\" | \"var\";\n}\n\n/**\n * Check if the module has any exports that need handling.\n */\nexport function hasExports(metadata: ModuleMetadata) {\n  return metadata.hasExports;\n}\n\n/**\n * Check if a given source is an anonymous import, e.g. \"import 'foo';\"\n */\nexport function isSideEffectImport(source: SourceModuleMetadata) {\n  return (\n    source.imports.size === 0 &&\n    source.importsNamespace.size === 0 &&\n    source.reexports.size === 0 &&\n    source.reexportNamespace.size === 0 &&\n    !source.reexportAll\n  );\n}\n\nexport function validateImportInteropOption(\n  importInterop: any,\n): importInterop is ImportInterop {\n  if (\n    typeof importInterop !== \"function\" &&\n    importInterop !== \"none\" &&\n    importInterop !== \"babel\" &&\n    importInterop !== \"node\"\n  ) {\n    throw new Error(\n      `.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`,\n    );\n  }\n  return importInterop;\n}\n\nfunction resolveImportInterop(\n  importInterop: ImportInterop,\n  source: string,\n  filename: string | undefined,\n) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\n\n/**\n * Remove all imports and exports from the file, and return all metadata\n * needed to reconstruct the module's behavior.\n */\nexport default function normalizeModuleAndLoadMetadata(\n  programPath: NodePath<t.Program>,\n  exportName: string,\n  {\n    importInterop,\n    initializeReexports = false,\n    lazy = false,\n    esNamespaceOnly = false,\n    filename,\n  }: {\n    importInterop: ImportInterop;\n    initializeReexports: boolean | void;\n    lazy: Lazy;\n    esNamespaceOnly: boolean;\n    filename: string;\n  },\n): ModuleMetadata {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  const stringSpecifiers = new Set<string>();\n\n  nameAnonymousExports(programPath);\n\n  const { local, source, hasExports } = getModuleMetadata(\n    programPath,\n    { initializeReexports, lazy },\n    stringSpecifiers,\n  );\n\n  removeModuleDeclarations(programPath);\n\n  // Reuse the imported namespace name if there is one.\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      // This is kind of gross. If we stop using `loose: true` we should\n      // just make this destructuring assignment.\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    const resolvedInterop = resolveImportInterop(\n      importInterop,\n      metadata.source,\n      filename,\n    );\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      // Both the default and namespace interops pass through __esModule\n      // objects, but the namespace interop is used to enable Babel's\n      // destructuring-like interop behavior for normal CommonJS.\n      // Since some tooling has started to remove that behavior, we expose\n      // it as the `esNamespace` option.\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers,\n  };\n}\n\nfunction getExportSpecifierName(\n  path: NodePath,\n  stringSpecifiers: Set<string>,\n): string {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,\n    );\n  }\n}\n\nfunction assertExportSpecifier(\n  path: NodePath,\n): asserts path is NodePath<t.ExportSpecifier> {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\n      \"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\",\n    );\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\n/**\n * Get metadata about the imports and exports present in this module.\n */\nfunction getModuleMetadata(\n  programPath: NodePath<t.Program>,\n  {\n    lazy,\n    initializeReexports,\n  }: {\n    // todo(flow-ts) changed from boolean, to match expected usage inside the function\n    lazy: boolean | string[] | ((source: string) => boolean);\n    initializeReexports: boolean | void;\n  },\n  stringSpecifiers: Set<string>,\n) {\n  const localData = getLocalExportMetadata(\n    programPath,\n    initializeReexports,\n    stringSpecifiers,\n  );\n\n  const sourceData = new Map();\n  const getData = (sourceNode: t.StringLiteral) => {\n    const source = sourceNode.value;\n\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier(\n          basename(source, extname(source)),\n        ).name,\n\n        interop: \"none\",\n\n        loc: null,\n\n        // Data about the requested sources and names.\n        imports: new Map(),\n        importsNamespace: new Set(),\n\n        // Metadata about data that is passed directly from source to export.\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n\n        lazy: false,\n\n        source,\n      };\n      sourceData.set(source, data);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, \"default\");\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(\n            spec.get(\"imported\"),\n            stringSpecifiers,\n          );\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, importName);\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      data.reexportAll = {\n        loc: child.node.loc,\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(\n          spec.get(\"local\"),\n          stringSpecifiers,\n        );\n        const exportName = getExportSpecifierName(\n          spec.get(\"exported\"),\n          stringSpecifiers,\n        );\n\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw spec\n            .get(\"exported\")\n            .buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (\n      child.isExportNamedDeclaration() ||\n      child.isExportDefaultDeclaration()\n    ) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      // TODO(logan): Using the namespace interop here is unfortunate. Revisit.\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (\n      lazy !== false &&\n      !(isSideEffectImport(metadata) || metadata.reexportAll)\n    ) {\n      if (lazy === true) {\n        // 'true' means that local relative files are eagerly loaded and\n        // dependency modules are loaded lazily.\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData,\n  };\n}\n\ntype ModuleBindingKind = \"import\" | \"hoisted\" | \"block\" | \"var\";\n/**\n * Get metadata about local variables that are exported.\n */\nfunction getLocalExportMetadata(\n  programPath: NodePath<t.Program>,\n  initializeReexports: boolean | void,\n  stringSpecifiers: Set<string>,\n): Map<string, LocalExportMetadata> {\n  const bindingKindLookup = new Map();\n\n  programPath.get(\"body\").forEach((child: NodePath) => {\n    let kind: ModuleBindingKind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (\n          initializeReexports &&\n          child.node.source &&\n          child.get(\"source\").isStringLiteral()\n        ) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({ kind: \"var\" })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n\n  const localMetadata = new Map();\n  const getLocalMetadata = (idPath: NodePath<t.Identifier>) => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(\n          `Exporting local \"${localName}\", which is not declared.`,\n        );\n      }\n\n      metadata = {\n        names: [],\n        kind,\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (\n      child.isExportNamedDeclaration() &&\n      (initializeReexports || !child.node.source)\n    ) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError(\n              'Illegal export \"__esModule\".',\n            );\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): improve babel-types\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    }\n  });\n  return localMetadata;\n}\n\n/**\n * Ensure that all exported values have local binding names.\n */\nfunction nameAnonymousExports(programPath: NodePath<t.Program>) {\n  // Name anonymous exported locals.\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    splitExportDeclaration(child);\n  });\n}\n\nfunction removeModuleDeclarations(programPath: NodePath<t.Program>) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      // export default foo;\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(\n          declaration as NodePath<t.FunctionDeclaration | t.ClassDeclaration>,\n        );\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}\n"],"mappings":";;;;;;;;;;AAAA;;AAGA;;AACA;;AA8DO,SAASA,UAAT,CAAoBC,QAApB,EAA8C;EACnD,OAAOA,QAAQ,CAACD,UAAhB;AACD;;AAKM,SAASE,kBAAT,CAA4BC,MAA5B,EAA0D;EAC/D,OACEA,MAAM,CAACC,OAAP,CAAeC,IAAf,KAAwB,CAAxB,IACAF,MAAM,CAACG,gBAAP,CAAwBD,IAAxB,KAAiC,CADjC,IAEAF,MAAM,CAACI,SAAP,CAAiBF,IAAjB,KAA0B,CAF1B,IAGAF,MAAM,CAACK,iBAAP,CAAyBH,IAAzB,KAAkC,CAHlC,IAIA,CAACF,MAAM,CAACM,WALV;AAOD;;AAEM,SAASC,2BAAT,CACLC,aADK,EAE2B;EAChC,IACE,OAAOA,aAAP,KAAyB,UAAzB,IACAA,aAAa,KAAK,MADlB,IAEAA,aAAa,KAAK,OAFlB,IAGAA,aAAa,KAAK,MAJpB,EAKE;IACA,MAAM,IAAIC,KAAJ,CACH,gHAA+GD,aAAc,IAD1H,CAAN;EAGD;;EACD,OAAOA,aAAP;AACD;;AAED,SAASE,oBAAT,CACEF,aADF,EAEER,MAFF,EAGEW,QAHF,EAIE;EACA,IAAI,OAAOH,aAAP,KAAyB,UAA7B,EAAyC;IACvC,OAAOD,2BAA2B,CAACC,aAAa,CAACR,MAAD,EAASW,QAAT,CAAd,CAAlC;EACD;;EACD,OAAOH,aAAP;AACD;;AAMc,SAASI,8BAAT,CACbC,WADa,EAEbC,UAFa,EAGb;EACEN,aADF;EAEEO,mBAAmB,GAAG,KAFxB;EAGEC,IAAI,GAAG,KAHT;EAIEC,eAAe,GAAG,KAJpB;EAKEN;AALF,CAHa,EAgBG;EAChB,IAAI,CAACG,UAAL,EAAiB;IACfA,UAAU,GAAGD,WAAW,CAACK,KAAZ,CAAkBC,qBAAlB,CAAwC,SAAxC,EAAmDC,IAAhE;EACD;;EACD,MAAMC,gBAAgB,GAAG,IAAIC,GAAJ,EAAzB;EAEAC,oBAAoB,CAACV,WAAD,CAApB;EAEA,MAAM;IAAEW,KAAF;IAASxB,MAAT;IAAiBH;EAAjB,IAAgC4B,iBAAiB,CACrDZ,WADqD,EAErD;IAAEE,mBAAF;IAAuBC;EAAvB,CAFqD,EAGrDK,gBAHqD,CAAvD;EAMAK,wBAAwB,CAACb,WAAD,CAAxB;;EAGA,KAAK,MAAM,GAAGf,QAAH,CAAX,IAA2BE,MAA3B,EAAmC;IACjC,IAAIF,QAAQ,CAACK,gBAAT,CAA0BD,IAA1B,GAAiC,CAArC,EAAwC;MAGtCJ,QAAQ,CAACsB,IAAT,GAAgBtB,QAAQ,CAACK,gBAAT,CAA0BwB,MAA1B,GAAmCC,IAAnC,GAA0CC,KAA1D;IACD;;IAED,MAAMC,eAAe,GAAGpB,oBAAoB,CAC1CF,aAD0C,EAE1CV,QAAQ,CAACE,MAFiC,EAG1CW,QAH0C,CAA5C;;IAMA,IAAImB,eAAe,KAAK,MAAxB,EAAgC;MAC9BhC,QAAQ,CAACiC,OAAT,GAAmB,MAAnB;IACD,CAFD,MAEO,IAAID,eAAe,KAAK,MAApB,IAA8BhC,QAAQ,CAACiC,OAAT,KAAqB,WAAvD,EAAoE;MACzEjC,QAAQ,CAACiC,OAAT,GAAmB,gBAAnB;IACD,CAFM,MAEA,IAAID,eAAe,KAAK,MAApB,IAA8BhC,QAAQ,CAACiC,OAAT,KAAqB,SAAvD,EAAkE;MACvEjC,QAAQ,CAACiC,OAAT,GAAmB,cAAnB;IACD,CAFM,MAEA,IAAId,eAAe,IAAInB,QAAQ,CAACiC,OAAT,KAAqB,WAA5C,EAAyD;MAM9DjC,QAAQ,CAACiC,OAAT,GAAmB,SAAnB;IACD;EACF;;EAED,OAAO;IACLjB,UADK;IAELkB,kBAAkB,EAAE,IAFf;IAGLnC,UAHK;IAIL2B,KAJK;IAKLxB,MALK;IAMLqB;EANK,CAAP;AAQD;;AAED,SAASY,sBAAT,CACEC,IADF,EAEEb,gBAFF,EAGU;EACR,IAAIa,IAAI,CAACC,YAAL,EAAJ,EAAyB;IACvB,OAAOD,IAAI,CAACE,IAAL,CAAUhB,IAAjB;EACD,CAFD,MAEO,IAAIc,IAAI,CAACG,eAAL,EAAJ,EAA4B;IACjC,MAAMC,WAAW,GAAGJ,IAAI,CAACE,IAAL,CAAUP,KAA9B;;IAOA,IAAI,CAAC,IAAAU,2CAAA,EAAiBD,WAAjB,CAAL,EAAoC;MAClCjB,gBAAgB,CAACmB,GAAjB,CAAqBF,WAArB;IACD;;IACD,OAAOA,WAAP;EACD,CAZM,MAYA;IACL,MAAM,IAAI7B,KAAJ,CACH,2EAA0EyB,IAAI,CAACE,IAAL,CAAUK,IAAK,EADtF,CAAN;EAGD;AACF;;AAED,SAASC,qBAAT,CACER,IADF,EAE+C;EAC7C,IAAIA,IAAI,CAACS,iBAAL,EAAJ,EAA8B;IAC5B;EACD,CAFD,MAEO,IAAIT,IAAI,CAACU,0BAAL,EAAJ,EAAuC;IAC5C,MAAMV,IAAI,CAACW,mBAAL,CACJ,iGADI,CAAN;EAGD,CAJM,MAIA;IACL,MAAMX,IAAI,CAACW,mBAAL,CAAyB,kCAAzB,CAAN;EACD;AACF;;AAKD,SAASpB,iBAAT,CACEZ,WADF,EAEE;EACEG,IADF;EAEED;AAFF,CAFF,EAUEM,gBAVF,EAWE;EACA,MAAMyB,SAAS,GAAGC,sBAAsB,CACtClC,WADsC,EAEtCE,mBAFsC,EAGtCM,gBAHsC,CAAxC;EAMA,MAAM2B,UAAU,GAAG,IAAIC,GAAJ,EAAnB;;EACA,MAAMC,OAAO,GAAIC,UAAD,IAAiC;IAC/C,MAAMnD,MAAM,GAAGmD,UAAU,CAACtB,KAA1B;IAEA,IAAIuB,IAAI,GAAGJ,UAAU,CAACK,GAAX,CAAerD,MAAf,CAAX;;IACA,IAAI,CAACoD,IAAL,EAAW;MACTA,IAAI,GAAG;QACLhC,IAAI,EAAEP,WAAW,CAACK,KAAZ,CAAkBC,qBAAlB,CACJ,IAAAmC,cAAA,EAAStD,MAAT,EAAiB,IAAAuD,aAAA,EAAQvD,MAAR,CAAjB,CADI,EAEJoB,IAHG;QAKLW,OAAO,EAAE,MALJ;QAOLyB,GAAG,EAAE,IAPA;QAULvD,OAAO,EAAE,IAAIgD,GAAJ,EAVJ;QAWL9C,gBAAgB,EAAE,IAAImB,GAAJ,EAXb;QAcLlB,SAAS,EAAE,IAAI6C,GAAJ,EAdN;QAeL5C,iBAAiB,EAAE,IAAIiB,GAAJ,EAfd;QAgBLhB,WAAW,EAAE,IAhBR;QAkBLU,IAAI,EAAE,KAlBD;QAoBLhB;MApBK,CAAP;MAsBAgD,UAAU,CAACS,GAAX,CAAezD,MAAf,EAAuBoD,IAAvB;IACD;;IACD,OAAOA,IAAP;EACD,CA9BD;;EA+BA,IAAIvD,UAAU,GAAG,KAAjB;EACAgB,WAAW,CAACwC,GAAZ,CAAgB,MAAhB,EAAwBK,OAAxB,CAAgCC,KAAK,IAAI;IACvC,IAAIA,KAAK,CAACC,mBAAN,EAAJ,EAAiC;MAC/B,MAAMR,IAAI,GAAGF,OAAO,CAACS,KAAK,CAACvB,IAAN,CAAWpC,MAAZ,CAApB;MACA,IAAI,CAACoD,IAAI,CAACI,GAAV,EAAeJ,IAAI,CAACI,GAAL,GAAWG,KAAK,CAACvB,IAAN,CAAWoB,GAAtB;MAEfG,KAAK,CAACN,GAAN,CAAU,YAAV,EAAwBK,OAAxB,CAAgCG,IAAI,IAAI;QACtC,IAAIA,IAAI,CAACC,wBAAL,EAAJ,EAAqC;UACnC,MAAMC,SAAS,GAAGF,IAAI,CAACR,GAAL,CAAS,OAAT,EAAkBjB,IAAlB,CAAuBhB,IAAzC;UAEAgC,IAAI,CAACnD,OAAL,CAAawD,GAAb,CAAiBM,SAAjB,EAA4B,SAA5B;UAEA,MAAMC,QAAQ,GAAGlB,SAAS,CAACO,GAAV,CAAcU,SAAd,CAAjB;;UACA,IAAIC,QAAJ,EAAc;YACZlB,SAAS,CAACmB,MAAV,CAAiBF,SAAjB;YAEAC,QAAQ,CAACE,KAAT,CAAeR,OAAf,CAAuBtC,IAAI,IAAI;cAC7BgC,IAAI,CAAChD,SAAL,CAAeqD,GAAf,CAAmBrC,IAAnB,EAAyB,SAAzB;YACD,CAFD;UAGD;QACF,CAbD,MAaO,IAAIyC,IAAI,CAACM,0BAAL,EAAJ,EAAuC;UAC5C,MAAMJ,SAAS,GAAGF,IAAI,CAACR,GAAL,CAAS,OAAT,EAAkBjB,IAAlB,CAAuBhB,IAAzC;UAEAgC,IAAI,CAACjD,gBAAL,CAAsBqC,GAAtB,CAA0BuB,SAA1B;UACA,MAAMC,QAAQ,GAAGlB,SAAS,CAACO,GAAV,CAAcU,SAAd,CAAjB;;UACA,IAAIC,QAAJ,EAAc;YACZlB,SAAS,CAACmB,MAAV,CAAiBF,SAAjB;YAEAC,QAAQ,CAACE,KAAT,CAAeR,OAAf,CAAuBtC,IAAI,IAAI;cAC7BgC,IAAI,CAAC/C,iBAAL,CAAuBmC,GAAvB,CAA2BpB,IAA3B;YACD,CAFD;UAGD;QACF,CAZM,MAYA,IAAIyC,IAAI,CAACO,iBAAL,EAAJ,EAA8B;UACnC,MAAMC,UAAU,GAAGpC,sBAAsB,CACvC4B,IAAI,CAACR,GAAL,CAAS,UAAT,CADuC,EAEvChC,gBAFuC,CAAzC;UAIA,MAAM0C,SAAS,GAAGF,IAAI,CAACR,GAAL,CAAS,OAAT,EAAkBjB,IAAlB,CAAuBhB,IAAzC;UAEAgC,IAAI,CAACnD,OAAL,CAAawD,GAAb,CAAiBM,SAAjB,EAA4BM,UAA5B;UAEA,MAAML,QAAQ,GAAGlB,SAAS,CAACO,GAAV,CAAcU,SAAd,CAAjB;;UACA,IAAIC,QAAJ,EAAc;YACZlB,SAAS,CAACmB,MAAV,CAAiBF,SAAjB;YAEAC,QAAQ,CAACE,KAAT,CAAeR,OAAf,CAAuBtC,IAAI,IAAI;cAC7BgC,IAAI,CAAChD,SAAL,CAAeqD,GAAf,CAAmBrC,IAAnB,EAAyBiD,UAAzB;YACD,CAFD;UAGD;QACF;MACF,CA5CD;IA6CD,CAjDD,MAiDO,IAAIV,KAAK,CAACW,sBAAN,EAAJ,EAAoC;MACzCzE,UAAU,GAAG,IAAb;MACA,MAAMuD,IAAI,GAAGF,OAAO,CAACS,KAAK,CAACvB,IAAN,CAAWpC,MAAZ,CAApB;MACA,IAAI,CAACoD,IAAI,CAACI,GAAV,EAAeJ,IAAI,CAACI,GAAL,GAAWG,KAAK,CAACvB,IAAN,CAAWoB,GAAtB;MAEfJ,IAAI,CAAC9C,WAAL,GAAmB;QACjBkD,GAAG,EAAEG,KAAK,CAACvB,IAAN,CAAWoB;MADC,CAAnB;IAGD,CARM,MAQA,IAAIG,KAAK,CAACY,wBAAN,MAAoCZ,KAAK,CAACvB,IAAN,CAAWpC,MAAnD,EAA2D;MAChEH,UAAU,GAAG,IAAb;MACA,MAAMuD,IAAI,GAAGF,OAAO,CAACS,KAAK,CAACvB,IAAN,CAAWpC,MAAZ,CAApB;MACA,IAAI,CAACoD,IAAI,CAACI,GAAV,EAAeJ,IAAI,CAACI,GAAL,GAAWG,KAAK,CAACvB,IAAN,CAAWoB,GAAtB;MAEfG,KAAK,CAACN,GAAN,CAAU,YAAV,EAAwBK,OAAxB,CAAgCG,IAAI,IAAI;QACtCnB,qBAAqB,CAACmB,IAAD,CAArB;QACA,MAAMQ,UAAU,GAAGpC,sBAAsB,CACvC4B,IAAI,CAACR,GAAL,CAAS,OAAT,CADuC,EAEvChC,gBAFuC,CAAzC;QAIA,MAAMP,UAAU,GAAGmB,sBAAsB,CACvC4B,IAAI,CAACR,GAAL,CAAS,UAAT,CADuC,EAEvChC,gBAFuC,CAAzC;QAKA+B,IAAI,CAAChD,SAAL,CAAeqD,GAAf,CAAmB3C,UAAnB,EAA+BuD,UAA/B;;QAEA,IAAIvD,UAAU,KAAK,YAAnB,EAAiC;UAC/B,MAAM+C,IAAI,CACPR,GADG,CACC,UADD,EAEHR,mBAFG,CAEiB,8BAFjB,CAAN;QAGD;MACF,CAlBD;IAmBD,CAxBM,MAwBA,IACLc,KAAK,CAACY,wBAAN,MACAZ,KAAK,CAACa,0BAAN,EAFK,EAGL;MACA3E,UAAU,GAAG,IAAb;IACD;EACF,CAxFD;;EA0FA,KAAK,MAAMC,QAAX,IAAuBkD,UAAU,CAACrB,MAAX,EAAvB,EAA4C;IAC1C,IAAI8C,YAAY,GAAG,KAAnB;IACA,IAAIC,UAAU,GAAG,KAAjB;;IAEA,IAAI5E,QAAQ,CAACK,gBAAT,CAA0BD,IAA1B,GAAiC,CAArC,EAAwC;MACtCuE,YAAY,GAAG,IAAf;MACAC,UAAU,GAAG,IAAb;IACD;;IAED,IAAI5E,QAAQ,CAACQ,WAAb,EAA0B;MACxBoE,UAAU,GAAG,IAAb;IACD;;IAED,KAAK,MAAML,UAAX,IAAyBvE,QAAQ,CAACG,OAAT,CAAiB0B,MAAjB,EAAzB,EAAoD;MAClD,IAAI0C,UAAU,KAAK,SAAnB,EAA8BI,YAAY,GAAG,IAAf,CAA9B,KACKC,UAAU,GAAG,IAAb;IACN;;IACD,KAAK,MAAML,UAAX,IAAyBvE,QAAQ,CAACM,SAAT,CAAmBuB,MAAnB,EAAzB,EAAsD;MACpD,IAAI0C,UAAU,KAAK,SAAnB,EAA8BI,YAAY,GAAG,IAAf,CAA9B,KACKC,UAAU,GAAG,IAAb;IACN;;IAED,IAAID,YAAY,IAAIC,UAApB,EAAgC;MAE9B5E,QAAQ,CAACiC,OAAT,GAAmB,WAAnB;IACD,CAHD,MAGO,IAAI0C,YAAJ,EAAkB;MACvB3E,QAAQ,CAACiC,OAAT,GAAmB,SAAnB;IACD;EACF;;EAED,KAAK,MAAM,CAAC/B,MAAD,EAASF,QAAT,CAAX,IAAiCkD,UAAjC,EAA6C;IAC3C,IACEhC,IAAI,KAAK,KAAT,IACA,EAAEjB,kBAAkB,CAACD,QAAD,CAAlB,IAAgCA,QAAQ,CAACQ,WAA3C,CAFF,EAGE;MACA,IAAIU,IAAI,KAAK,IAAb,EAAmB;QAGjBlB,QAAQ,CAACkB,IAAT,GAAgB,CAAC,KAAK2D,IAAL,CAAU3E,MAAV,CAAjB;MACD,CAJD,MAIO,IAAI4E,KAAK,CAACC,OAAN,CAAc7D,IAAd,CAAJ,EAAyB;QAC9BlB,QAAQ,CAACkB,IAAT,GAAgBA,IAAI,CAAC8D,OAAL,CAAa9E,MAAb,MAAyB,CAAC,CAA1C;MACD,CAFM,MAEA,IAAI,OAAOgB,IAAP,KAAgB,UAApB,EAAgC;QACrClB,QAAQ,CAACkB,IAAT,GAAgBA,IAAI,CAAChB,MAAD,CAApB;MACD,CAFM,MAEA;QACL,MAAM,IAAIS,KAAJ,CAAW,oDAAX,CAAN;MACD;IACF;EACF;;EAED,OAAO;IACLZ,UADK;IAEL2B,KAAK,EAAEsB,SAFF;IAGL9C,MAAM,EAAEgD;EAHH,CAAP;AAKD;;AAMD,SAASD,sBAAT,CACElC,WADF,EAEEE,mBAFF,EAGEM,gBAHF,EAIoC;EAClC,MAAM0D,iBAAiB,GAAG,IAAI9B,GAAJ,EAA1B;EAEApC,WAAW,CAACwC,GAAZ,CAAgB,MAAhB,EAAwBK,OAAxB,CAAiCC,KAAD,IAAqB;IACnD,IAAIqB,IAAJ;;IACA,IAAIrB,KAAK,CAACC,mBAAN,EAAJ,EAAiC;MAC/BoB,IAAI,GAAG,QAAP;IACD,CAFD,MAEO;MACL,IAAIrB,KAAK,CAACa,0BAAN,EAAJ,EAAwC;QACtCb,KAAK,GAAGA,KAAK,CAACN,GAAN,CAAU,aAAV,CAAR;MACD;;MACD,IAAIM,KAAK,CAACY,wBAAN,EAAJ,EAAsC;QACpC,IAAIZ,KAAK,CAACvB,IAAN,CAAW6C,WAAf,EAA4B;UAC1BtB,KAAK,GAAGA,KAAK,CAACN,GAAN,CAAU,aAAV,CAAR;QACD,CAFD,MAEO,IACLtC,mBAAmB,IACnB4C,KAAK,CAACvB,IAAN,CAAWpC,MADX,IAEA2D,KAAK,CAACN,GAAN,CAAU,QAAV,EAAoBhB,eAApB,EAHK,EAIL;UACAsB,KAAK,CAACN,GAAN,CAAU,YAAV,EAAwBK,OAAxB,CAAgCG,IAAI,IAAI;YACtCnB,qBAAqB,CAACmB,IAAD,CAArB;YACAkB,iBAAiB,CAACtB,GAAlB,CAAsBI,IAAI,CAACR,GAAL,CAAS,OAAT,EAAkBjB,IAAlB,CAAuBhB,IAA7C,EAAmD,OAAnD;UACD,CAHD;UAIA;QACD;MACF;;MAED,IAAIuC,KAAK,CAACuB,qBAAN,EAAJ,EAAmC;QACjCF,IAAI,GAAG,SAAP;MACD,CAFD,MAEO,IAAIrB,KAAK,CAACwB,kBAAN,EAAJ,EAAgC;QACrCH,IAAI,GAAG,OAAP;MACD,CAFM,MAEA,IAAIrB,KAAK,CAACyB,qBAAN,CAA4B;QAAEJ,IAAI,EAAE;MAAR,CAA5B,CAAJ,EAAkD;QACvDA,IAAI,GAAG,KAAP;MACD,CAFM,MAEA,IAAIrB,KAAK,CAACyB,qBAAN,EAAJ,EAAmC;QACxCJ,IAAI,GAAG,OAAP;MACD,CAFM,MAEA;QACL;MACD;IACF;;IAEDK,MAAM,CAACC,IAAP,CAAY3B,KAAK,CAAC4B,0BAAN,EAAZ,EAAgD7B,OAAhD,CAAwDtC,IAAI,IAAI;MAC9D2D,iBAAiB,CAACtB,GAAlB,CAAsBrC,IAAtB,EAA4B4D,IAA5B;IACD,CAFD;EAGD,CAxCD;EA0CA,MAAMQ,aAAa,GAAG,IAAIvC,GAAJ,EAAtB;;EACA,MAAMwC,gBAAgB,GAAIC,MAAD,IAAoC;IAC3D,MAAM3B,SAAS,GAAG2B,MAAM,CAACtD,IAAP,CAAYhB,IAA9B;IACA,IAAItB,QAAQ,GAAG0F,aAAa,CAACnC,GAAd,CAAkBU,SAAlB,CAAf;;IAEA,IAAI,CAACjE,QAAL,EAAe;MACb,MAAMkF,IAAI,GAAGD,iBAAiB,CAAC1B,GAAlB,CAAsBU,SAAtB,CAAb;;MAEA,IAAIiB,IAAI,KAAKW,SAAb,EAAwB;QACtB,MAAMD,MAAM,CAAC7C,mBAAP,CACH,oBAAmBkB,SAAU,2BAD1B,CAAN;MAGD;;MAEDjE,QAAQ,GAAG;QACToE,KAAK,EAAE,EADE;QAETc;MAFS,CAAX;MAIAQ,aAAa,CAAC/B,GAAd,CAAkBM,SAAlB,EAA6BjE,QAA7B;IACD;;IACD,OAAOA,QAAP;EACD,CApBD;;EAsBAe,WAAW,CAACwC,GAAZ,CAAgB,MAAhB,EAAwBK,OAAxB,CAAgCC,KAAK,IAAI;IACvC,IACEA,KAAK,CAACY,wBAAN,OACCxD,mBAAmB,IAAI,CAAC4C,KAAK,CAACvB,IAAN,CAAWpC,MADpC,CADF,EAGE;MACA,IAAI2D,KAAK,CAACvB,IAAN,CAAW6C,WAAf,EAA4B;QAC1B,MAAMA,WAAW,GAAGtB,KAAK,CAACN,GAAN,CAAU,aAAV,CAApB;QACA,MAAMuC,GAAG,GAAGX,WAAW,CAACY,8BAAZ,EAAZ;QACAR,MAAM,CAACC,IAAP,CAAYM,GAAZ,EAAiBlC,OAAjB,CAAyBtC,IAAI,IAAI;UAC/B,IAAIA,IAAI,KAAK,YAAb,EAA2B;YACzB,MAAM6D,WAAW,CAACpC,mBAAZ,CACJ,8BADI,CAAN;UAGD;;UACD4C,gBAAgB,CAACG,GAAG,CAACxE,IAAD,CAAJ,CAAhB,CAA4B8C,KAA5B,CAAkC4B,IAAlC,CAAuC1E,IAAvC;QACD,CAPD;MAQD,CAXD,MAWO;QACLuC,KAAK,CAACN,GAAN,CAAU,YAAV,EAAwBK,OAAxB,CAAgCG,IAAI,IAAI;UACtC,MAAMrC,KAAK,GAAGqC,IAAI,CAACR,GAAL,CAAS,OAAT,CAAd;UACA,MAAM0C,QAAQ,GAAGlC,IAAI,CAACR,GAAL,CAAS,UAAT,CAAjB;UACA,MAAMmC,aAAa,GAAGC,gBAAgB,CAACjE,KAAD,CAAtC;UACA,MAAMV,UAAU,GAAGmB,sBAAsB,CAAC8D,QAAD,EAAW1E,gBAAX,CAAzC;;UAEA,IAAIP,UAAU,KAAK,YAAnB,EAAiC;YAC/B,MAAMiF,QAAQ,CAAClD,mBAAT,CAA6B,8BAA7B,CAAN;UACD;;UACD2C,aAAa,CAACtB,KAAd,CAAoB4B,IAApB,CAAyBhF,UAAzB;QACD,CAVD;MAWD;IACF,CA5BD,MA4BO,IAAI6C,KAAK,CAACa,0BAAN,EAAJ,EAAwC;MAC7C,MAAMS,WAAW,GAAGtB,KAAK,CAACN,GAAN,CAAU,aAAV,CAApB;;MACA,IACE4B,WAAW,CAACC,qBAAZ,MACAD,WAAW,CAACE,kBAAZ,EAFF,EAGE;QAEAM,gBAAgB,CAACR,WAAW,CAAC5B,GAAZ,CAAgB,IAAhB,CAAD,CAAhB,CAAwCa,KAAxC,CAA8C4B,IAA9C,CAAmD,SAAnD;MACD,CAND,MAMO;QAEL,MAAMb,WAAW,CAACpC,mBAAZ,CACJ,uCADI,CAAN;MAGD;IACF;EACF,CA5CD;EA6CA,OAAO2C,aAAP;AACD;;AAKD,SAASjE,oBAAT,CAA8BV,WAA9B,EAAgE;EAE9DA,WAAW,CAACwC,GAAZ,CAAgB,MAAhB,EAAwBK,OAAxB,CAAgCC,KAAK,IAAI;IACvC,IAAI,CAACA,KAAK,CAACa,0BAAN,EAAL,EAAyC;IACzC,IAAAwB,qCAAA,EAAuBrC,KAAvB;EACD,CAHD;AAID;;AAED,SAASjC,wBAAT,CAAkCb,WAAlC,EAAoE;EAClEA,WAAW,CAACwC,GAAZ,CAAgB,MAAhB,EAAwBK,OAAxB,CAAgCC,KAAK,IAAI;IACvC,IAAIA,KAAK,CAACC,mBAAN,EAAJ,EAAiC;MAC/BD,KAAK,CAACsC,MAAN;IACD,CAFD,MAEO,IAAItC,KAAK,CAACY,wBAAN,EAAJ,EAAsC;MAC3C,IAAIZ,KAAK,CAACvB,IAAN,CAAW6C,WAAf,EAA4B;QAE1BtB,KAAK,CAACvB,IAAN,CAAW6C,WAAX,CAAuBiB,WAAvB,GAAqCvC,KAAK,CAACvB,IAAN,CAAW8D,WAAhD;QACAvC,KAAK,CAACwC,WAAN,CAAkBxC,KAAK,CAACvB,IAAN,CAAW6C,WAA7B;MACD,CAJD,MAIO;QACLtB,KAAK,CAACsC,MAAN;MACD;IACF,CARM,MAQA,IAAItC,KAAK,CAACa,0BAAN,EAAJ,EAAwC;MAE7C,MAAMS,WAAW,GAAGtB,KAAK,CAACN,GAAN,CAAU,aAAV,CAApB;;MACA,IACE4B,WAAW,CAACC,qBAAZ,MACAD,WAAW,CAACE,kBAAZ,EAFF,EAGE;QAEAF,WAAW,CAACiB,WAAZ,GAA0BvC,KAAK,CAACvB,IAAN,CAAW8D,WAArC;QACAvC,KAAK,CAACwC,WAAN,CACElB,WADF;MAGD,CATD,MASO;QAEL,MAAMA,WAAW,CAACpC,mBAAZ,CACJ,uCADI,CAAN;MAGD;IACF,CAlBM,MAkBA,IAAIc,KAAK,CAACW,sBAAN,EAAJ,EAAoC;MACzCX,KAAK,CAACsC,MAAN;IACD;EACF,CAhCD;AAiCD"}