{"version":3,"file":"index.production.js","sources":["../../../table-core/build/esm/index.js","../../src/index.tsx"],"sourcesContent":["/**\n * table-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction noop() {//\n}\nfunction makeStateUpdater(key, instance) {\n  return updater => {\n    instance.setState(old => {\n      return { ...old,\n        [key]: functionalUpdate(updater, old[key])\n      };\n    });\n  };\n}\nfunction isFunction(d) {\n  return d instanceof Function;\n}\nfunction flattenBy(arr, getChildren) {\n  const flat = [];\n\n  const recurse = subArr => {\n    subArr.forEach(item => {\n      flat.push(item);\n      const children = getChildren(item);\n\n      if (children != null && children.length) {\n        recurse(children);\n      }\n    });\n  };\n\n  recurse(arr);\n  return flat;\n}\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return () => {\n    let depTime;\n    if (opts.key && opts.debug) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n\n    if (!depsChanged) {\n      return result;\n    }\n\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n\n    if (opts.key && opts.debug) {\n      if (opts != null && opts.debug()) {\n        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n        const resultFpsPercentage = resultEndTime / 16;\n\n        const pad = (str, num) => {\n          str = String(str);\n\n          while (str.length < num) {\n            str = ' ' + str;\n          }\n\n          return str;\n        };\n\n        console.info(\"%c\\u23F1 \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction createColumn(instance, columnDef, depth, parent) {\n  var _ref, _columnDef$id;\n\n  const defaultColumn = instance._getDefaultColumnDef();\n\n  columnDef = { ...defaultColumn,\n    ...columnDef\n  };\n  let id = (_ref = (_columnDef$id = columnDef.id) != null ? _columnDef$id : columnDef.accessorKey) != null ? _ref : typeof columnDef.header === 'string' ? columnDef.header : undefined;\n  let accessorFn;\n\n  if (columnDef.accessorFn) {\n    accessorFn = columnDef.accessorFn;\n  } else if (columnDef.accessorKey) {\n    accessorFn = originalRow => originalRow[columnDef.accessorKey];\n  }\n\n  if (!id) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(columnDef.accessorFn ? \"Columns require an id when using an accessorFn\" : \"Columns require an id when using a non-string header\");\n    }\n\n    throw new Error();\n  }\n\n  let column = { ...columnDef,\n    id: \"\" + id,\n    accessorFn,\n    parent: parent,\n    depth,\n    columnDef,\n    columnDefType: columnDef.columnDefType,\n    columns: [],\n    getFlatColumns: memo(() => [true], () => {\n      var _column$columns;\n\n      return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];\n    }, {\n      key: process.env.NODE_ENV === 'production' && 'column.getFlatColumns',\n      debug: () => {\n        var _instance$options$deb;\n\n        return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugColumns;\n      }\n    }),\n    getLeafColumns: memo(() => [instance._getOrderColumnsFn()], orderColumns => {\n      var _column$columns2;\n\n      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n        let leafColumns = column.columns.flatMap(column => column.getLeafColumns());\n        return orderColumns(leafColumns);\n      }\n\n      return [column];\n    }, {\n      key: process.env.NODE_ENV === 'production' && 'column.getLeafColumns',\n      debug: () => {\n        var _instance$options$deb2;\n\n        return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugColumns;\n      }\n    })\n  };\n  column = instance._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.createColumn == null ? void 0 : feature.createColumn(column, instance));\n  }, column); // Yes, we have to convert instance to uknown, because we know more than the compiler here.\n\n  return column;\n}\n\n//\nfunction createHeader(instance, column, options) {\n  var _options$id;\n\n  const id = (_options$id = options.id) != null ? _options$id : column.id;\n  let header = {\n    id,\n    column,\n    index: options.index,\n    isPlaceholder: !!options.isPlaceholder,\n    placeholderId: options.placeholderId,\n    depth: options.depth,\n    subHeaders: [],\n    colSpan: 0,\n    rowSpan: 0,\n    headerGroup: null,\n    getLeafHeaders: () => {\n      const leafHeaders = [];\n\n      const recurseHeader = h => {\n        if (h.subHeaders && h.subHeaders.length) {\n          h.subHeaders.map(recurseHeader);\n        }\n\n        leafHeaders.push(h);\n      };\n\n      recurseHeader(header);\n      return leafHeaders;\n    },\n    renderHeader: () => column.columnDef.header ? instance._render(column.columnDef.header, {\n      instance,\n      header: header,\n      column\n    }) : null,\n    renderFooter: () => column.columnDef.footer ? instance._render(column.columnDef.footer, {\n      instance,\n      header: header,\n      column\n    }) : null\n  };\n\n  instance._features.forEach(feature => {\n    Object.assign(header, feature.createHeader == null ? void 0 : feature.createHeader(header, instance));\n  });\n\n  return header;\n}\n\nconst Headers = {\n  createInstance: instance => {\n    return {\n      // Header Groups\n      getHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n        var _left$map$filter, _right$map$filter;\n\n        const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n        const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n        const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n        const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], instance);\n        return headerGroups;\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getHeaderGroups',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugHeaders;\n        }\n      }),\n      getCenterHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n        leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n        return buildHeaderGroups(allColumns, leafColumns, instance, 'center');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterHeaderGroups',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.left], (allColumns, leafColumns, left) => {\n        var _left$map$filter2;\n\n        const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n        return buildHeaderGroups(allColumns, orderedLeafColumns, instance, 'left');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftHeaderGroups',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugHeaders;\n        }\n      }),\n      getRightHeaderGroups: memo(() => [instance.getAllColumns(), instance.getVisibleLeafColumns(), instance.getState().columnPinning.right], (allColumns, leafColumns, right) => {\n        var _right$map$filter2;\n\n        const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n        return buildHeaderGroups(allColumns, orderedLeafColumns, instance, 'right');\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightHeaderGroups',\n        debug: () => {\n          var _instance$options$deb4;\n\n          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugHeaders;\n        }\n      }),\n      // Footer Groups\n      getFooterGroups: memo(() => [instance.getHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getFooterGroups',\n        debug: () => {\n          var _instance$options$deb5;\n\n          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftFooterGroups: memo(() => [instance.getLeftHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftFooterGroups',\n        debug: () => {\n          var _instance$options$deb6;\n\n          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugHeaders;\n        }\n      }),\n      getCenterFooterGroups: memo(() => [instance.getCenterHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterFooterGroups',\n        debug: () => {\n          var _instance$options$deb7;\n\n          return (_instance$options$deb7 = instance.options.debugAll) != null ? _instance$options$deb7 : instance.options.debugHeaders;\n        }\n      }),\n      getRightFooterGroups: memo(() => [instance.getRightHeaderGroups()], headerGroups => {\n        return [...headerGroups].reverse();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightFooterGroups',\n        debug: () => {\n          var _instance$options$deb8;\n\n          return (_instance$options$deb8 = instance.options.debugAll) != null ? _instance$options$deb8 : instance.options.debugHeaders;\n        }\n      }),\n      // Flat Headers\n      getFlatHeaders: memo(() => [instance.getHeaderGroups()], headerGroups => {\n        return headerGroups.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getFlatHeaders',\n        debug: () => {\n          var _instance$options$deb9;\n\n          return (_instance$options$deb9 = instance.options.debugAll) != null ? _instance$options$deb9 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftFlatHeaders: memo(() => [instance.getLeftHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftFlatHeaders',\n        debug: () => {\n          var _instance$options$deb10;\n\n          return (_instance$options$deb10 = instance.options.debugAll) != null ? _instance$options$deb10 : instance.options.debugHeaders;\n        }\n      }),\n      getCenterFlatHeaders: memo(() => [instance.getCenterHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterFlatHeaders',\n        debug: () => {\n          var _instance$options$deb11;\n\n          return (_instance$options$deb11 = instance.options.debugAll) != null ? _instance$options$deb11 : instance.options.debugHeaders;\n        }\n      }),\n      getRightFlatHeaders: memo(() => [instance.getRightHeaderGroups()], left => {\n        return left.map(headerGroup => {\n          return headerGroup.headers;\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightFlatHeaders',\n        debug: () => {\n          var _instance$options$deb12;\n\n          return (_instance$options$deb12 = instance.options.debugAll) != null ? _instance$options$deb12 : instance.options.debugHeaders;\n        }\n      }),\n      // Leaf Headers\n      getCenterLeafHeaders: memo(() => [instance.getCenterFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders;\n\n          return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterLeafHeaders',\n        debug: () => {\n          var _instance$options$deb13;\n\n          return (_instance$options$deb13 = instance.options.debugAll) != null ? _instance$options$deb13 : instance.options.debugHeaders;\n        }\n      }),\n      getLeftLeafHeaders: memo(() => [instance.getLeftFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders2;\n\n          return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftLeafHeaders',\n        debug: () => {\n          var _instance$options$deb14;\n\n          return (_instance$options$deb14 = instance.options.debugAll) != null ? _instance$options$deb14 : instance.options.debugHeaders;\n        }\n      }),\n      getRightLeafHeaders: memo(() => [instance.getRightFlatHeaders()], flatHeaders => {\n        return flatHeaders.filter(header => {\n          var _header$subHeaders3;\n\n          return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n        });\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightLeafHeaders',\n        debug: () => {\n          var _instance$options$deb15;\n\n          return (_instance$options$deb15 = instance.options.debugAll) != null ? _instance$options$deb15 : instance.options.debugHeaders;\n        }\n      }),\n      getLeafHeaders: memo(() => [instance.getLeftHeaderGroups(), instance.getCenterHeaderGroups(), instance.getRightHeaderGroups()], (left, center, right) => {\n        var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n\n        return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {\n          return header.getLeafHeaders();\n        }).flat();\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeafHeaders',\n        debug: () => {\n          var _instance$options$deb16;\n\n          return (_instance$options$deb16 = instance.options.debugAll) != null ? _instance$options$deb16 : instance.options.debugHeaders;\n        }\n      })\n    };\n  }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, instance, headerFamily) {\n  var _headerGroups$0$heade, _headerGroups$;\n\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n  let maxDepth = 0;\n\n  const findMaxDepth = function (columns, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n\n    maxDepth = Math.max(maxDepth, depth);\n    columns.filter(column => column.getIsVisible()).forEach(column => {\n      var _column$columns;\n\n      if ((_column$columns = column.columns) != null && _column$columns.length) {\n        findMaxDepth(column.columns, depth + 1);\n      }\n    }, 0);\n  };\n\n  findMaxDepth(allColumns);\n  let headerGroups = [];\n\n  const createHeaderGroup = (headersToGroup, depth) => {\n    // The header group we are creating\n    const headerGroup = {\n      depth,\n      id: [headerFamily, \"\" + depth].filter(Boolean).join('_'),\n      headers: []\n    }; // The parent columns we're going to scan next\n\n    const pendingParentHeaders = []; // Scan each column for parents\n\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n      let column;\n      let isPlaceholder = false;\n\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent;\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column;\n        isPlaceholder = true;\n      }\n\n      if ((latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n        // This column is repeated. Add it as a sub header to the next batch\n        latestPendingParentHeader.subHeaders.push(headerToGroup);\n      } else {\n        // This is a new header. Let's create it\n        const header = createHeader(instance, column, {\n          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),\n          isPlaceholder,\n          placeholderId: isPlaceholder ? \"\" + pendingParentHeaders.filter(d => d.column === column).length : undefined,\n          depth,\n          index: pendingParentHeaders.length\n        }); // Add the headerToGroup as a subHeader of the new header\n\n        header.subHeaders.push(headerToGroup); // Add the new header to the pendingParentHeaders to get grouped\n        // in the next batch\n\n        pendingParentHeaders.push(header);\n      }\n\n      headerGroup.headers.push(headerToGroup);\n      headerToGroup.headerGroup = headerGroup;\n    });\n    headerGroups.push(headerGroup);\n\n    if (depth > 0) {\n      createHeaderGroup(pendingParentHeaders, depth - 1);\n    }\n  };\n\n  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(instance, column, {\n    depth: maxDepth,\n    index\n  }));\n  createHeaderGroup(bottomHeaders, maxDepth - 1);\n  headerGroups.reverse(); // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = headers => {\n    const filteredHeaders = headers.filter(header => header.column.getIsVisible());\n    return filteredHeaders.map(header => {\n      let colSpan = 0;\n      let rowSpan = 0;\n      let childRowSpans = [0];\n\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = [];\n        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {\n          let {\n            colSpan: childColSpan,\n            rowSpan: childRowSpan\n          } = _ref;\n          colSpan += childColSpan;\n          childRowSpans.push(childRowSpan);\n        });\n      } else {\n        colSpan = 1;\n      }\n\n      const minChildRowSpan = Math.min(...childRowSpans);\n      rowSpan = rowSpan + minChildRowSpan;\n      header.colSpan = colSpan;\n      header.rowSpan = rowSpan;\n      return {\n        colSpan,\n        rowSpan\n      };\n    });\n  };\n\n  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n  return headerGroups;\n}\n\n//\nconst defaultColumnSizing = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER\n};\n\nconst getDefaultColumnSizingInfoState = () => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: false,\n  columnSizingStart: []\n});\n\nconst ColumnSizing = {\n  getDefaultColumnDef: () => {\n    return defaultColumnSizing;\n  },\n  getInitialState: state => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      columnResizeMode: 'onEnd',\n      onColumnSizingChange: makeStateUpdater('columnSizing', instance),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      getSize: () => {\n        var _column$columnDef$min, _ref, _column$columnDef$max;\n\n        const columnSize = instance.getState().columnSizing[column.id];\n        return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n      },\n      getStart: position => {\n        const columns = !position ? instance.getVisibleLeafColumns() : position === 'left' ? instance.getLeftVisibleLeafColumns() : instance.getRightVisibleLeafColumns();\n        const index = columns.findIndex(d => d.id === column.id);\n\n        if (index > 0) {\n          const prevSiblingColumn = columns[index - 1];\n          return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();\n        }\n\n        return 0;\n      },\n      resetSize: () => {\n        instance.setColumnSizing(_ref2 => {\n          let {\n            [column.id]: _,\n            ...rest\n          } = _ref2;\n          return rest;\n        });\n      },\n      getCanResize: () => {\n        var _column$columnDef$ena, _instance$options$ena;\n\n        return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_instance$options$ena = instance.options.enableColumnResizing) != null ? _instance$options$ena : true);\n      },\n      getIsResizing: () => {\n        return instance.getState().columnSizingInfo.isResizingColumn === column.id;\n      }\n    };\n  },\n  createHeader: (header, instance) => {\n    return {\n      getSize: () => {\n        let sum = 0;\n\n        const recurse = header => {\n          if (header.subHeaders.length) {\n            header.subHeaders.forEach(recurse);\n          } else {\n            var _header$column$getSiz;\n\n            sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n          }\n        };\n\n        recurse(header);\n        return sum;\n      },\n      getStart: () => {\n        if (header.index > 0) {\n          const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n          return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n        }\n\n        return 0;\n      },\n      getResizeHandler: () => {\n        const column = instance.getColumn(header.column.id);\n        const canResize = column.getCanResize();\n        return e => {\n          if (!canResize) {\n            return;\n          }\n          e.persist == null ? void 0 : e.persist();\n\n          if (isTouchStartEvent(e)) {\n            // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n            if (e.touches && e.touches.length > 1) {\n              return;\n            }\n          }\n\n          const startSize = header.getSize();\n          const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];\n          const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n\n          const updateOffset = (eventType, clientXPos) => {\n            if (typeof clientXPos !== 'number') {\n              return;\n            }\n\n            let newColumnSizing = {};\n            instance.setColumnSizingInfo(old => {\n              var _old$startOffset, _old$startSize;\n\n              const deltaOffset = clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0);\n              const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n              old.columnSizingStart.forEach(_ref3 => {\n                let [columnId, headerSize] = _ref3;\n                newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n              });\n              return { ...old,\n                deltaOffset,\n                deltaPercentage\n              };\n            });\n\n            if (instance.options.columnResizeMode === 'onChange' || eventType === 'end') {\n              instance.setColumnSizing(old => ({ ...old,\n                ...newColumnSizing\n              }));\n            }\n          };\n\n          const onMove = clientXPos => updateOffset('move', clientXPos);\n\n          const onEnd = clientXPos => {\n            updateOffset('end', clientXPos);\n            instance.setColumnSizingInfo(old => ({ ...old,\n              isResizingColumn: false,\n              startOffset: null,\n              startSize: null,\n              deltaOffset: null,\n              deltaPercentage: null,\n              columnSizingStart: []\n            }));\n          };\n\n          const mouseEvents = {\n            moveHandler: e => onMove(e.clientX),\n            upHandler: e => {\n              document.removeEventListener('mousemove', mouseEvents.moveHandler);\n              document.removeEventListener('mouseup', mouseEvents.upHandler);\n              onEnd(e.clientX);\n            }\n          };\n          const passiveIfSupported = passiveEventSupported() ? {\n            passive: false\n          } : false;\n\n          if (isTouchStartEvent(e)) ; else {\n            document.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);\n            document.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);\n          }\n\n          instance.setColumnSizingInfo(old => ({ ...old,\n            startOffset: clientX,\n            startSize,\n            deltaOffset: 0,\n            deltaPercentage: 0,\n            columnSizingStart,\n            isResizingColumn: column.id\n          }));\n        };\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnSizing: updater => instance.options.onColumnSizingChange == null ? void 0 : instance.options.onColumnSizingChange(updater),\n      setColumnSizingInfo: updater => instance.options.onColumnSizingInfoChange == null ? void 0 : instance.options.onColumnSizingInfoChange(updater),\n      resetColumnSizing: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnSizing(defaultState ? {} : (_instance$initialStat = instance.initialState.columnSizing) != null ? _instance$initialStat : {});\n      },\n      resetHeaderSizeInfo: defaultState => {\n        var _instance$initialStat2;\n\n        instance.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_instance$initialStat2 = instance.initialState.columnSizingInfo) != null ? _instance$initialStat2 : getDefaultColumnSizingInfoState());\n      },\n      getTotalSize: () => {\n        var _instance$getHeaderGr, _instance$getHeaderGr2;\n\n        return (_instance$getHeaderGr = (_instance$getHeaderGr2 = instance.getHeaderGroups()[0]) == null ? void 0 : _instance$getHeaderGr2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getHeaderGr : 0;\n      },\n      getLeftTotalSize: () => {\n        var _instance$getLeftHead, _instance$getLeftHead2;\n\n        return (_instance$getLeftHead = (_instance$getLeftHead2 = instance.getLeftHeaderGroups()[0]) == null ? void 0 : _instance$getLeftHead2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getLeftHead : 0;\n      },\n      getCenterTotalSize: () => {\n        var _instance$getCenterHe, _instance$getCenterHe2;\n\n        return (_instance$getCenterHe = (_instance$getCenterHe2 = instance.getCenterHeaderGroups()[0]) == null ? void 0 : _instance$getCenterHe2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getCenterHe : 0;\n      },\n      getRightTotalSize: () => {\n        var _instance$getRightHea, _instance$getRightHea2;\n\n        return (_instance$getRightHea = (_instance$getRightHea2 = instance.getRightHeaderGroups()[0]) == null ? void 0 : _instance$getRightHea2.headers.reduce((sum, header) => {\n          return sum + header.getSize();\n        }, 0)) != null ? _instance$getRightHea : 0;\n      }\n    };\n  }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported;\n  let supported = false;\n\n  try {\n    const options = {\n      get passive() {\n        supported = true;\n        return false;\n      }\n\n    };\n\n    const noop = () => {};\n\n    window.addEventListener('test', noop, options);\n    window.removeEventListener('test', noop);\n  } catch (err) {\n    supported = false;\n  }\n\n  passiveSupported = supported;\n  return passiveSupported;\n}\n\nfunction isTouchStartEvent(e) {\n  return e.type === 'touchstart';\n}\n\n//\nconst Expanding = {\n  getInitialState: state => {\n    return {\n      expanded: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', instance),\n      autoResetExpanded: true,\n      paginateExpandedRows: true\n    };\n  },\n  createInstance: instance => {\n    let registered = false;\n    let queued = false;\n    return {\n      _autoResetExpanded: () => {\n        if (!registered) {\n          instance._queue(() => {\n            registered = true;\n          });\n\n          return;\n        }\n\n        if (instance.options.autoResetAll === false) {\n          return;\n        }\n\n        if (instance.options.autoResetAll === true || instance.options.autoResetExpanded) {\n          if (queued) return;\n          queued = true;\n\n          instance._queue(() => {\n            instance.resetExpanded();\n            queued = false;\n          });\n        }\n      },\n      setExpanded: updater => instance.options.onExpandedChange == null ? void 0 : instance.options.onExpandedChange(updater),\n      toggleAllRowsExpanded: expanded => {\n        if (expanded != null ? expanded : !instance.getIsAllRowsExpanded()) {\n          instance.setExpanded(true);\n        } else {\n          instance.setExpanded({});\n        }\n      },\n      resetExpanded: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setExpanded(defaultState ? {} : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.expanded) != null ? _instance$initialStat : {});\n      },\n      getCanSomeRowsExpand: () => {\n        return instance.getRowModel().flatRows.some(row => row.getCanExpand());\n      },\n      getToggleAllRowsExpandedHandler: () => {\n        return e => {\n          e.persist == null ? void 0 : e.persist();\n          instance.toggleAllRowsExpanded();\n        };\n      },\n      getIsSomeRowsExpanded: () => {\n        const expanded = instance.getState().expanded;\n        return expanded === true || Object.values(expanded).some(Boolean);\n      },\n      getIsAllRowsExpanded: () => {\n        const expanded = instance.getState().expanded; // If expanded is true, save some cycles and return true\n\n        if (expanded === true) {\n          return true;\n        } // If any row is not expanded, return false\n\n\n        if (instance.getRowModel().flatRows.some(row => row.getIsExpanded())) {\n          return false;\n        } // They must all be expanded :shrug:\n\n\n        return true;\n      },\n      getExpandedDepth: () => {\n        let maxDepth = 0;\n        const rowIds = instance.getState().expanded === true ? Object.keys(instance.getRowModel().rowsById) : Object.keys(instance.getState().expanded);\n        rowIds.forEach(id => {\n          const splitId = id.split('.');\n          maxDepth = Math.max(maxDepth, splitId.length);\n        });\n        return maxDepth;\n      },\n      getPreExpandedRowModel: () => instance.getGroupedRowModel(),\n      getExpandedRowModel: () => {\n        if (!instance._getExpandedRowModel && instance.options.getExpandedRowModel) {\n          instance._getExpandedRowModel = instance.options.getExpandedRowModel(instance);\n        }\n\n        if (instance.options.manualExpanding || !instance._getExpandedRowModel) {\n          return instance.getPreExpandedRowModel();\n        }\n\n        return instance._getExpandedRowModel();\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      toggleExpanded: expanded => {\n        instance.setExpanded(old => {\n          var _expanded;\n\n          const exists = old === true ? true : !!(old != null && old[row.id]);\n          let oldExpanded = {};\n\n          if (old === true) {\n            Object.keys(instance.getRowModel().rowsById).forEach(rowId => {\n              oldExpanded[rowId] = true;\n            });\n          } else {\n            oldExpanded = old;\n          }\n\n          expanded = (_expanded = expanded) != null ? _expanded : !exists;\n\n          if (!exists && expanded) {\n            return { ...oldExpanded,\n              [row.id]: true\n            };\n          }\n\n          if (exists && !expanded) {\n            const {\n              [row.id]: _,\n              ...rest\n            } = oldExpanded;\n            return rest;\n          }\n\n          return old;\n        });\n      },\n      getIsExpanded: () => {\n        var _instance$options$get;\n\n        const expanded = instance.getState().expanded;\n        return !!((_instance$options$get = instance.options.getIsRowExpanded == null ? void 0 : instance.options.getIsRowExpanded(row)) != null ? _instance$options$get : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n      },\n      getCanExpand: () => {\n        var _instance$options$get2, _instance$options$ena, _row$subRows;\n\n        return ((_instance$options$get2 = instance.options.getRowCanExpand == null ? void 0 : instance.options.getRowCanExpand(row)) != null ? _instance$options$get2 : true) && ((_instance$options$ena = instance.options.enableExpanding) != null ? _instance$options$ena : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n      },\n      getToggleExpandedHandler: () => {\n        const canExpand = row.getCanExpand();\n        return () => {\n          if (!canExpand) return;\n          row.toggleExpanded();\n        };\n      }\n    };\n  }\n};\n\nconst includesString = (row, columnId, filterValue) => {\n  const search = filterValue.toLowerCase();\n  return row.getValue(columnId).toLowerCase().includes(search);\n};\n\nincludesString.autoRemove = val => testFalsey(val);\n\nconst includesStringSensitive = (row, columnId, filterValue) => {\n  return row.getValue(columnId).includes(filterValue);\n};\n\nincludesStringSensitive.autoRemove = val => testFalsey(val);\n\nconst equalsString = (row, columnId, filterValue) => {\n  return row.getValue(columnId).toLowerCase() === filterValue.toLowerCase();\n};\n\nequalsString.autoRemove = val => testFalsey(val);\n\nconst arrIncludes = (row, columnId, filterValue) => {\n  return row.getValue(columnId).includes(filterValue);\n};\n\narrIncludes.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst arrIncludesAll = (row, columnId, filterValue) => {\n  return !filterValue.some(val => !row.getValue(columnId).includes(val));\n};\n\narrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst arrIncludesSome = (row, columnId, filterValue) => {\n  return filterValue.some(val => row.getValue(columnId).includes(val));\n};\n\narrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);\n\nconst equals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) === filterValue;\n};\n\nequals.autoRemove = val => testFalsey(val);\n\nconst weakEquals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) == filterValue;\n};\n\nweakEquals.autoRemove = val => testFalsey(val);\n\nconst inNumberRange = (row, columnId, filterValue) => {\n  let [min, max] = filterValue;\n  const rowValue = row.getValue(columnId);\n  return rowValue >= min && rowValue <= max;\n};\n\ninNumberRange.resolveFilterValue = val => {\n  let [unsafeMin, unsafeMax] = val;\n  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;\n  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;\n  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n\n  if (min > max) {\n    const temp = min;\n    min = max;\n    max = temp;\n  }\n\n  return [min, max];\n};\n\ninNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]); // Export\n\n\nconst filterFns = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  arrIncludes,\n  arrIncludesAll,\n  arrIncludesSome,\n  equals,\n  weakEquals,\n  inNumberRange\n};\n\n// Utils\nfunction testFalsey(val) {\n  return val === undefined || val === null || val === '';\n}\n\n//\nconst Filters = {\n  getDefaultColumnDef: () => {\n    return {\n      filterFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      columnFilters: [],\n      globalFilter: undefined,\n      // filtersProgress: 1,\n      // facetProgress: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', instance),\n      onGlobalFilterChange: makeStateUpdater('globalFilter', instance),\n      filterFromLeafRows: false,\n      globalFilterFn: 'auto',\n      getColumnCanGlobalFilter: column => {\n        var _instance$getCoreRowM, _instance$getCoreRowM2;\n\n        const value = (_instance$getCoreRowM = instance.getCoreRowModel().flatRows[0]) == null ? void 0 : (_instance$getCoreRowM2 = _instance$getCoreRowM._getAllCellsByColumnId()[column.id]) == null ? void 0 : _instance$getCoreRowM2.getValue();\n        return typeof value === 'string';\n      }\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      filterFn: column.filterFn,\n      getAutoFilterFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'string') {\n          return filterFns.includesString;\n        }\n\n        if (typeof value === 'number') {\n          return filterFns.inNumberRange;\n        }\n\n        if (typeof value === 'boolean') {\n          return filterFns.equals;\n        }\n\n        if (value !== null && typeof value === 'object') {\n          return filterFns.equals;\n        }\n\n        if (Array.isArray(value)) {\n          return filterFns.arrIncludes;\n        }\n\n        return filterFns.weakEquals;\n      },\n      getFilterFn: () => {\n        var _ref;\n\n        const userFilterFns = instance.options.filterFns;\n        return isFunction(column.filterFn) ? column.filterFn : column.filterFn === 'auto' ? column.getAutoFilterFn() : (_ref = userFilterFns == null ? void 0 : userFilterFns[column.filterFn]) != null ? _ref : filterFns[column.filterFn];\n      },\n      getCanFilter: () => {\n        var _column$columnDef$ena, _instance$options$ena, _instance$options$ena2;\n\n        return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_instance$options$ena = instance.options.enableColumnFilters) != null ? _instance$options$ena : true) && ((_instance$options$ena2 = instance.options.enableFilters) != null ? _instance$options$ena2 : true) && !!column.accessorFn;\n      },\n      getCanGlobalFilter: () => {\n        var _column$columnDef$ena2, _instance$options$ena3, _instance$options$ena4, _instance$options$get;\n\n        return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_instance$options$ena3 = instance.options.enableGlobalFilter) != null ? _instance$options$ena3 : true) && ((_instance$options$ena4 = instance.options.enableFilters) != null ? _instance$options$ena4 : true) && ((_instance$options$get = instance.options.getColumnCanGlobalFilter == null ? void 0 : instance.options.getColumnCanGlobalFilter(column)) != null ? _instance$options$get : true) && !!column.accessorFn;\n      },\n      getIsFiltered: () => column.getFilterIndex() > -1,\n      getFilterValue: () => {\n        var _instance$getState$co, _instance$getState$co2;\n\n        return (_instance$getState$co = instance.getState().columnFilters) == null ? void 0 : (_instance$getState$co2 = _instance$getState$co.find(d => d.id === column.id)) == null ? void 0 : _instance$getState$co2.value;\n      },\n      getFilterIndex: () => {\n        var _instance$getState$co3, _instance$getState$co4;\n\n        return (_instance$getState$co3 = (_instance$getState$co4 = instance.getState().columnFilters) == null ? void 0 : _instance$getState$co4.findIndex(d => d.id === column.id)) != null ? _instance$getState$co3 : -1;\n      },\n      setFilterValue: value => {\n        instance.setColumnFilters(old => {\n          const filterFn = column.getFilterFn();\n          const previousfilter = old == null ? void 0 : old.find(d => d.id === column.id);\n          const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined); //\n\n          if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n            var _old$filter;\n\n            return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];\n          }\n\n          const newFilterObj = {\n            id: column.id,\n            value: newFilter\n          };\n\n          if (previousfilter) {\n            var _old$map;\n\n            return (_old$map = old == null ? void 0 : old.map(d => {\n              if (d.id === column.id) {\n                return newFilterObj;\n              }\n\n              return d;\n            })) != null ? _old$map : [];\n          }\n\n          if (old != null && old.length) {\n            return [...old, newFilterObj];\n          }\n\n          return [newFilterObj];\n        });\n      },\n      _getFacetedRowModel: instance.options.getFacetedRowModel && instance.options.getFacetedRowModel(instance, column.id),\n      getFacetedRowModel: () => {\n        if (!column._getFacetedRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return column._getFacetedRowModel();\n      },\n      _getFacetedUniqueValues: instance.options.getFacetedUniqueValues && instance.options.getFacetedUniqueValues(instance, column.id),\n      getFacetedUniqueValues: () => {\n        if (!column._getFacetedUniqueValues) {\n          return new Map();\n        }\n\n        return column._getFacetedUniqueValues();\n      },\n      _getFacetedMinMaxValues: instance.options.getFacetedMinMaxValues && instance.options.getFacetedMinMaxValues(instance, column.id),\n      getFacetedMinMaxValues: () => {\n        if (!column._getFacetedMinMaxValues) {\n          return undefined;\n        }\n\n        return column._getFacetedMinMaxValues();\n      } // () => [column.getFacetedRowModel()],\n      // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      columnFilters: {},\n      columnFiltersMeta: {}\n    };\n  },\n  createInstance: instance => {\n    return {\n      getGlobalAutoFilterFn: () => {\n        return filterFns.includesString;\n      },\n      getGlobalFilterFn: () => {\n        var _ref2;\n\n        const {\n          filterFns: userFilterFns,\n          globalFilterFn: globalFilterFn\n        } = instance.options;\n        return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? instance.getGlobalAutoFilterFn() : (_ref2 = userFilterFns == null ? void 0 : userFilterFns[globalFilterFn]) != null ? _ref2 : filterFns[globalFilterFn];\n      },\n      setColumnFilters: updater => {\n        const leafColumns = instance.getAllLeafColumns();\n\n        const updateFn = old => {\n          var _functionalUpdate;\n\n          return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {\n            const column = leafColumns.find(d => d.id === filter.id);\n\n            if (column) {\n              const filterFn = column.getFilterFn();\n\n              if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                return false;\n              }\n            }\n\n            return true;\n          });\n        };\n\n        instance.options.onColumnFiltersChange == null ? void 0 : instance.options.onColumnFiltersChange(updateFn);\n      },\n      setGlobalFilter: updater => {\n        instance.options.onGlobalFilterChange == null ? void 0 : instance.options.onGlobalFilterChange(updater);\n      },\n      resetGlobalFilter: defaultState => {\n        instance.setGlobalFilter(defaultState ? undefined : instance.initialState.globalFilter);\n      },\n      resetColumnFilters: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setColumnFilters(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.columnFilters) != null ? _instance$initialStat : []);\n      },\n      getPreFilteredRowModel: () => instance.getCoreRowModel(),\n      _getFilteredRowModel: instance.options.getFilteredRowModel && instance.options.getFilteredRowModel(instance),\n      getFilteredRowModel: () => {\n        if (instance.options.manualFiltering || !instance._getFilteredRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return instance._getFilteredRowModel();\n      },\n      _getGlobalFacetedRowModel: instance.options.getFacetedRowModel && instance.options.getFacetedRowModel(instance, '__global__'),\n      getGlobalFacetedRowModel: () => {\n        if (instance.options.manualFiltering || !instance._getGlobalFacetedRowModel) {\n          return instance.getPreFilteredRowModel();\n        }\n\n        return instance._getGlobalFacetedRowModel();\n      },\n      _getGlobalFacetedUniqueValues: instance.options.getFacetedUniqueValues && instance.options.getFacetedUniqueValues(instance, '__global__'),\n      getGlobalFacetedUniqueValues: () => {\n        if (!instance._getGlobalFacetedUniqueValues) {\n          return new Map();\n        }\n\n        return instance._getGlobalFacetedUniqueValues();\n      },\n      _getGlobalFacetedMinMaxValues: instance.options.getFacetedMinMaxValues && instance.options.getFacetedMinMaxValues(instance, '__global__'),\n      getGlobalFacetedMinMaxValues: () => {\n        if (!instance._getGlobalFacetedMinMaxValues) {\n          return;\n        }\n\n        return instance._getGlobalFacetedMinMaxValues();\n      }\n    };\n  }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;\n}\n\nconst sum = (columnId, _leafRows, childRows) => {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return childRows.reduce((sum, next) => sum + (typeof next === 'number' ? next : 0), 0);\n};\n\nconst min = (columnId, _leafRows, childRows) => {\n  let min;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n\n    if (value != null && (min > value || min === undefined && value >= value)) {\n      min = value;\n    }\n  });\n  return min;\n};\n\nconst max = (columnId, _leafRows, childRows) => {\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n\n    if (value != null && (max < value || max === undefined && value >= value)) {\n      max = value;\n    }\n  });\n  return max;\n};\n\nconst extent = (columnId, _leafRows, childRows) => {\n  let min;\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value;\n      } else {\n        if (min > value) min = value;\n        if (max < value) max = value;\n      }\n    }\n  });\n  return [min, max];\n};\n\nconst mean = (columnId, leafRows) => {\n  let count = 0;\n  let sum = 0;\n  leafRows.forEach(row => {\n    let value = row.getValue(columnId);\n\n    if (value != null && (value = +value) >= value) {\n      ++count, sum += value;\n    }\n  });\n  if (count) return sum / count;\n  return;\n};\n\nconst median = (columnId, leafRows) => {\n  if (!leafRows.length) {\n    return;\n  }\n\n  let min = 0;\n  let max = 0;\n  leafRows.forEach(row => {\n    let value = row.getValue(columnId);\n\n    if (typeof value === 'number') {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n    }\n  });\n  return (min + max) / 2;\n};\n\nconst unique = (columnId, leafRows) => {\n  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values());\n};\n\nconst uniqueCount = (columnId, leafRows) => {\n  return new Set(leafRows.map(d => d.getValue(columnId))).size;\n};\n\nconst count = (_columnId, leafRows) => {\n  return leafRows.length;\n};\n\nconst aggregationFns = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count\n};\n\n//\nconst Grouping = {\n  getDefaultColumnDef: () => {\n    return {\n      aggregationFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      grouping: [],\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', instance),\n      groupedColumnMode: 'reorder'\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      toggleGrouping: () => {\n        instance.setGrouping(old => {\n          // Find any existing grouping for this column\n          if (old != null && old.includes(column.id)) {\n            return old.filter(d => d !== column.id);\n          }\n\n          return [...(old != null ? old : []), column.id];\n        });\n      },\n      getCanGroup: () => {\n        var _ref, _ref2, _ref3, _column$columnDef$ena;\n\n        return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : instance.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n      },\n      getIsGrouped: () => {\n        var _instance$getState$gr;\n\n        return (_instance$getState$gr = instance.getState().grouping) == null ? void 0 : _instance$getState$gr.includes(column.id);\n      },\n      getGroupedIndex: () => {\n        var _instance$getState$gr2;\n\n        return (_instance$getState$gr2 = instance.getState().grouping) == null ? void 0 : _instance$getState$gr2.indexOf(column.id);\n      },\n      getToggleGroupingHandler: () => {\n        const canGroup = column.getCanGroup();\n        return () => {\n          if (!canGroup) return;\n          column.toggleGrouping();\n        };\n      },\n      getAutoAggregationFn: () => {\n        const firstRow = instance.getCoreRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'number') {\n          return aggregationFns.sum;\n        }\n\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return aggregationFns.extent;\n        }\n\n        return aggregationFns.count;\n      },\n      getAggregationFn: () => {\n        var _ref4;\n\n        const userAggregationFns = instance.options.aggregationFns;\n\n        if (!column) {\n          throw new Error();\n        }\n\n        return isFunction(column.aggregationFn) ? column.aggregationFn : column.aggregationFn === 'auto' ? column.getAutoAggregationFn() : (_ref4 = userAggregationFns == null ? void 0 : userAggregationFns[column.aggregationFn]) != null ? _ref4 : aggregationFns[column.aggregationFn];\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setGrouping: updater => instance.options.onGroupingChange == null ? void 0 : instance.options.onGroupingChange(updater),\n      resetGrouping: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setGrouping(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.grouping) != null ? _instance$initialStat : []);\n      },\n      getPreGroupedRowModel: () => instance.getSortedRowModel(),\n      getGroupedRowModel: () => {\n        if (!instance._getGroupedRowModel && instance.options.getGroupedRowModel) {\n          instance._getGroupedRowModel = instance.options.getGroupedRowModel(instance);\n        }\n\n        if (instance.options.manualGrouping || !instance._getGroupedRowModel) {\n          return instance.getPreGroupedRowModel();\n        }\n\n        return instance._getGroupedRowModel();\n      }\n    };\n  },\n  createRow: row => {\n    return {\n      getIsGrouped: () => !!row.groupingColumnId,\n      _groupingValuesCache: {}\n    };\n  },\n  createCell: (cell, column, row, instance) => {\n    return {\n      getIsGrouped: () => column.getIsGrouped() && column.id === row.groupingColumnId,\n      getIsPlaceholder: () => !cell.getIsGrouped() && column.getIsGrouped(),\n      getIsAggregated: () => {\n        var _row$subRows;\n\n        return !cell.getIsGrouped() && !cell.getIsPlaceholder() && ((_row$subRows = row.subRows) == null ? void 0 : _row$subRows.length) > 1;\n      },\n      renderAggregatedCell: () => {\n        var _column$columnDef$agg;\n\n        const template = (_column$columnDef$agg = column.columnDef.aggregatedCell) != null ? _column$columnDef$agg : column.columnDef.cell;\n        return template ? instance._render(template, {\n          instance,\n          column,\n          row,\n          cell,\n          getValue: cell.getValue\n        }) : null;\n      }\n    };\n  }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n  if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n    return leafColumns;\n  }\n\n  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));\n\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns;\n  }\n\n  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);\n  return [...groupingColumns, ...nonGroupingColumns];\n}\n\n//\nconst Ordering = {\n  getInitialState: state => {\n    return {\n      columnOrder: [],\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', instance)\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnOrder: updater => instance.options.onColumnOrderChange == null ? void 0 : instance.options.onColumnOrderChange(updater),\n      resetColumnOrder: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnOrder(defaultState ? [] : (_instance$initialStat = instance.initialState.columnOrder) != null ? _instance$initialStat : []);\n      },\n      _getOrderColumnsFn: memo(() => [instance.getState().columnOrder, instance.getState().grouping, instance.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {\n        // Sort grouped columns to the start of the column list\n        // before the headers are built\n        let orderedColumns = []; // If there is no order, return the normal columns\n\n        if (!(columnOrder != null && columnOrder.length)) {\n          orderedColumns = columns;\n        } else {\n          const columnOrderCopy = [...columnOrder]; // If there is an order, make a copy of the columns\n\n          const columnsCopy = [...columns]; // And make a new ordered array of the columns\n          // Loop over the columns and place them in order into the new array\n\n          while (columnsCopy.length && columnOrderCopy.length) {\n            const targetColumnId = columnOrderCopy.shift();\n            const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);\n\n            if (foundIndex > -1) {\n              orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n            }\n          } // If there are any columns left, add them to the end\n\n\n          orderedColumns = [...orderedColumns, ...columnsCopy];\n        }\n\n        return orderColumns(orderedColumns, grouping, groupedColumnMode);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getOrderColumnsFn' // debug: () => instance.options.debugAll ?? instance.options.debugTable,\n\n      })\n    };\n  }\n};\n\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\n\nconst getDefaultPaginationState = () => ({\n  pageIndex: defaultPageIndex,\n  pageSize: defaultPageSize\n});\n\nconst Pagination = {\n  getInitialState: state => {\n    return { ...state,\n      pagination: { ...getDefaultPaginationState(),\n        ...(state == null ? void 0 : state.pagination)\n      }\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', instance)\n    };\n  },\n  createInstance: instance => {\n    let registered = false;\n    let queued = false;\n    return {\n      _autoResetPageIndex: () => {\n        var _ref, _instance$options$aut;\n\n        if (!registered) {\n          instance._queue(() => {\n            registered = true;\n          });\n\n          return;\n        }\n\n        if ((_ref = (_instance$options$aut = instance.options.autoResetAll) != null ? _instance$options$aut : instance.options.autoResetPageIndex) != null ? _ref : !instance.options.manualPagination) {\n          if (queued) return;\n          queued = true;\n\n          instance._queue(() => {\n            instance.resetPageIndex();\n            queued = false;\n          });\n        }\n      },\n      setPagination: updater => {\n        const safeUpdater = old => {\n          let newState = functionalUpdate(updater, old);\n          return newState;\n        };\n\n        return instance.options.onPaginationChange == null ? void 0 : instance.options.onPaginationChange(safeUpdater);\n      },\n      resetPagination: defaultState => {\n        var _instance$initialStat;\n\n        instance.setPagination(defaultState ? getDefaultPaginationState() : (_instance$initialStat = instance.initialState.pagination) != null ? _instance$initialStat : getDefaultPaginationState());\n      },\n      setPageIndex: updater => {\n        instance.setPagination(old => {\n          let pageIndex = functionalUpdate(updater, old.pageIndex);\n          const maxPageIndex = typeof old.pageCount !== 'undefined' ? old.pageCount - 1 : Number.MAX_SAFE_INTEGER;\n          pageIndex = Math.min(Math.max(0, pageIndex), maxPageIndex);\n          return { ...old,\n            pageIndex\n          };\n        });\n      },\n      resetPageIndex: defaultState => {\n        var _instance$initialStat2, _instance$initialStat3, _instance$initialStat4;\n\n        instance.setPageIndex(defaultState ? defaultPageIndex : (_instance$initialStat2 = (_instance$initialStat3 = instance.initialState) == null ? void 0 : (_instance$initialStat4 = _instance$initialStat3.pagination) == null ? void 0 : _instance$initialStat4.pageIndex) != null ? _instance$initialStat2 : defaultPageIndex);\n      },\n      resetPageSize: defaultState => {\n        var _instance$initialStat5, _instance$initialStat6, _instance$initialStat7;\n\n        instance.setPageSize(defaultState ? defaultPageSize : (_instance$initialStat5 = (_instance$initialStat6 = instance.initialState) == null ? void 0 : (_instance$initialStat7 = _instance$initialStat6.pagination) == null ? void 0 : _instance$initialStat7.pageSize) != null ? _instance$initialStat5 : defaultPageSize);\n      },\n      setPageSize: updater => {\n        instance.setPagination(old => {\n          const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n          const topRowIndex = old.pageSize * old.pageIndex;\n          const pageIndex = Math.floor(topRowIndex / pageSize);\n          return { ...old,\n            pageIndex,\n            pageSize\n          };\n        });\n      },\n      setPageCount: updater => instance.setPagination(old => {\n        var _old$pageCount;\n\n        let newPageCount = functionalUpdate(updater, (_old$pageCount = old.pageCount) != null ? _old$pageCount : -1);\n\n        if (typeof newPageCount === 'number') {\n          newPageCount = Math.max(-1, newPageCount);\n        }\n\n        return { ...old,\n          pageCount: newPageCount\n        };\n      }),\n      getPageOptions: memo(() => [instance.getState().pagination.pageSize, instance.getState().pagination.pageCount], (pageSize, pageCount) => {\n        let pageOptions = [];\n\n        if (pageCount && pageCount > 0) {\n          pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);\n        }\n\n        return pageOptions;\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getPageOptions',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n        }\n      }),\n      getCanPreviousPage: () => instance.getState().pagination.pageIndex > 0,\n      getCanNextPage: () => {\n        const {\n          pageIndex\n        } = instance.getState().pagination;\n        const pageCount = instance.getPageCount();\n\n        if (pageCount === -1) {\n          return true;\n        }\n\n        if (pageCount === 0) {\n          return false;\n        }\n\n        return pageIndex < pageCount - 1;\n      },\n      previousPage: () => {\n        return instance.setPageIndex(old => old - 1);\n      },\n      nextPage: () => {\n        return instance.setPageIndex(old => {\n          return old + 1;\n        });\n      },\n      getPrePaginationRowModel: () => instance.getExpandedRowModel(),\n      getPaginationRowModel: () => {\n        if (!instance._getPaginationRowModel && instance.options.getPaginationRowModel) {\n          instance._getPaginationRowModel = instance.options.getPaginationRowModel(instance);\n        }\n\n        if (instance.options.manualPagination || !instance._getPaginationRowModel) {\n          return instance.getPrePaginationRowModel();\n        }\n\n        return instance._getPaginationRowModel();\n      },\n      getPageCount: () => {\n        const {\n          pageCount\n        } = instance.getState().pagination;\n\n        if (typeof pageCount !== 'undefined') {\n          return pageCount;\n        }\n\n        return Math.ceil(instance.getPrePaginationRowModel().rows.length / instance.getState().pagination.pageSize);\n      }\n    };\n  }\n};\n\n//\nconst getDefaultPinningState = () => ({\n  left: [],\n  right: []\n});\n\nconst Pinning = {\n  getInitialState: state => {\n    return {\n      columnPinning: getDefaultPinningState(),\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      pin: position => {\n        const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);\n        instance.setColumnPinning(old => {\n          var _old$left3, _old$right3;\n\n          if (position === 'right') {\n            var _old$left, _old$right;\n\n            return {\n              left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n              right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]\n            };\n          }\n\n          if (position === 'left') {\n            var _old$left2, _old$right2;\n\n            return {\n              left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],\n              right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n            };\n          }\n\n          return {\n            left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n            right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n          };\n        });\n      },\n      getCanPin: () => {\n        const leafColumns = column.getLeafColumns();\n        return leafColumns.some(d => {\n          var _d$columnDef$enablePi, _instance$options$ena;\n\n          return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_instance$options$ena = instance.options.enablePinning) != null ? _instance$options$ena : true);\n        });\n      },\n      getIsPinned: () => {\n        const leafColumnIds = column.getLeafColumns().map(d => d.id);\n        const {\n          left,\n          right\n        } = instance.getState().columnPinning;\n        const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));\n        const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));\n        return isLeft ? 'left' : isRight ? 'right' : false;\n      },\n      getPinnedIndex: () => {\n        var _instance$getState$co, _instance$getState$co2, _instance$getState$co3;\n\n        const position = column.getIsPinned();\n        return position ? (_instance$getState$co = (_instance$getState$co2 = instance.getState().columnPinning) == null ? void 0 : (_instance$getState$co3 = _instance$getState$co2[position]) == null ? void 0 : _instance$getState$co3.indexOf(column.id)) != null ? _instance$getState$co : -1 : 0;\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      getCenterVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allCells, left, right) => {\n        const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n        return allCells.filter(d => !leftAndRight.includes(d.column.id));\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getCenterVisibleCells',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n        }\n      }),\n      getLeftVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.left,,], (allCells, left) => {\n        const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({ ...d,\n          position: 'left'\n        }));\n        return cells;\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getLeftVisibleCells',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n        }\n      }),\n      getRightVisibleCells: memo(() => [row._getAllVisibleCells(), instance.getState().columnPinning.right], (allCells, right) => {\n        const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({ ...d,\n          position: 'left'\n        }));\n        return cells;\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row.getRightVisibleCells',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugRows;\n        }\n      })\n    };\n  },\n  createInstance: instance => {\n    return {\n      setColumnPinning: updater => instance.options.onColumnPinningChange == null ? void 0 : instance.options.onColumnPinningChange(updater),\n      resetColumnPinning: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        return instance.setColumnPinning(defaultState ? getDefaultPinningState() : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.columnPinning) != null ? _instance$initialStat : getDefaultPinningState());\n      },\n      getIsSomeColumnsPinned: position => {\n        var _pinningState$positio;\n\n        const pinningState = instance.getState().columnPinning;\n\n        if (!position) {\n          var _pinningState$left, _pinningState$right;\n\n          return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n        }\n\n        return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n      },\n      getLeftLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.left], (allColumns, left) => {\n        return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getLeftLeafColumns',\n        debug: () => {\n          var _instance$options$deb4;\n\n          return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;\n        }\n      }),\n      getRightLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.right], (allColumns, right) => {\n        return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getRightLeafColumns',\n        debug: () => {\n          var _instance$options$deb5;\n\n          return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;\n        }\n      }),\n      getCenterLeafColumns: memo(() => [instance.getAllLeafColumns(), instance.getState().columnPinning.left, instance.getState().columnPinning.right], (allColumns, left, right) => {\n        const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n        return allColumns.filter(d => !leftAndRight.includes(d.id));\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getCenterLeafColumns',\n        debug: () => {\n          var _instance$options$deb6;\n\n          return (_instance$options$deb6 = instance.options.debugAll) != null ? _instance$options$deb6 : instance.options.debugColumns;\n        }\n      })\n    };\n  }\n};\n\n//\nconst RowSelection = {\n  getInitialState: state => {\n    return {\n      rowSelection: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', instance),\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n\n    };\n  },\n  createInstance: instance => {\n    return {\n      setRowSelection: updater => instance.options.onRowSelectionChange == null ? void 0 : instance.options.onRowSelectionChange(updater),\n      resetRowSelection: defaultState => {\n        var _instance$initialStat;\n\n        return instance.setRowSelection(defaultState ? {} : (_instance$initialStat = instance.initialState.rowSelection) != null ? _instance$initialStat : {});\n      },\n      toggleAllRowsSelected: value => {\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !instance.getIsAllRowsSelected();\n          const rowSelection = { ...old\n          };\n          const preGroupedFlatRows = instance.getPreGroupedRowModel().flatRows; // We don't use `mutateRowIsSelected` here for performance reasons.\n          // All of the rows are flat already, so it wouldn't be worth it\n\n          if (value) {\n            preGroupedFlatRows.forEach(row => {\n              rowSelection[row.id] = true;\n            });\n          } else {\n            preGroupedFlatRows.forEach(row => {\n              delete rowSelection[row.id];\n            });\n          }\n\n          return rowSelection;\n        });\n      },\n      toggleAllPageRowsSelected: value => instance.setRowSelection(old => {\n        typeof value !== 'undefined' ? value : !instance.getIsAllPageRowsSelected();\n        const rowSelection = { ...old\n        };\n        instance.getRowModel().rows.forEach(row => {\n          mutateRowIsSelected(rowSelection, row.id, value, instance);\n        });\n        return rowSelection;\n      }),\n      // addRowSelectionRange: rowId => {\n      //   const {\n      //     rows,\n      //     rowsById,\n      //     options: { selectGroupingRows, selectSubRows },\n      //   } = instance\n      //   const findSelectedRow = (rows: Row[]) => {\n      //     let found\n      //     rows.find(d => {\n      //       if (d.getIsSelected()) {\n      //         found = d\n      //         return true\n      //       }\n      //       const subFound = findSelectedRow(d.subRows || [])\n      //       if (subFound) {\n      //         found = subFound\n      //         return true\n      //       }\n      //       return false\n      //     })\n      //     return found\n      //   }\n      //   const firstRow = findSelectedRow(rows) || rows[0]\n      //   const lastRow = rowsById[rowId]\n      //   let include = false\n      //   const selectedRowIds = {}\n      //   const addRow = (row: Row) => {\n      //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n      //       rowsById,\n      //       selectGroupingRows: selectGroupingRows!,\n      //       selectSubRows: selectSubRows!,\n      //     })\n      //   }\n      //   instance.rows.forEach(row => {\n      //     const isFirstRow = row.id === firstRow.id\n      //     const isLastRow = row.id === lastRow.id\n      //     if (isFirstRow || isLastRow) {\n      //       if (!include) {\n      //         include = true\n      //       } else if (include) {\n      //         addRow(row)\n      //         include = false\n      //       }\n      //     }\n      //     if (include) {\n      //       addRow(row)\n      //     }\n      //   })\n      //   instance.setRowSelection(selectedRowIds)\n      // },\n      getPreSelectedRowModel: () => instance.getCoreRowModel(),\n      getSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getCoreRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'development' && 'getSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n        }\n      }),\n      getFilteredSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getFilteredRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'getFilteredSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugTable;\n        }\n      }),\n      getGroupedSelectedRowModel: memo(() => [instance.getState().rowSelection, instance.getGroupedRowModel()], (rowSelection, rowModel) => {\n        if (!Object.keys(rowSelection).length) {\n          return {\n            rows: [],\n            flatRows: [],\n            rowsById: {}\n          };\n        }\n\n        return selectRowsFn(instance, rowModel);\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'getGroupedSelectedRowModel',\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugTable;\n        }\n      }),\n      ///\n      // getGroupingRowCanSelect: rowId => {\n      //   const row = instance.getRow(rowId)\n      //   if (!row) {\n      //     throw new Error()\n      //   }\n      //   if (typeof instance.options.enableGroupingRowSelection === 'function') {\n      //     return instance.options.enableGroupingRowSelection(row)\n      //   }\n      //   return instance.options.enableGroupingRowSelection ?? false\n      // },\n      getIsAllRowsSelected: () => {\n        const preFilteredFlatRows = instance.getPreFilteredRowModel().flatRows;\n        const {\n          rowSelection\n        } = instance.getState();\n        let isAllRowsSelected = Boolean(preFilteredFlatRows.length && Object.keys(rowSelection).length);\n\n        if (isAllRowsSelected) {\n          if (preFilteredFlatRows.some(row => !rowSelection[row.id])) {\n            isAllRowsSelected = false;\n          }\n        }\n\n        return isAllRowsSelected;\n      },\n      getIsAllPageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows;\n        const {\n          rowSelection\n        } = instance.getState();\n        let isAllPageRowsSelected = !!paginationFlatRows.length;\n\n        if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {\n          isAllPageRowsSelected = false;\n        }\n\n        return isAllPageRowsSelected;\n      },\n      getIsSomeRowsSelected: () => {\n        var _instance$getState$ro;\n\n        return !instance.getIsAllRowsSelected() && !!Object.keys((_instance$getState$ro = instance.getState().rowSelection) != null ? _instance$getState$ro : {}).length;\n      },\n      getIsSomePageRowsSelected: () => {\n        const paginationFlatRows = instance.getPaginationRowModel().flatRows;\n        return instance.getIsAllPageRowsSelected() ? false : !!(paginationFlatRows != null && paginationFlatRows.length);\n      },\n      getToggleAllRowsSelectedHandler: () => {\n        return e => {\n          instance.toggleAllRowsSelected(e.target.checked);\n        };\n      },\n      getToggleAllPageRowsSelectedHandler: () => {\n        return e => {\n          instance.toggleAllPageRowsSelected(e.target.checked);\n        };\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      toggleSelected: value => {\n        const isSelected = row.getIsSelected();\n        instance.setRowSelection(old => {\n          value = typeof value !== 'undefined' ? value : !isSelected;\n\n          if (isSelected === value) {\n            return old;\n          }\n\n          const selectedRowIds = { ...old\n          };\n          mutateRowIsSelected(selectedRowIds, row.id, value, instance);\n          return selectedRowIds;\n        });\n      },\n      getIsSelected: () => {\n        const {\n          rowSelection\n        } = instance.getState();\n        return isRowSelected(row, rowSelection) === true;\n      },\n      getIsSomeSelected: () => {\n        const {\n          rowSelection\n        } = instance.getState();\n        return isRowSelected(row, rowSelection) === 'some';\n      },\n      getCanSelect: () => {\n        var _instance$options$ena;\n\n        if (typeof instance.options.enableRowSelection === 'function') {\n          return instance.options.enableRowSelection(row);\n        }\n\n        return (_instance$options$ena = instance.options.enableRowSelection) != null ? _instance$options$ena : true;\n      },\n      getCanSelectSubRows: () => {\n        var _instance$options$ena2;\n\n        if (typeof instance.options.enableSubRowSelection === 'function') {\n          return instance.options.enableSubRowSelection(row);\n        }\n\n        return (_instance$options$ena2 = instance.options.enableSubRowSelection) != null ? _instance$options$ena2 : true;\n      },\n      getCanMultiSelect: () => {\n        var _instance$options$ena3;\n\n        if (typeof instance.options.enableMultiRowSelection === 'function') {\n          return instance.options.enableMultiRowSelection(row);\n        }\n\n        return (_instance$options$ena3 = instance.options.enableMultiRowSelection) != null ? _instance$options$ena3 : true;\n      },\n      getToggleSelectedHandler: () => {\n        const canSelect = row.getCanSelect();\n        return e => {\n          var _target;\n\n          if (!canSelect) return;\n          row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n        };\n      }\n    };\n  }\n};\n\nconst mutateRowIsSelected = (selectedRowIds, id, value, instance) => {\n  var _row$subRows;\n\n  const row = instance.getRow(id);\n  row.getIsGrouped(); // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && instance.options.enableGroupingRowSelection)\n  // ) {\n\n  if (value) {\n    selectedRowIds[id] = true;\n  } else {\n    delete selectedRowIds[id];\n  } // }\n\n\n  if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, instance));\n  }\n};\n\nfunction selectRowsFn(instance, rowModel) {\n  const rowSelection = instance.getState().rowSelection;\n  const newSelectedFlatRows = [];\n  const newSelectedRowsById = {}; // Filters top level and nested rows\n\n  const recurseRows = function (rows, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    return rows.map(row => {\n      var _row$subRows2;\n\n      const isSelected = isRowSelected(row, rowSelection) === true;\n\n      if (isSelected) {\n        newSelectedFlatRows.push(row);\n        newSelectedRowsById[row.id] = row;\n      }\n\n      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n        row = { ...row,\n          subRows: recurseRows(row.subRows, depth + 1)\n        };\n      }\n\n      if (isSelected) {\n        return row;\n      }\n    }).filter(Boolean);\n  };\n\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById\n  };\n}\nfunction isRowSelected(row, selection, instance) {\n  if (selection[row.id]) {\n    return true;\n  }\n\n  if (row.subRows && row.subRows.length) {\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach(subRow => {\n      // Bail out early if we know both of these\n      if (someSelected && !allChildrenSelected) {\n        return;\n      }\n\n      if (isRowSelected(subRow, selection)) {\n        someSelected = true;\n      } else {\n        allChildrenSelected = false;\n      }\n    });\n    return allChildrenSelected ? true : someSelected ? 'some' : false;\n  }\n\n  return false;\n}\n\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\n\nconst alphanumeric = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n\nconst alphanumericCaseSensitive = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n}; // The text filter is more basic (less numeric support)\n// but is much faster\n\n\nconst text = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n}; // The text filter is more basic (less numeric support)\n// but is much faster\n\n\nconst textCaseSensitive = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n\nconst datetime = (rowA, rowB, columnId) => {\n  return compareBasic(rowA.getValue(columnId).getTime(), rowB.getValue(columnId).getTime());\n};\n\nconst basic = (rowA, rowB, columnId) => {\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n}; // Utils\n\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n\n    return String(a);\n  }\n\n  if (typeof a === 'string') {\n    return a;\n  }\n\n  return '';\n} // Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\n\n\nfunction compareAlphanumeric(aStr, bStr) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean); // While\n\n  while (a.length && b.length) {\n    const aa = a.shift();\n    const bb = b.shift();\n    const an = parseInt(aa, 10);\n    const bn = parseInt(bb, 10);\n    const combo = [an, bn].sort(); // Both are string\n\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n\n      if (bb > aa) {\n        return -1;\n      }\n\n      continue;\n    } // One is a string, one is a number\n\n\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    } // Both are numbers\n\n\n    if (an > bn) {\n      return 1;\n    }\n\n    if (bn > an) {\n      return -1;\n    }\n  }\n\n  return a.length - b.length;\n} // Exports\n\n\nconst sortingFns = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic\n};\n\n//\nconst Sorting = {\n  getInitialState: state => {\n    return {\n      sorting: [],\n      ...state\n    };\n  },\n  getDefaultColumnDef: () => {\n    return {\n      sortingFn: 'auto'\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', instance),\n      isMultiSortEvent: e => {\n        return e.shiftKey;\n      }\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      getAutoSortingFn: () => {\n        const firstRows = instance.getFilteredRowModel().flatRows.slice(10);\n        let isString = false;\n\n        for (const row of firstRows) {\n          const value = row == null ? void 0 : row.getValue(column.id);\n\n          if (Object.prototype.toString.call(value) === '[object Date]') {\n            return sortingFns.datetime;\n          }\n\n          if (typeof value === 'string') {\n            isString = true;\n\n            if (value.split(reSplitAlphaNumeric).length > 1) {\n              return sortingFns.alphanumeric;\n            }\n          }\n        }\n\n        if (isString) {\n          return sortingFns.text;\n        }\n\n        return sortingFns.basic;\n      },\n      getAutoSortDir: () => {\n        const firstRow = instance.getFilteredRowModel().flatRows[0];\n        const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n\n        if (typeof value === 'string') {\n          return 'asc';\n        }\n\n        return 'desc';\n      },\n      getSortingFn: () => {\n        var _ref;\n\n        const userSortingFn = instance.options.sortingFns;\n\n        if (!column) {\n          throw new Error();\n        }\n\n        return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === 'auto' ? column.getAutoSortingFn() : (_ref = userSortingFn == null ? void 0 : userSortingFn[column.columnDef.sortingFn]) != null ? _ref : sortingFns[column.columnDef.sortingFn];\n      },\n      toggleSorting: (desc, multi) => {\n        // if (column.columns.length) {\n        //   column.columns.forEach((c, i) => {\n        //     if (c.id) {\n        //       instance.toggleColumnSorting(c.id, undefined, multi || !!i)\n        //     }\n        //   })\n        //   return\n        // }\n        instance.setSorting(old => {\n          var _ref2, _column$columnDef$sor, _instance$options$ena, _instance$options$ena2;\n\n          // Find any existing sorting for this column\n          const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);\n          const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);\n          const hasDescDefined = typeof desc !== 'undefined' && desc !== null;\n          let newSorting = []; // What should we do with this sort action?\n\n          let sortAction;\n\n          if (column.getCanMultiSort() && multi) {\n            if (existingSorting) {\n              sortAction = 'toggle';\n            } else {\n              sortAction = 'add';\n            }\n          } else {\n            // Normal mode\n            if (old != null && old.length && existingIndex !== old.length - 1) {\n              sortAction = 'replace';\n            } else if (existingSorting) {\n              sortAction = 'toggle';\n            } else {\n              sortAction = 'replace';\n            }\n          }\n\n          const sortDescFirst = (_ref2 = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : instance.options.sortDescFirst) != null ? _ref2 : column.getAutoSortDir() === 'desc'; // Handle toggle states that will remove the sorting\n\n          if (sortAction === 'toggle' && ( // Must be toggling\n          (_instance$options$ena = instance.options.enableSortingRemoval) != null ? _instance$options$ena : true) && // If enableSortRemove, enable in general\n          !hasDescDefined && ( // Must not be setting desc\n          multi ? (_instance$options$ena2 = instance.options.enableMultiRemove) != null ? _instance$options$ena2 : true : true) && ( // If multi, don't allow if enableMultiRemove\n          existingSorting != null && existingSorting.desc // Finally, detect if it should indeed be removed\n          ? !sortDescFirst : sortDescFirst)) {\n            sortAction = 'remove';\n          }\n\n          if (sortAction === 'replace') {\n            newSorting = [{\n              id: column.id,\n              desc: hasDescDefined ? desc : !!sortDescFirst\n            }];\n          } else if (sortAction === 'add' && old != null && old.length) {\n            var _instance$options$max;\n\n            newSorting = [...old, {\n              id: column.id,\n              desc: hasDescDefined ? desc : !!sortDescFirst\n            }]; // Take latest n columns\n\n            newSorting.splice(0, newSorting.length - ((_instance$options$max = instance.options.maxMultiSortColCount) != null ? _instance$options$max : Number.MAX_SAFE_INTEGER));\n          } else if (sortAction === 'toggle' && old != null && old.length) {\n            // This flips (or sets) the\n            newSorting = old.map(d => {\n              if (d.id === column.id) {\n                return { ...d,\n                  desc: hasDescDefined ? desc : !(existingSorting != null && existingSorting.desc)\n                };\n              }\n\n              return d;\n            });\n          } else if (sortAction === 'remove' && old != null && old.length) {\n            newSorting = old.filter(d => d.id !== column.id);\n          }\n\n          return newSorting;\n        });\n      },\n      getCanSort: () => {\n        var _column$columnDef$ena, _instance$options$ena3;\n\n        return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_instance$options$ena3 = instance.options.enableSorting) != null ? _instance$options$ena3 : true) && !!column.accessorFn;\n      },\n      getCanMultiSort: () => {\n        var _ref3, _column$columnDef$ena2;\n\n        return (_ref3 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : instance.options.enableMultiSort) != null ? _ref3 : !!column.accessorFn;\n      },\n      getIsSorted: () => {\n        var _instance$getState$so;\n\n        const columnSort = (_instance$getState$so = instance.getState().sorting) == null ? void 0 : _instance$getState$so.find(d => d.id === column.id);\n        return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';\n      },\n      getSortIndex: () => {\n        var _instance$getState$so2, _instance$getState$so3;\n\n        return (_instance$getState$so2 = (_instance$getState$so3 = instance.getState().sorting) == null ? void 0 : _instance$getState$so3.findIndex(d => d.id === column.id)) != null ? _instance$getState$so2 : -1;\n      },\n      clearSorting: () => {\n        //clear sorting for just 1 column\n        instance.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);\n      },\n      getToggleSortingHandler: () => {\n        const canSort = column.getCanSort();\n        return e => {\n          if (!canSort) return;\n          e.persist == null ? void 0 : e.persist();\n          column.toggleSorting == null ? void 0 : column.toggleSorting(undefined, column.getCanMultiSort() ? instance.options.isMultiSortEvent == null ? void 0 : instance.options.isMultiSortEvent(e) : false);\n        };\n      }\n    };\n  },\n  createInstance: instance => {\n    return {\n      setSorting: updater => instance.options.onSortingChange == null ? void 0 : instance.options.onSortingChange(updater),\n      resetSorting: defaultState => {\n        var _instance$initialStat, _instance$initialStat2;\n\n        instance.setSorting(defaultState ? [] : (_instance$initialStat = (_instance$initialStat2 = instance.initialState) == null ? void 0 : _instance$initialStat2.sorting) != null ? _instance$initialStat : []);\n      },\n      getPreSortedRowModel: () => instance.getFilteredRowModel(),\n      getSortedRowModel: () => {\n        if (!instance._getSortedRowModel && instance.options.getSortedRowModel) {\n          instance._getSortedRowModel = instance.options.getSortedRowModel(instance);\n        }\n\n        if (instance.options.manualSorting || !instance._getSortedRowModel) {\n          return instance.getPreSortedRowModel();\n        }\n\n        return instance._getSortedRowModel();\n      }\n    };\n  }\n};\n\n//\nconst Visibility = {\n  getInitialState: state => {\n    return {\n      columnVisibility: {},\n      ...state\n    };\n  },\n  getDefaultOptions: instance => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', instance)\n    };\n  },\n  createColumn: (column, instance) => {\n    return {\n      toggleVisibility: value => {\n        if (column.getCanHide()) {\n          instance.setColumnVisibility(old => ({ ...old,\n            [column.id]: value != null ? value : !column.getIsVisible()\n          }));\n        }\n      },\n      getIsVisible: () => {\n        var _instance$getState$co, _instance$getState$co2;\n\n        return (_instance$getState$co = (_instance$getState$co2 = instance.getState().columnVisibility) == null ? void 0 : _instance$getState$co2[column.id]) != null ? _instance$getState$co : true;\n      },\n      getCanHide: () => {\n        var _column$columnDef$ena, _instance$options$ena;\n\n        return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_instance$options$ena = instance.options.enableHiding) != null ? _instance$options$ena : true);\n      },\n      getToggleVisibilityHandler: () => {\n        return e => {\n          column.toggleVisibility == null ? void 0 : column.toggleVisibility(e.target.checked);\n        };\n      }\n    };\n  },\n  createRow: (row, instance) => {\n    return {\n      _getAllVisibleCells: memo(() => [row.getAllCells().filter(cell => cell.column.getIsVisible()).map(d => d.id).join('_')], _ => {\n        return row.getAllCells().filter(cell => cell.column.getIsVisible());\n      }, {\n        key: process.env.NODE_ENV === 'production' && 'row._getAllVisibleCells',\n        debug: () => {\n          var _instance$options$deb;\n\n          return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n        }\n      }),\n      getVisibleCells: memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], {\n        key: process.env.NODE_ENV === 'development' && 'row.getVisibleCells',\n        debug: () => {\n          var _instance$options$deb2;\n\n          return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n        }\n      })\n    };\n  },\n  createInstance: instance => {\n    const makeVisibleColumnsMethod = (key, getColumns) => {\n      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {\n        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());\n      }, {\n        key,\n        debug: () => {\n          var _instance$options$deb3;\n\n          return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;\n        }\n      });\n    };\n\n    return {\n      getVisibleFlatColumns: makeVisibleColumnsMethod('getVisibleFlatColumns', () => instance.getAllFlatColumns()),\n      getVisibleLeafColumns: makeVisibleColumnsMethod('getVisibleLeafColumns', () => instance.getAllLeafColumns()),\n      getLeftVisibleLeafColumns: makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => instance.getLeftLeafColumns()),\n      getRightVisibleLeafColumns: makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => instance.getRightLeafColumns()),\n      getCenterVisibleLeafColumns: makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => instance.getCenterLeafColumns()),\n      setColumnVisibility: updater => instance.options.onColumnVisibilityChange == null ? void 0 : instance.options.onColumnVisibilityChange(updater),\n      resetColumnVisibility: defaultState => {\n        var _instance$initialStat;\n\n        instance.setColumnVisibility(defaultState ? {} : (_instance$initialStat = instance.initialState.columnVisibility) != null ? _instance$initialStat : {});\n      },\n      toggleAllColumnsVisible: value => {\n        var _value;\n\n        value = (_value = value) != null ? _value : !instance.getIsAllColumnsVisible();\n        instance.setColumnVisibility(instance.getAllLeafColumns().reduce((obj, column) => ({ ...obj,\n          [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n        }), {}));\n      },\n      getIsAllColumnsVisible: () => !instance.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible())),\n      getIsSomeColumnsVisible: () => instance.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible()),\n      getToggleAllColumnsVisibilityHandler: () => {\n        return e => {\n          var _target;\n\n          instance.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n        };\n      }\n    };\n  }\n};\n\nconst features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing]; //\n\nfunction createTableInstance(options) {\n  var _options$initialState;\n\n  if (options.debugAll || options.debugTable) {\n    console.info('Creating Table Instance...');\n  }\n\n  let instance = {\n    _features: features\n  };\n\n  const defaultOptions = instance._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(instance));\n  }, {});\n\n  const mergeOptions = options => {\n    if (instance.options.mergeOptions) {\n      return instance.options.mergeOptions(defaultOptions, options);\n    }\n\n    return { ...defaultOptions,\n      ...options\n    };\n  };\n\n  const coreInitialState = {};\n  let initialState = { ...coreInitialState,\n    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})\n  };\n\n  instance._features.forEach(feature => {\n    var _feature$getInitialSt;\n\n    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n  });\n\n  const queued = [];\n  let queuedTimeout = false;\n  const coreInstance = {\n    _features: features,\n    options: { ...defaultOptions,\n      ...options\n    },\n    initialState,\n    _queue: cb => {\n      queued.push(cb);\n\n      if (!queuedTimeout) {\n        queuedTimeout = true; // Schedule a microtask to run the queued callbacks after\n        // the current call stack (render, etc) has finished.\n\n        Promise.resolve().then(() => {\n          while (queued.length) {\n            queued.shift()();\n          }\n\n          queuedTimeout = false;\n        }).catch(error => setTimeout(() => {\n          throw error;\n        }));\n      }\n    },\n    reset: () => {\n      instance.setState(instance.initialState);\n    },\n    setOptions: updater => {\n      const newOptions = functionalUpdate(updater, instance.options);\n      instance.options = mergeOptions(newOptions);\n    },\n    _render: (template, props) => {\n      if (typeof instance.options.render === 'function') {\n        return instance.options.render(template, props);\n      }\n\n      if (typeof template === 'function') {\n        return template(props);\n      }\n\n      return template;\n    },\n    getState: () => {\n      return instance.options.state;\n    },\n    setState: updater => {\n      instance.options.onStateChange == null ? void 0 : instance.options.onStateChange(updater);\n    },\n    _getRowId: (row, index, parent) => {\n      var _instance$options$get;\n\n      return (_instance$options$get = instance.options.getRowId == null ? void 0 : instance.options.getRowId(row, index, parent)) != null ? _instance$options$get : \"\" + (parent ? [parent.id, index].join('.') : index);\n    },\n    getCoreRowModel: () => {\n      if (!instance._getCoreRowModel) {\n        instance._getCoreRowModel = instance.options.getCoreRowModel(instance);\n      }\n\n      return instance._getCoreRowModel();\n    },\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n    getRowModel: () => {\n      return instance.getPaginationRowModel();\n    },\n    getRow: id => {\n      const row = instance.getRowModel().rowsById[id];\n\n      if (!row) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\"getRow expected an ID, but got \" + id);\n        }\n\n        throw new Error();\n      }\n\n      return row;\n    },\n    _getDefaultColumnDef: memo(() => [instance.options.defaultColumn], defaultColumn => {\n      var _defaultColumn;\n\n      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n      return {\n        header: props => props.header.column.id,\n        footer: props => props.header.column.id,\n        cell: props => {\n          var _props$getValue$toStr, _props$getValue$toStr2, _props$getValue;\n\n          return (_props$getValue$toStr = (_props$getValue$toStr2 = (_props$getValue = props.getValue()).toString) == null ? void 0 : _props$getValue$toStr2.call(_props$getValue)) != null ? _props$getValue$toStr : null;\n        },\n        ...instance._features.reduce((obj, feature) => {\n          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n        }, {}),\n        ...defaultColumn\n      };\n    }, {\n      debug: () => {\n        var _instance$options$deb;\n\n        return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugColumns;\n      },\n      key: process.env.NODE_ENV === 'development' && 'getDefaultColumnDef'\n    }),\n    _getColumnDefs: () => instance.options.columns,\n    getAllColumns: memo(() => [instance._getColumnDefs()], columnDefs => {\n      const recurseColumns = function (columnDefs, parent, depth) {\n        if (depth === void 0) {\n          depth = 0;\n        }\n\n        return columnDefs.map(columnDef => {\n          const column = createColumn(instance, columnDef, depth, parent);\n          column.columns = columnDef.columns ? recurseColumns(columnDef.columns, column, depth + 1) : [];\n          return column;\n        });\n      };\n\n      return recurseColumns(columnDefs);\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllColumns',\n      debug: () => {\n        var _instance$options$deb2;\n\n        return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugColumns;\n      }\n    }),\n    getAllFlatColumns: memo(() => [instance.getAllColumns()], allColumns => {\n      return allColumns.flatMap(column => {\n        return column.getFlatColumns();\n      });\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllFlatColumns',\n      debug: () => {\n        var _instance$options$deb3;\n\n        return (_instance$options$deb3 = instance.options.debugAll) != null ? _instance$options$deb3 : instance.options.debugColumns;\n      }\n    }),\n    _getAllFlatColumnsById: memo(() => [instance.getAllFlatColumns()], flatColumns => {\n      return flatColumns.reduce((acc, column) => {\n        acc[column.id] = column;\n        return acc;\n      }, {});\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllFlatColumnsById',\n      debug: () => {\n        var _instance$options$deb4;\n\n        return (_instance$options$deb4 = instance.options.debugAll) != null ? _instance$options$deb4 : instance.options.debugColumns;\n      }\n    }),\n    getAllLeafColumns: memo(() => [instance.getAllColumns(), instance._getOrderColumnsFn()], (allColumns, orderColumns) => {\n      let leafColumns = allColumns.flatMap(column => column.getLeafColumns());\n      return orderColumns(leafColumns);\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'getAllLeafColumns',\n      debug: () => {\n        var _instance$options$deb5;\n\n        return (_instance$options$deb5 = instance.options.debugAll) != null ? _instance$options$deb5 : instance.options.debugColumns;\n      }\n    }),\n    getColumn: columnId => {\n      const column = instance._getAllFlatColumnsById()[columnId];\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"[Table] Column with id \" + columnId + \" does not exist.\");\n        }\n\n        throw new Error();\n      }\n\n      return column;\n    }\n  };\n  Object.assign(instance, coreInstance);\n\n  instance._features.forEach(feature => {\n    return Object.assign(instance, feature.createInstance == null ? void 0 : feature.createInstance(instance));\n  });\n\n  return instance;\n}\n\n//\nfunction createTableFactory(opts) {\n  return () => createTable(undefined, undefined, opts);\n} // A lot of returns in here are `as any` for a reason. Unless you\n// can find a better way to do this, then don't worry about them\n\nfunction createTable(_, __, options) {\n  const table = {\n    generics: undefined,\n    options: options != null ? options : {\n      render: (() => {\n        throw new Error('');\n      })()\n    },\n    // setGenerics: () => table as any,\n    setRowType: () => table,\n    setTableMetaType: () => table,\n    setColumnMetaType: () => table,\n    setFilterMetaType: () => table,\n    setOptions: newOptions => createTable(_, __, { ...options,\n      ...newOptions\n    }),\n    createDisplayColumn: column => ({ ...column,\n      columnDefType: 'display'\n    }),\n    createGroup: column => ({ ...column,\n      columnDefType: 'group'\n    }),\n    createDataColumn: (accessor, column) => {\n      column = { ...column,\n        columnDefType: 'data',\n        id: column.id\n      };\n\n      if (typeof accessor === 'string') {\n        var _column$id;\n\n        return { ...column,\n          id: (_column$id = column.id) != null ? _column$id : accessor,\n          accessorKey: accessor\n        };\n      }\n\n      if (typeof accessor === 'function') {\n        return { ...column,\n          accessorFn: accessor\n        };\n      }\n\n      throw new Error('Invalid accessor');\n    },\n    createOptions: options => options\n  };\n  return table;\n}\n\nfunction createCell(instance, row, column, columnId) {\n  const cell = {\n    id: row.id + \"_\" + column.id,\n    row,\n    column,\n    getValue: () => row.getValue(columnId),\n    renderCell: () => column.columnDef.cell ? instance._render(column.columnDef.cell, {\n      instance,\n      column,\n      row,\n      cell: cell,\n      getValue: cell.getValue\n    }) : null\n  };\n\n  instance._features.forEach(feature => {\n    Object.assign(cell, feature.createCell == null ? void 0 : feature.createCell(cell, column, row, instance));\n  }, {});\n\n  return cell;\n}\n\nconst createRow = (instance, id, original, rowIndex, depth, subRows) => {\n  let row = {\n    id,\n    index: rowIndex,\n    original,\n    depth,\n    _valuesCache: {},\n    getValue: columnId => {\n      if (row._valuesCache.hasOwnProperty(columnId)) {\n        return row._valuesCache[columnId];\n      }\n\n      const column = instance.getColumn(columnId);\n\n      if (!column.accessorFn) {\n        return undefined;\n      }\n\n      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n      return row._valuesCache[columnId];\n    },\n    subRows: subRows != null ? subRows : [],\n    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\n    getAllCells: memo(() => [instance.getAllLeafColumns()], leafColumns => {\n      return leafColumns.map(column => {\n        return createCell(instance, row, column, column.id);\n      });\n    }, {\n      key: process.env.NODE_ENV === 'development' && 'row.getAllCells',\n      debug: () => {\n        var _instance$options$deb;\n\n        return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugRows;\n      }\n    }),\n    _getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {\n      return allCells.reduce((acc, cell) => {\n        acc[cell.column.id] = cell;\n        return acc;\n      }, {});\n    }, {\n      key: process.env.NODE_ENV === 'production' && 'row.getAllCellsByColumnId',\n      debug: () => {\n        var _instance$options$deb2;\n\n        return (_instance$options$deb2 = instance.options.debugAll) != null ? _instance$options$deb2 : instance.options.debugRows;\n      }\n    })\n  };\n\n  for (let i = 0; i < instance._features.length; i++) {\n    const feature = instance._features[i];\n    Object.assign(row, feature == null ? void 0 : feature.createRow == null ? void 0 : feature.createRow(row, instance));\n  }\n\n  return row;\n};\n\nfunction getCoreRowModel() {\n  return instance => memo(() => [instance.options.data], data => {\n    const rowModel = {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    };\n    let rows;\n    let row;\n    let originalRow;\n\n    const accessRows = function (originalRows, depth, parent) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      rows = [];\n\n      for (let i = 0; i < originalRows.length; i++) {\n        originalRow = originalRows[i]; // This could be an expensive check at scale, so we should move it somewhere else, but where?\n        // if (!id) {\n        //   if (process.env.NODE_ENV !== 'production') {\n        //     throw new Error(`getRowId expected an ID, but got ${id}`)\n        //   }\n        // }\n        // Make the row\n\n        row = createRow(instance, instance._getRowId(originalRow, i, parent), originalRow, i, depth); // Keep track of every row in a flat array\n\n        rowModel.flatRows.push(row); // Also keep track of every row by its ID\n\n        rowModel.rowsById[row.id] = row; // Push instance row into parent\n\n        rows.push(row); // Get the original subrows\n\n        if (instance.options.getSubRows) {\n          var _row$originalSubRows;\n\n          row.originalSubRows = instance.options.getSubRows(originalRow, i); // Then recursively access them\n\n          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n          }\n        }\n      }\n\n      return rows;\n    };\n\n    rowModel.rows = accessRows(data);\n    return rowModel;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction filterRows(rows, filterRowImpl, instance) {\n  if (instance.options.filterFromLeafRows) {\n    return filterRowModelFromLeafs(rows, filterRowImpl, instance);\n  }\n\n  return filterRowModelFromRoot(rows, filterRowImpl, instance);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, instance) {\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  let row;\n  let newRow;\n\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    const rows = []; // Filter from children up first\n\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      var _row$subRows;\n\n      row = rowsToFilter[i];\n\n      if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n        newRow = createRow(instance, row.id, row.original, row.index, row.depth);\n        newRow.columnFilters = row.columnFilters;\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n\n        if (!newRow.subRows.length) {\n          continue;\n        }\n\n        row = newRow;\n      }\n\n      if (filterRow(row)) {\n        rows.push(row);\n        newFilteredRowsById[row.id] = row;\n        newFilteredRowsById[i] = row;\n      }\n    }\n\n    return rows;\n  };\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, instance) {\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  let rows;\n  let row;\n  let newRow; // Filters top level and nested rows\n\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    // Filter from parents downward first\n    rows = []; // Apply the filter to any subRows\n\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      row = rowsToFilter[i];\n      const pass = filterRow(row);\n\n      if (pass) {\n        var _row$subRows2;\n\n        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n          newRow = createRow(instance, row.id, row.original, row.index, row.depth);\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n          row = newRow;\n        }\n\n        rows.push(row);\n        newFilteredFlatRows.push(row);\n        newFilteredRowsById[row.id] = row;\n      }\n    }\n\n    return rows;\n  };\n\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\n\nfunction getFilteredRowModel() {\n  return instance => memo(() => [instance.getPreFilteredRowModel(), instance.getState().columnFilters, instance.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {\n    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      for (let i = 0; i < rowModel.flatRows.length; i++) {\n        rowModel.flatRows[i].columnFilters = {};\n        rowModel.flatRows[i].columnFiltersMeta = {};\n      }\n\n      return rowModel;\n    }\n\n    const resolvedColumnFilters = [];\n    const resolvedGlobalFilters = [];\n    (columnFilters != null ? columnFilters : []).forEach(d => {\n      var _filterFn$resolveFilt;\n\n      const column = instance.getColumn(d.id);\n\n      if (!column) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"Table: Could not find a column to filter with columnId: \" + d.id);\n        }\n      }\n\n      const filterFn = column.getFilterFn();\n\n      if (!filterFn) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\"Could not find a valid 'column.filterFn' for column with the ID: \" + column.id + \".\");\n        }\n\n        return;\n      }\n\n      resolvedColumnFilters.push({\n        id: d.id,\n        filterFn,\n        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n      });\n    });\n    const filterableIds = columnFilters.map(d => d.id);\n    const globalFilterFn = instance.getGlobalFilterFn();\n    const globallyFilterableColumns = instance.getAllLeafColumns().filter(column => column.getCanGlobalFilter());\n\n    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n      filterableIds.push('__global__');\n      globallyFilterableColumns.forEach(column => {\n        var _globalFilterFn$resol;\n\n        resolvedGlobalFilters.push({\n          id: column.id,\n          filterFn: globalFilterFn,\n          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n        });\n      });\n    }\n\n    let currentColumnFilter;\n    let currentGlobalFilter; // Flag the prefiltered row model with each filter state\n\n    for (let j = 0; j < rowModel.flatRows.length; j++) {\n      const row = rowModel.flatRows[j];\n      row.columnFilters = {};\n\n      if (resolvedColumnFilters.length) {\n        for (let i = 0; i < resolvedColumnFilters.length; i++) {\n          currentColumnFilter = resolvedColumnFilters[i];\n          const id = currentColumnFilter.id; // Tag the row with the column filter state\n\n          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          });\n        }\n      }\n\n      if (resolvedGlobalFilters.length) {\n        for (let i = 0; i < resolvedGlobalFilters.length; i++) {\n          currentGlobalFilter = resolvedGlobalFilters[i];\n          const id = currentGlobalFilter.id; // Tag the row with the first truthy global filter state\n\n          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          })) {\n            row.columnFilters.__global__ = true;\n            break;\n          }\n        }\n\n        if (row.columnFilters.__global__ !== true) {\n          row.columnFilters.__global__ = false;\n        }\n      }\n    }\n\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }; // Filter final rows using all of the active filters\n\n\n    return filterRows(rowModel.rows, filterRowsImpl, instance);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFilteredRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction getFacetedRowModel() {\n  return (instance, columnId) => memo(() => [instance.getPreFilteredRowModel(), instance.getState().columnFilters, instance.getState().globalFilter, instance.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {\n    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      return preRowModel;\n    }\n\n    const filterableIds = [...columnFilters.map(d => d.id).filter(d => d !== columnId), globalFilter ? '__global__' : undefined].filter(Boolean);\n\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    return filterRows(preRowModel.rows, filterRowsImpl, instance);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedRowModel_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getFacetedUniqueValues() {\n  return (instance, columnId) => memo(() => [instance.getColumn(columnId).getFacetedRowModel()], facetedRowModel => {\n    let facetedUniqueValues = new Map();\n\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      var _facetedRowModel$flat;\n\n      const value = (_facetedRowModel$flat = facetedRowModel.flatRows[i]) == null ? void 0 : _facetedRowModel$flat.getValue(columnId);\n\n      if (facetedUniqueValues.has(value)) {\n        var _facetedUniqueValues$;\n\n        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n      } else {\n        facetedUniqueValues.set(value, 1);\n      }\n    }\n\n    return facetedUniqueValues;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedUniqueValues_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getFacetedMinMaxValues() {\n  return (instance, columnId) => memo(() => [instance.getColumn(columnId).getFacetedRowModel()], facetedRowModel => {\n    var _facetedRowModel$flat;\n\n    const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getValue(columnId);\n\n    if (typeof firstValue === 'undefined') {\n      return undefined;\n    }\n\n    let facetedMinMaxValues = [firstValue, firstValue];\n\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      var _facetedRowModel$flat2;\n\n      const value = (_facetedRowModel$flat2 = facetedRowModel.flatRows[i]) == null ? void 0 : _facetedRowModel$flat2.getValue(columnId);\n\n      if (value < facetedMinMaxValues[0]) {\n        facetedMinMaxValues[0] = value;\n      } else if (value > facetedMinMaxValues[1]) {\n        facetedMinMaxValues[1] = value;\n      }\n    }\n\n    return facetedMinMaxValues;\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getFacetedMinMaxValues_' + columnId,\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {}\n  });\n}\n\nfunction getSortedRowModel() {\n  return instance => memo(() => [instance.getState().sorting, instance.getPreSortedRowModel()], (sorting, rowModel) => {\n    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n      return rowModel;\n    }\n\n    const sortingState = instance.getState().sorting;\n    const sortedFlatRows = []; // Filter out sortings that correspond to non existing columns\n\n    const availableSorting = sortingState.filter(sort => instance.getColumn(sort.id).getCanSort());\n    const columnInfoById = {};\n    availableSorting.forEach(sortEntry => {\n      const column = instance.getColumn(sortEntry.id);\n      columnInfoById[sortEntry.id] = {\n        sortUndefined: column.columnDef.sortUndefined,\n        invertSorting: column.columnDef.invertSorting,\n        sortingFn: column.getSortingFn()\n      };\n    });\n\n    const sortData = rows => {\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = rows.slice();\n      sortedData.sort((rowA, rowB) => {\n        for (let i = 0; i < availableSorting.length; i += 1) {\n          var _sortEntry$desc;\n\n          const sortEntry = availableSorting[i];\n          const columnInfo = columnInfoById[sortEntry.id];\n          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n\n          if (columnInfo.sortUndefined) {\n            const aValue = rowA.getValue(sortEntry.id);\n            const bValue = rowB.getValue(sortEntry.id);\n            const aUndefined = typeof aValue === 'undefined';\n            const bUndefined = typeof bValue === 'undefined';\n\n            if (aUndefined || bUndefined) {\n              return aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n            }\n          } // This function should always return in ascending order\n\n\n          let sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n\n          if (sortInt !== 0) {\n            if (isDesc) {\n              sortInt *= -1;\n            }\n\n            if (columnInfo.invertSorting) {\n              sortInt *= -1;\n            }\n\n            return sortInt;\n          }\n        }\n\n        return rowA.index - rowB.index;\n      }); // If there are sub-rows, sort them\n\n      sortedData.forEach(row => {\n        sortedFlatRows.push(row);\n\n        if (!row.subRows || row.subRows.length <= 1) {\n          return;\n        }\n\n        row.subRows = sortData(row.subRows);\n      });\n      return sortedData;\n    };\n\n    return {\n      rows: sortData(rowModel.rows),\n      flatRows: sortedFlatRows,\n      rowsById: rowModel.rowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getSortedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._autoResetPageIndex();\n    }\n  });\n}\n\nfunction getGroupedRowModel() {\n  return instance => memo(() => [instance.getState().grouping, instance.getPreGroupedRowModel()], (grouping, rowModel) => {\n    if (!rowModel.rows.length || !grouping.length) {\n      return rowModel;\n    } // Filter the grouping list down to columns that exist\n\n\n    const existingGrouping = grouping.filter(columnId => instance.getColumn(columnId));\n    const groupedFlatRows = [];\n    const groupedRowsById = {}; // const onlyGroupedFlatRows: Row[] = [];\n    // const onlyGroupedRowsById: Record<RowId, Row> = {};\n    // const nonGroupedFlatRows: Row[] = [];\n    // const nonGroupedRowsById: Record<RowId, Row> = {};\n    // Recursively group the data\n\n    const groupUpRecursively = function (rows, depth, parentId) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      // This is the last level, just return the rows\n      if (depth === existingGrouping.length) {\n        return rows;\n      }\n\n      const columnId = existingGrouping[depth]; // Group the rows together for this level\n\n      const rowGroupsMap = groupBy(rows, columnId); // Peform aggregations for each group\n\n      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {\n        let [groupingValue, groupedRows] = _ref;\n        let id = columnId + \":\" + groupingValue;\n        id = parentId ? parentId + \">\" + id : id; // First, Recurse to group sub rows before aggregation\n\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n\n        const leafRows = depth ? flattenBy(groupedRows, row => row.subRows) : groupedRows;\n        const row = createRow(instance, id, undefined, index, depth);\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n          getValue: columnId => {\n            // Don't aggregate columns that are in the grouping\n            if (existingGrouping.includes(columnId)) {\n              if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n              }\n\n              if (groupedRows[0]) {\n                var _groupedRows$0$getVal;\n\n                row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n              }\n\n              return row._valuesCache[columnId];\n            }\n\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n              return row._groupingValuesCache[columnId];\n            } // Aggregate the values\n\n\n            const column = instance.getColumn(columnId);\n            const aggregateFn = column.getAggregationFn();\n\n            if (aggregateFn) {\n              row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n              return row._groupingValuesCache[columnId];\n            } else if (column.aggregationFn) {\n              console.info({\n                column\n              });\n              throw new Error(process.env.NODE_ENV !== 'production' ? \"Table: Invalid column.aggregateType option for column listed above\" : '');\n            }\n          }\n        });\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        });\n        return row;\n      });\n      return aggregatedGroupedRows;\n    };\n\n    const groupedRows = groupUpRecursively(rowModel.rows, 0, '');\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {\n      //   onlyGroupedFlatRows.push(subRow);\n      //   onlyGroupedRowsById[subRow.id] = subRow;\n      // } else {\n      //   nonGroupedFlatRows.push(subRow);\n      //   nonGroupedRowsById[subRow.id] = subRow;\n      // }\n    });\n    return {\n      rows: groupedRows,\n      flatRows: groupedFlatRows,\n      rowsById: groupedRowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getGroupedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    },\n    onChange: () => {\n      instance._queue(() => {\n        instance._autoResetExpanded();\n\n        instance._autoResetPageIndex();\n      });\n    }\n  });\n}\n\nfunction groupBy(rows, columnId) {\n  const groupMap = new Map();\n  return rows.reduce((map, row) => {\n    const resKey = \"\" + row.getValue(columnId);\n    const previous = map.get(resKey);\n\n    if (!previous) {\n      map.set(resKey, [row]);\n    } else {\n      map.set(resKey, [...previous, row]);\n    }\n\n    return map;\n  }, groupMap);\n}\n\nfunction getExpandedRowModel() {\n  return instance => memo(() => [instance.getState().expanded, instance.getPreExpandedRowModel(), instance.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {\n    if (!rowModel.rows.length || // Do not expand if rows are not included in pagination\n    !paginateExpandedRows || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n      return rowModel;\n    }\n\n    return expandRows(rowModel);\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getExpandedRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    }\n  });\n}\nfunction expandRows(rowModel, instance) {\n  const expandedRows = [];\n\n  const handleRow = row => {\n    var _row$subRows;\n\n    expandedRows.push(row);\n\n    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n\n  rowModel.rows.forEach(handleRow);\n  return {\n    rows: expandedRows,\n    flatRows: rowModel.flatRows,\n    rowsById: rowModel.rowsById\n  };\n}\n\nfunction getPaginationRowModel(opts) {\n  return instance => memo(() => [instance.getState().pagination, instance.getPrePaginationRowModel()], (pagination, rowModel) => {\n    if (!rowModel.rows.length) {\n      return rowModel;\n    }\n\n    const {\n      pageSize,\n      pageIndex\n    } = pagination;\n    let {\n      rows,\n      flatRows,\n      rowsById\n    } = rowModel;\n    const pageStart = pageSize * pageIndex;\n    const pageEnd = pageStart + pageSize;\n    rows = rows.slice(pageStart, pageEnd);\n\n    if (!instance.options.paginateExpandedRows) {\n      return expandRows({\n        rows,\n        flatRows,\n        rowsById\n      });\n    }\n\n    return {\n      rows,\n      flatRows,\n      rowsById\n    };\n  }, {\n    key: process.env.NODE_ENV === 'development' && 'getPaginationRowModel',\n    debug: () => {\n      var _instance$options$deb;\n\n      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;\n    }\n  });\n}\n\nexport { ColumnSizing, Expanding, Filters, Grouping, Headers, Ordering, Pagination, Pinning, RowSelection, Sorting, Visibility, aggregationFns, buildHeaderGroups, createColumn, createRow, createTableFactory, createTableInstance, defaultColumnSizing, expandRows, filterFns, flattenBy, functionalUpdate, getCoreRowModel, getExpandedRowModel, getFacetedMinMaxValues, getFacetedRowModel, getFacetedUniqueValues, getFilteredRowModel, getGroupedRowModel, getPaginationRowModel, getSortedRowModel, isFunction, isRowSelected, makeStateUpdater, memo, noop, orderColumns, passiveEventSupported, reSplitAlphaNumeric, selectRowsFn, shouldAutoRemoveFilter, sortingFns };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\nexport * from '@tanstack/table-core'\n\nimport {\n  createTableInstance,\n  TableOptions,\n  TableInstance,\n  Table,\n  TableGenerics,\n  createTableFactory,\n  Overwrite,\n  PartialKeys,\n  TableOptionsResolved,\n} from '@tanstack/table-core'\n\nexport type Renderable<TProps> =\n  | React.ReactNode\n  | React.FunctionComponent<TProps>\n  | React.Component<TProps>\n\nexport type Render = <TProps extends {}>(\n  Comp: Renderable<TProps>,\n  props: TProps\n) => React.ReactNode | JSX.Element\n\nexport type ReactTableGenerics = Overwrite<\n  TableGenerics,\n  { Renderer: Render; Rendered: ReturnType<Render> }\n>\n\n//\n\nexport const render: Render = (Comp, props) =>\n  !Comp ? null : isReactComponent(Comp) ? <Comp {...props} /> : Comp\n\nfunction isReactComponent(component: unknown): component is React.FC {\n  return (\n    isClassComponent(component) ||\n    typeof component === 'function' ||\n    isExoticComponent(component)\n  )\n}\n\nfunction isClassComponent(component: any) {\n  return (\n    typeof component === 'function' &&\n    (() => {\n      const proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isExoticComponent(component: any) {\n  return (\n    typeof component === 'object' &&\n    typeof component.$$typeof === 'symbol' &&\n    ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description)\n  )\n}\n\nexport const createTable = createTableFactory({ render })\n\n// const useIsomorphicLayoutEffect =\n//   typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport type UseTableInstanceOptions<TGenerics extends ReactTableGenerics> =\n  TableOptions<TGenerics>\n\nexport function useTableInstance<TGenerics extends ReactTableGenerics>(\n  table: Table<TGenerics>,\n  options: UseTableInstanceOptions<TGenerics>\n): TableInstance<TGenerics> {\n  // Compose in the generic options to the user options\n  const resolvedOptions: TableOptionsResolved<TGenerics> = {\n    ...table.options,\n    state: {}, // Dummy state\n    onStateChange: () => {}, // noop\n    render,\n    ...options,\n  }\n\n  // Create a new table instance and store it in state\n  const [instanceRef] = React.useState(() => ({\n    current: createTableInstance<TGenerics>(resolvedOptions),\n  }))\n\n  // By default, manage table state here using the instance's initial state\n  const [state, setState] = React.useState(\n    () => instanceRef.current.initialState\n  )\n\n  // Compose the default state above with any user state. This will allow the user\n  // to only control a subset of the state if desired.\n  instanceRef.current.setOptions(prev => ({\n    ...prev,\n    ...options,\n    state: {\n      ...state,\n      ...options.state,\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: updater => {\n      setState(updater)\n      options.onStateChange?.(updater)\n    },\n  }))\n\n  return instanceRef.current\n}\n"],"names":["functionalUpdate","updater","input","makeStateUpdater","key","instance","setState","old","isFunction","d","Function","flattenBy","arr","getChildren","flat","recurse","subArr","forEach","item","push","children","length","memo","getDeps","fn","opts","result","deps","depTime","debug","Date","now","newDeps","some","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","createColumn","columnDef","depth","parent","_ref","_columnDef$id","defaultColumn","_getDefaultColumnDef","accessorFn","id","accessorKey","header","undefined","originalRow","Error","column","columnDefType","columns","getFlatColumns","_column$columns","flatMap","_instance$options$deb","options","debugAll","debugColumns","getLeafColumns","_getOrderColumnsFn","orderColumns","_column$columns2","leafColumns","_instance$options$deb2","_features","reduce","obj","feature","Object","assign","createHeader","_options$id","isPlaceholder","placeholderId","subHeaders","colSpan","rowSpan","headerGroup","getLeafHeaders","leafHeaders","recurseHeader","h","map","renderHeader","_render","renderFooter","footer","Headers","createInstance","getHeaderGroups","getAllColumns","getVisibleLeafColumns","getState","columnPinning","left","right","allColumns","_left$map$filter","_right$map$filter","leftColumns","columnId","find","filter","Boolean","rightColumns","buildHeaderGroups","includes","debugHeaders","getCenterHeaderGroups","getLeftHeaderGroups","_left$map$filter2","_instance$options$deb3","getRightHeaderGroups","_right$map$filter2","_instance$options$deb4","getFooterGroups","headerGroups","reverse","_instance$options$deb5","getLeftFooterGroups","_instance$options$deb6","getCenterFooterGroups","_instance$options$deb7","getRightFooterGroups","_instance$options$deb8","getFlatHeaders","headers","_instance$options$deb9","getLeftFlatHeaders","_instance$options$deb10","getCenterFlatHeaders","_instance$options$deb11","getRightFlatHeaders","_instance$options$deb12","getCenterLeafHeaders","flatHeaders","_header$subHeaders","_instance$options$deb13","getLeftLeafHeaders","_header$subHeaders2","_instance$options$deb14","getRightLeafHeaders","_header$subHeaders3","_instance$options$deb15","center","_left$0$headers","_left$","_center$0$headers","_center$","_right$0$headers","_right$","_instance$options$deb16","columnsToGroup","headerFamily","_headerGroups$0$heade","_headerGroups$","maxDepth","findMaxDepth","getIsVisible","createHeaderGroup","headersToGroup","join","pendingParentHeaders","headerToGroup","latestPendingParentHeader","bottomHeaders","recurseHeadersForSpans","childRowSpans","childColSpan","childRowSpan","defaultColumnSizing","size","minSize","maxSize","Number","MAX_SAFE_INTEGER","ColumnSizing","getDefaultColumnDef","getInitialState","state","columnSizing","columnSizingInfo","startOffset","startSize","deltaOffset","deltaPercentage","isResizingColumn","columnSizingStart","getDefaultOptions","columnResizeMode","onColumnSizingChange","onColumnSizingInfoChange","getSize","_column$columnDef$min","_column$columnDef$max","columnSize","getStart","position","getLeftVisibleLeafColumns","getRightVisibleLeafColumns","findIndex","prevSiblingColumn","resetSize","setColumnSizing","_ref2","_","rest","getCanResize","_column$columnDef$ena","_instance$options$ena","enableResizing","enableColumnResizing","getIsResizing","sum","_header$column$getSiz","prevSiblingHeader","getResizeHandler","getColumn","canResize","e","persist","isTouchStartEvent","touches","clientX","updateOffset","eventType","clientXPos","newColumnSizing","setColumnSizingInfo","_old$startOffset","_old$startSize","_ref3","headerSize","mouseEvents","moveHandler","onMove","upHandler","document","removeEventListener","passiveIfSupported","passiveEventSupported","passive","addEventListener","resetColumnSizing","defaultState","_instance$initialStat","initialState","resetHeaderSizeInfo","_instance$initialStat2","getTotalSize","_instance$getHeaderGr","_instance$getHeaderGr2","getLeftTotalSize","_instance$getLeftHead","_instance$getLeftHead2","getCenterTotalSize","_instance$getCenterHe","_instance$getCenterHe2","getRightTotalSize","_instance$getRightHea","_instance$getRightHea2","passiveSupported","supported","noop","window","err","type","Expanding","expanded","onExpandedChange","autoResetExpanded","paginateExpandedRows","registered","queued","_autoResetExpanded","autoResetAll","_queue","resetExpanded","setExpanded","toggleAllRowsExpanded","getIsAllRowsExpanded","getCanSomeRowsExpand","getRowModel","flatRows","row","getCanExpand","getToggleAllRowsExpandedHandler","getIsSomeRowsExpanded","values","getIsExpanded","getExpandedDepth","keys","rowsById","splitId","split","getPreExpandedRowModel","getGroupedRowModel","getExpandedRowModel","_getExpandedRowModel","manualExpanding","createRow","toggleExpanded","_expanded","exists","oldExpanded","rowId","_instance$options$get","getIsRowExpanded","_instance$options$get2","_row$subRows","getRowCanExpand","enableExpanding","subRows","getToggleExpandedHandler","canExpand","includesString","filterValue","search","toLowerCase","getValue","autoRemove","val","testFalsey","includesStringSensitive","equalsString","arrIncludes","arrIncludesAll","arrIncludesSome","equals","weakEquals","inNumberRange","rowValue","resolveFilterValue","unsafeMin","unsafeMax","parsedMin","parseFloat","parsedMax","isNaN","Infinity","temp","filterFns","Filters","filterFn","columnFilters","globalFilter","onColumnFiltersChange","onGlobalFilterChange","filterFromLeafRows","globalFilterFn","getColumnCanGlobalFilter","_instance$getCoreRowM","_instance$getCoreRowM2","getCoreRowModel","_getAllCellsByColumnId","getAutoFilterFn","firstRow","value","Array","isArray","getFilterFn","userFilterFns","getCanFilter","_instance$options$ena2","enableColumnFilter","enableColumnFilters","enableFilters","getCanGlobalFilter","_column$columnDef$ena2","_instance$options$ena3","_instance$options$ena4","enableGlobalFilter","getIsFiltered","getFilterIndex","getFilterValue","_instance$getState$co","_instance$getState$co2","_instance$getState$co3","_instance$getState$co4","setFilterValue","setColumnFilters","previousfilter","newFilter","_old$filter","shouldAutoRemoveFilter","newFilterObj","_old$map","_getFacetedRowModel","getFacetedRowModel","getPreFilteredRowModel","_getFacetedUniqueValues","getFacetedUniqueValues","Map","_getFacetedMinMaxValues","getFacetedMinMaxValues","columnFiltersMeta","getGlobalAutoFilterFn","getGlobalFilterFn","getAllLeafColumns","_functionalUpdate","setGlobalFilter","resetGlobalFilter","resetColumnFilters","_getFilteredRowModel","getFilteredRowModel","manualFiltering","_getGlobalFacetedRowModel","getGlobalFacetedRowModel","_getGlobalFacetedUniqueValues","getGlobalFacetedUniqueValues","_getGlobalFacetedMinMaxValues","getGlobalFacetedMinMaxValues","aggregationFns","_leafRows","childRows","next","extent","mean","leafRows","count","median","unique","from","Set","uniqueCount","_columnId","Grouping","aggregationFn","grouping","onGroupingChange","groupedColumnMode","toggleGrouping","setGrouping","getCanGroup","enableGrouping","getIsGrouped","_instance$getState$gr","getGroupedIndex","_instance$getState$gr2","indexOf","getToggleGroupingHandler","canGroup","getAutoAggregationFn","prototype","toString","call","getAggregationFn","_ref4","userAggregationFns","resetGrouping","getPreGroupedRowModel","getSortedRowModel","_getGroupedRowModel","manualGrouping","groupingColumnId","_groupingValuesCache","createCell","cell","getIsPlaceholder","getIsAggregated","renderAggregatedCell","_column$columnDef$agg","template","aggregatedCell","nonGroupingColumns","col","g","Ordering","columnOrder","onColumnOrderChange","setColumnOrder","resetColumnOrder","orderedColumns","columnOrderCopy","columnsCopy","targetColumnId","shift","foundIndex","splice","Pagination","pagination","pageIndex","pageSize","onPaginationChange","_autoResetPageIndex","_instance$options$aut","autoResetPageIndex","manualPagination","resetPageIndex","setPagination","resetPagination","setPageIndex","maxPageIndex","pageCount","_instance$initialStat3","_instance$initialStat4","resetPageSize","_instance$initialStat5","_instance$initialStat6","_instance$initialStat7","setPageSize","topRowIndex","floor","setPageCount","_old$pageCount","newPageCount","getPageOptions","pageOptions","fill","i","debugTable","getCanPreviousPage","getCanNextPage","getPageCount","previousPage","nextPage","getPrePaginationRowModel","getPaginationRowModel","_getPaginationRowModel","ceil","rows","Pinning","onColumnPinningChange","pin","columnIds","setColumnPinning","_old$left3","_old$right3","_old$left","_old$right","_old$left2","_old$right2","getCanPin","_d$columnDef$enablePi","enablePinning","getIsPinned","leafColumnIds","isLeft","isRight","getPinnedIndex","getCenterVisibleCells","_getAllVisibleCells","allCells","leftAndRight","debugRows","getLeftVisibleCells","getRightVisibleCells","resetColumnPinning","getIsSomeColumnsPinned","_pinningState$positio","pinningState","_pinningState$left","_pinningState$right","getLeftLeafColumns","getRightLeafColumns","getCenterLeafColumns","RowSelection","rowSelection","onRowSelectionChange","enableRowSelection","enableMultiRowSelection","enableSubRowSelection","setRowSelection","resetRowSelection","toggleAllRowsSelected","getIsAllRowsSelected","preGroupedFlatRows","toggleAllPageRowsSelected","getIsAllPageRowsSelected","mutateRowIsSelected","getPreSelectedRowModel","getSelectedRowModel","rowModel","selectRowsFn","getFilteredSelectedRowModel","getGroupedSelectedRowModel","preFilteredFlatRows","isAllRowsSelected","paginationFlatRows","isAllPageRowsSelected","getIsSomeRowsSelected","_instance$getState$ro","getIsSomePageRowsSelected","getToggleAllRowsSelectedHandler","target","checked","getToggleAllPageRowsSelectedHandler","toggleSelected","isSelected","getIsSelected","selectedRowIds","isRowSelected","getIsSomeSelected","getCanSelect","getCanSelectSubRows","getCanMultiSelect","getToggleSelectedHandler","canSelect","_target","getRow","newSelectedFlatRows","newSelectedRowsById","recurseRows","_row$subRows2","selection","allChildrenSelected","someSelected","subRow","reSplitAlphaNumeric","compareBasic","a","b","compareAlphanumeric","aStr","bStr","aa","bb","an","parseInt","bn","combo","sort","sortingFns","alphanumeric","rowA","rowB","alphanumericCaseSensitive","text","textCaseSensitive","datetime","getTime","basic","Sorting","sorting","sortingFn","onSortingChange","isMultiSortEvent","shiftKey","getAutoSortingFn","firstRows","slice","isString","getAutoSortDir","getSortingFn","userSortingFn","toggleSorting","desc","multi","setSorting","_column$columnDef$sor","existingSorting","existingIndex","hasDescDefined","sortAction","newSorting","getCanMultiSort","sortDescFirst","enableSortingRemoval","enableMultiRemove","_instance$options$max","maxMultiSortColCount","getCanSort","enableSorting","enableMultiSort","getIsSorted","_instance$getState$so","columnSort","getSortIndex","_instance$getState$so2","_instance$getState$so3","clearSorting","getToggleSortingHandler","canSort","resetSorting","getPreSortedRowModel","_getSortedRowModel","manualSorting","Visibility","columnVisibility","onColumnVisibilityChange","toggleVisibility","getCanHide","setColumnVisibility","enableHiding","getToggleVisibilityHandler","getAllCells","getVisibleCells","makeVisibleColumnsMethod","getColumns","getVisibleFlatColumns","getAllFlatColumns","getCenterVisibleLeafColumns","resetColumnVisibility","toggleAllColumnsVisible","_value","getIsAllColumnsVisible","getIsSomeColumnsVisible","getToggleAllColumnsVisibilityHandler","features","createTableInstance","_options$initialState","defaultOptions","_feature$getInitialSt","queuedTimeout","coreInstance","cb","Promise","resolve","then","catch","error","setTimeout","reset","setOptions","newOptions","mergeOptions","props","render","onStateChange","_getRowId","getRowId","_getCoreRowModel","_defaultColumn","_props$getValue$toStr","_props$getValue$toStr2","_props$getValue","_getColumnDefs","columnDefs","recurseColumns","_getAllFlatColumnsById","flatColumns","acc","createTableFactory","createTable","__","table","generics","setRowType","setTableMetaType","setColumnMetaType","setFilterMetaType","createDisplayColumn","createGroup","createDataColumn","accessor","_column$id","createOptions","original","rowIndex","_valuesCache","hasOwnProperty","getLeafRows","renderCell","filterRows","filterRowImpl","rowsToFilter","filterRow","newFilteredFlatRows","newFilteredRowsById","newRow","recurseFilterRows","filterRowModelFromLeafs","filterRowModelFromRoot","expandRows","expandedRows","handleRow","Comp","component","proto","getPrototypeOf","isReactComponent","isClassComponent","$$typeof","description","isExoticComponent","React","createElement","data","accessRows","originalRows","_row$originalSubRows","getSubRows","originalSubRows","facetedRowModel","_facetedRowModel$flat","firstValue","facetedMinMaxValues","_facetedRowModel$flat2","preRowModel","filterableIds","facetedUniqueValues","_facetedUniqueValues$","has","set","get","resolvedColumnFilters","resolvedGlobalFilters","_filterFn$resolveFilt","resolvedValue","globallyFilterableColumns","currentColumnFilter","currentGlobalFilter","_globalFilterFn$resol","j","filterMeta","__global__","existingGrouping","groupedFlatRows","groupedRowsById","groupUpRecursively","parentId","rowGroupsMap","groupMap","resKey","previous","groupBy","aggregatedGroupedRows","entries","groupingValue","groupedRows","_groupedRows$0$getVal","aggregateFn","pageStart","pageEnd","sortingState","sortedFlatRows","availableSorting","columnInfoById","sortEntry","sortUndefined","invertSorting","sortData","sortedData","_sortEntry$desc","columnInfo","isDesc","aUndefined","bUndefined","sortInt","resolvedOptions","instanceRef","useState","current","prev"],"mappings":"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"}