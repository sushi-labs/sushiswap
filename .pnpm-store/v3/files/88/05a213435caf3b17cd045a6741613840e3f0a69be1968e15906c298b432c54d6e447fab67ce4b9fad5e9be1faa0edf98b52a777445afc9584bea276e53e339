{"version":3,"names":["anyTypeAnnotation","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isFlowBaseAnnotation","isGenericTypeAnnotation","isIdentifier","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isTSArrayType","isTSTypeAnnotation","isTSTypeReference","isTupleTypeAnnotation","isTypeAnnotation","isUnionTypeAnnotation","isVoidTypeAnnotation","stringTypeAnnotation","voidTypeAnnotation","getTypeAnnotation","type","getData","_getTypeAnnotation","typeAnnotation","setData","typeAnnotationInferringNodes","WeakSet","node","key","parentPath","isVariableDeclarator","declar","declarParent","isForInStatement","isForOfStatement","has","add","inferer","inferers","call","validParent","delete","isBaseType","baseName","soft","_isBaseType","Error","couldBeBaseType","name","type2","types","baseTypeStrictlyMatches","rightArg","left","right","isGenericType","genericName","id","typeName"],"sources":["../../../src/path/inference/index.ts"],"sourcesContent":["import type NodePath from \"../index\";\nimport * as inferers from \"./inferers\";\nimport {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nexport function getTypeAnnotation(this: NodePath): t.FlowType | t.TSType {\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) {\n    return type;\n  }\n  type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\n\n// Used to avoid infinite recursion in cases like\n//   var b, c; if (0) { c = 1; b = c; } c = b;\n// It also works with indirect recursion.\nconst typeAnnotationInferringNodes = new WeakSet();\n\n/**\n * todo: split up this method\n */\n\nexport function _getTypeAnnotation(this: NodePath): any {\n  const node = this.node;\n\n  if (!node) {\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      // for (let NODE in bar) {}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      // for (let NODE of bar) {}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  // @ts-expect-error typeAnnotation may not index node\n  if (node.typeAnnotation) {\n    // @ts-expect-error typeAnnotation may not index node\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    // Bail out from type inference to avoid infinite loops\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    let inferer =\n      // @ts-expect-error inferers do not cover all AST types\n      inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    // @ts-expect-error inferers do not cover all AST types\n    inferer = inferers[this.parentPath.type];\n    if (inferer?.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nexport function isBaseType(\n  this: NodePath,\n  baseName: string,\n  soft?: boolean,\n): boolean {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(\n  baseName: string,\n  type?: t.FlowType | t.TSType,\n  soft?: boolean,\n): boolean {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nexport function couldBeBaseType(this: NodePath, name: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nexport function baseTypeStrictlyMatches(\n  this: NodePath,\n  rightArg: NodePath,\n): boolean {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\n\nexport function isGenericType(this: NodePath, genericName: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") {\n    // T[]\n    if (\n      isTSArrayType(type) ||\n      isArrayTypeAnnotation(type) ||\n      isTupleTypeAnnotation(type)\n    ) {\n      return true;\n    }\n  }\n  return (\n    (isGenericTypeAnnotation(type) &&\n      isIdentifier(type.id, {\n        name: genericName,\n      })) ||\n    (isTSTypeReference(type) &&\n      isIdentifier(type.typeName, {\n        name: genericName,\n      }))\n  );\n}\n"],"mappings":"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"}