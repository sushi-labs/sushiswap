"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixConfigDev = exports.onDevRequest = exports.rawBody = void 0;
const entrypoint = process.env.VERCEL_DEV_ENTRYPOINT;
delete process.env.VERCEL_DEV_ENTRYPOINT;
const tsconfig = process.env.VERCEL_DEV_TSCONFIG;
delete process.env.VERCEL_DEV_TSCONFIG;
if (!entrypoint) {
    throw new Error('`VERCEL_DEV_ENTRYPOINT` must be defined');
}
const path_1 = require("path");
const ts_node_1 = require("ts-node");
const typescript_1 = require("./typescript");
let useRequire = false;
if (!process.env.VERCEL_DEV_IS_ESM) {
    const resolveTypescript = (p) => {
        try {
            return require.resolve('typescript', {
                paths: [p],
            });
        }
        catch (_) {
            return '';
        }
    };
    const requireTypescript = (p) => {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        return require(p);
    };
    let ts = null;
    // Use the project's version of Typescript if available and supports `target`
    let compiler = resolveTypescript(process.cwd());
    if (compiler) {
        ts = requireTypescript(compiler);
    }
    // Otherwise fall back to using the copy that `@vercel/node` uses
    if (!ts) {
        compiler = resolveTypescript(path_1.join(__dirname, '..'));
        ts = requireTypescript(compiler);
    }
    let config = {};
    if (tsconfig) {
        try {
            config = ts.readConfigFile(tsconfig, ts.sys.readFile).config;
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                console.error(`Error while parsing "${tsconfig}"`);
                throw err;
            }
        }
    }
    fixConfigDev(config);
    ts_node_1.register({
        compiler,
        compilerOptions: config.compilerOptions,
        transpileOnly: true,
    });
    useRequire = true;
}
const http_1 = require("http");
const launcher_js_1 = require("@vercel/node-bridge/launcher.js");
const build_utils_1 = require("@vercel/build-utils");
const exit_hook_1 = __importDefault(require("exit-hook"));
const edge_runtime_1 = require("edge-runtime");
const static_config_1 = require("@vercel/static-config");
const ts_morph_1 = require("ts-morph");
const esbuild_1 = __importDefault(require("esbuild"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const edge_wasm_plugin_1 = require("./edge-wasm-plugin");
function logError(error) {
    console.error(error.message);
    if (error.stack) {
        // only show the stack trace if debug is enabled
        // because it points to internals, not user code
        const errorPrefixLength = 'Error: '.length;
        const errorMessageLength = errorPrefixLength + error.message.length;
        build_utils_1.debug(error.stack.substring(errorMessageLength + 1));
    }
}
function listen(server, port, host) {
    return new Promise(resolve => {
        server.listen(port, host, () => {
            resolve();
        });
    });
}
async function createServerlessEventHandler(entrypoint, options) {
    const launcher = launcher_js_1.getVercelLauncher({
        entrypointPath: entrypoint,
        helpersPath: './helpers.js',
        shouldAddHelpers: options.shouldAddHelpers,
        useRequire,
        // not used
        bridgePath: '',
        sourcemapSupportPath: '',
    });
    const bridge = launcher();
    return async function (request) {
        const body = await rawBody(request);
        const event = {
            Action: 'Invoke',
            body: JSON.stringify({
                method: request.method,
                path: request.url,
                headers: request.headers,
                encoding: 'base64',
                body: body.toString('base64'),
            }),
        };
        return bridge.launcher(event, {
            callbackWaitsForEmptyEventLoop: false,
        });
    };
}
async function serializeRequest(message) {
    const bodyBuffer = await build_utils_1.streamToBuffer(message);
    const body = bodyBuffer.toString('base64');
    return JSON.stringify({
        url: message.url,
        method: message.method,
        headers: message.headers,
        body,
    });
}
async function compileUserCode(entrypointPath, entrypointLabel) {
    const { wasmAssets, plugin: edgeWasmPlugin } = edge_wasm_plugin_1.createEdgeWasmPlugin();
    try {
        const result = await esbuild_1.default.build({
            platform: 'node',
            target: 'node14',
            sourcemap: 'inline',
            bundle: true,
            plugins: [edgeWasmPlugin],
            entryPoints: [entrypointPath],
            write: false,
            format: 'cjs',
        });
        const compiledFile = result.outputFiles?.[0];
        if (!compiledFile) {
            throw new Error(`Compilation of ${entrypointLabel} produced no output files.`);
        }
        const userCode = `
      ${compiledFile.text};

      addEventListener('fetch', async (event) => {
        try {
          let serializedRequest = await event.request.text();
          let requestDetails = JSON.parse(serializedRequest);

          let body;

          if (requestDetails.method !== 'GET' && requestDetails.method !== 'HEAD') {
            body = Uint8Array.from(atob(requestDetails.body), c => c.charCodeAt(0));
          }

          let requestUrl = requestDetails.headers['x-forwarded-proto'] + '://' + requestDetails.headers['x-forwarded-host'] + requestDetails.url;

          let request = new Request(requestUrl, {
            headers: requestDetails.headers,
            method: requestDetails.method,
            body: body
          });

          event.request = request;

          let edgeHandler = module.exports.default;
          if (!edgeHandler) {
            throw new Error('No default export was found. Add a default export to handle requests. Learn more: https://vercel.link/creating-edge-middleware');
          }

          let response = await edgeHandler(event.request, event);

          if (!response) {
            throw new Error('Edge Function "${entrypointLabel}" did not return a response.');
          }

          return event.respondWith(response);
        } catch (error) {
          // we can't easily show a meaningful stack trace
          // so, stick to just the error message for now
          event.respondWith(new Response(error.message, {
            status: 500,
            headers: {
              'x-vercel-failed': 'edge-wrapper'
            }
          }));
        }
      })`;
        return { userCode, wasmAssets };
    }
    catch (error) {
        // We can't easily show a meaningful stack trace from ncc -> edge-runtime.
        // So, stick with just the message for now.
        console.error(`Failed to instantiate edge runtime.`);
        logError(error);
        return undefined;
    }
}
async function createEdgeRuntime(params) {
    try {
        if (!params) {
            return undefined;
        }
        const wasmBindings = await params.wasmAssets.getContext();
        const edgeRuntime = new edge_runtime_1.EdgeRuntime({
            initialCode: params.userCode,
            extend: (context) => {
                Object.assign(context, {
                    __dirname: '',
                    module: {
                        exports: {},
                    },
                    process: {
                        env: process.env,
                    },
                }, wasmBindings);
                return context;
            },
        });
        const server = await edge_runtime_1.runServer({ runtime: edgeRuntime });
        exit_hook_1.default(server.close);
        return server;
    }
    catch (error) {
        // We can't easily show a meaningful stack trace from ncc -> edge-runtime.
        // So, stick with just the message for now.
        console.error('Failed to instantiate edge runtime.');
        logError(error);
        return undefined;
    }
}
async function createEdgeEventHandler(entrypointPath, entrypointLabel) {
    const userCode = await compileUserCode(entrypointPath, entrypointLabel);
    const server = await createEdgeRuntime(userCode);
    return async function (request) {
        if (!server) {
            // this error state is already logged, but we have to wait until here to exit the process
            // this matches the serverless function bridge launcher's behavior when
            // an error is thrown in the function
            process.exit(1);
        }
        const response = await node_fetch_1.default(server.url, {
            redirect: 'manual',
            method: 'post',
            body: await serializeRequest(request),
        });
        const body = await response.text();
        const isUserError = response.headers.get('x-vercel-failed') === 'edge-wrapper';
        if (isUserError && response.status >= 500) {
            // this error was "unhandled" from the user code's perspective
            console.log(`Unhandled rejection: ${body}`);
            // this matches the serverless function bridge launcher's behavior when
            // an error is thrown in the function
            process.exit(1);
        }
        return {
            statusCode: response.status,
            headers: response.headers.raw(),
            body,
            encoding: 'utf8',
        };
    };
}
const validRuntimes = ['experimental-edge'];
function parseRuntime(entrypoint, entryPointPath) {
    const project = new ts_morph_1.Project();
    const staticConfig = static_config_1.getConfig(project, entryPointPath);
    const runtime = staticConfig?.runtime;
    if (runtime && !validRuntimes.includes(runtime)) {
        throw new Error(`Invalid function runtime "${runtime}" for "${entrypoint}". Valid runtimes are: ${JSON.stringify(validRuntimes)}. Learn more: https://vercel.link/creating-edge-functions`);
    }
    return runtime;
}
async function createEventHandler(entrypoint, config, options) {
    const entrypointPath = path_1.join(process.cwd(), entrypoint);
    const runtime = parseRuntime(entrypoint, entrypointPath);
    // `middleware.js`/`middleware.ts` file is always run as
    // an Edge Function, otherwise needs to be opted-in via
    // `export const config = { runtime: 'experimental-edge' }`
    if (config.middleware === true || runtime === 'experimental-edge') {
        return createEdgeEventHandler(entrypointPath, entrypoint);
    }
    return createServerlessEventHandler(entrypointPath, options);
}
let handleEvent;
let handlerEventError;
async function main() {
    const config = JSON.parse(process.env.VERCEL_DEV_CONFIG || '{}');
    delete process.env.VERCEL_DEV_CONFIG;
    const buildEnv = JSON.parse(process.env.VERCEL_DEV_BUILD_ENV || '{}');
    delete process.env.VERCEL_DEV_BUILD_ENV;
    const shouldAddHelpers = !(config.helpers === false || buildEnv.NODEJS_HELPERS === '0');
    const proxyServer = http_1.createServer(onDevRequest);
    await listen(proxyServer, 0, '127.0.0.1');
    try {
        handleEvent = await createEventHandler(entrypoint, config, {
            shouldAddHelpers,
        });
    }
    catch (error) {
        logError(error);
        handlerEventError = error;
    }
    const address = proxyServer.address();
    if (typeof process.send === 'function') {
        process.send(address);
    }
    else {
        console.log('Dev server listening:', address);
    }
}
function rawBody(readable) {
    return new Promise((resolve, reject) => {
        let bytes = 0;
        const chunks = [];
        readable.on('error', reject);
        readable.on('data', chunk => {
            chunks.push(chunk);
            bytes += chunk.length;
        });
        readable.on('end', () => {
            resolve(Buffer.concat(chunks, bytes));
        });
    });
}
exports.rawBody = rawBody;
async function onDevRequest(req, res) {
    if (handlerEventError) {
        // this error state is already logged, but we have to wait until here to exit the process
        // this matches the serverless function bridge launcher's behavior when
        // an error is thrown in the function
        process.exit(1);
    }
    if (!handleEvent) {
        res.statusCode = 500;
        res.end('Bridge is not ready, please try again');
        return;
    }
    try {
        const result = await handleEvent(req);
        res.statusCode = result.statusCode;
        for (const [key, value] of Object.entries(result.headers)) {
            if (typeof value !== 'undefined') {
                res.setHeader(key, value);
            }
        }
        res.end(Buffer.from(result.body, result.encoding));
    }
    catch (error) {
        res.statusCode = 500;
        res.end(error.stack);
    }
}
exports.onDevRequest = onDevRequest;
function fixConfigDev(config) {
    const nodeVersionMajor = Number(process.versions.node.split('.')[0]);
    typescript_1.fixConfig(config, nodeVersionMajor);
    // In prod, `.ts` inputs use TypeScript and
    // `.js` inputs use Babel to convert ESM to CJS.
    // In dev, both `.ts` and `.js` inputs use ts-node
    // without Babel so we must enable `allowJs`.
    config.compilerOptions.allowJs = true;
    // In prod, we emit outputs to the filesystem.
    // In dev, we don't emit because we use ts-node.
    config.compilerOptions.noEmit = true;
}
exports.fixConfigDev = fixConfigDev;
main().catch(err => {
    logError(err);
    process.exit(1);
});
