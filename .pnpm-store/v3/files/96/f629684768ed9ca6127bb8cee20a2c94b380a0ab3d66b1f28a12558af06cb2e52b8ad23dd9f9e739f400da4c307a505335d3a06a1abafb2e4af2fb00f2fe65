{"version":3,"file":"vm.js","sourceRoot":"","sources":["../src/vm.ts"],"names":[],"mappings":";;;AAEA,2BAAgD;AAChD,uCAAyC;AACzC,2CAAsC;AAoBtC;;;;GAIG;AACH,MAAa,EAAE;IAKb,YAAY,UAAwB,EAAE;;QACpC,MAAM,OAAO,GAAG,IAAA,kBAAa,EAC3B,EAAE,EACF;YACE,IAAI,EAAE,cAAc;YACpB,cAAc,EAAE,MAAA,OAAO,CAAC,cAAc,mCAAI;gBACxC,OAAO,EAAE,KAAK;gBACd,IAAI,EAAE,KAAK;aACZ;SACF,CACuB,CAAA;QAE1B,IAAI,CAAC,YAAY,GAAG,MAAA,OAAO,CAAC,YAAY,mCAAI,IAAI,GAAG,EAAE,CAAA;QACrD,IAAI,CAAC,OAAO,GAAG,MAAA,MAAA,OAAO,CAAC,MAAM,wDAAG,OAAO,CAAC,mCAAI,OAAO,CAAA;QACnD,IAAI,CAAC,SAAS,GAAG,IAAA,uBAAa,EAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,CAAC,CAAA;IACjE,CAAC;IAED;;OAEG;IACH,QAAQ,CAAU,IAAY;QAC5B,OAAO,IAAA,iBAAY,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAA;IACzC,CAAC;IAED;;;OAGG;IACH,OAAO,CAA6B,QAAgB;QAClD,OAAO,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAA;IAC3C,CAAC;IAED;;;;OAIG;IACH,gBAAgB,CAA6B,QAAgB;QAC3D,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAI,QAAQ,CAAC,CAAA;QAC9C,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;YACvD,IAAI,CAAC,OAAO,CAAC,GAAgC,CAAC,GAAG,KAAK,CAAA;SACvD;IACH,CAAC;IAED;;;;OAIG;IACH,sBAAsB,CAAC,IAAY;QACjC,MAAM,IAAI,GAAG,IAAA,oBAAQ,EAAC,IAAI,CAAC,CAAA;QAC3B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QAChC,IAAI,CAAC,MAAM,EAAE,CAAA;IACf,CAAC;CACF;AA3DD,gBA2DC","sourcesContent":["import type { Context as VMContext, CreateContextOptions } from 'vm'\nimport type { Dictionary, ExtendedDictionary } from './types'\nimport { createContext, runInContext } from 'vm'\nimport { createRequire } from './require'\nimport { tempFile } from './temp-file'\n\nexport interface VMOptions<T> {\n  /**\n   * Provide code generation options to the Node.js VM.\n   * If you don't provide any option, code generation will be disabled.\n   */\n  codeGeneration?: CreateContextOptions['codeGeneration']\n  /**\n   * Allows to extend the VMContext. Note that it must return a contextified\n   * object so ideally it should return the same reference it receives.\n   */\n  extend?: (context: VMContext) => ExtendedDictionary<T>\n  /**\n   * Provides an initial map to the require cache.\n   * If none is given, it will be initialized to an empty map.\n   */\n  requireCache?: Map<string, Dictionary>\n}\n\n/**\n * A raw VM with a context that can be extended on instantiation. Implements\n * a realm-like interface where one can evaluate code or require CommonJS\n * modules in multiple ways.\n */\nexport class VM<T extends Dictionary> {\n  private readonly requireFn: (referrer: string, specifier: string) => any\n  public readonly requireCache: Map<string, Dictionary>\n  public readonly context: ExtendedDictionary<T>\n\n  constructor(options: VMOptions<T> = {}) {\n    const context = createContext(\n      {},\n      {\n        name: 'Edge Runtime',\n        codeGeneration: options.codeGeneration ?? {\n          strings: false,\n          wasm: false,\n        },\n      }\n    ) as ExtendedDictionary<T>\n\n    this.requireCache = options.requireCache ?? new Map()\n    this.context = options.extend?.(context) ?? context\n    this.requireFn = createRequire(this.context, this.requireCache)\n  }\n\n  /**\n   * Allows to run arbitrary code within the VM.\n   */\n  evaluate<T = any>(code: string): T {\n    return runInContext(code, this.context)\n  }\n\n  /**\n   * Allows to require a CommonJS module referenced in the provided file\n   * path within the VM context. It will return its exports.\n   */\n  require<T extends Dictionary = any>(filepath: string): T {\n    return this.requireFn(filepath, filepath)\n  }\n\n  /**\n   * Same as `require` but it will copy each of the exports in the context\n   * of the vm. Then exports can be used inside of the vm with an\n   * evaluated script.\n   */\n  requireInContext<T extends Dictionary = any>(filepath: string): void {\n    const moduleLoaded = this.require<T>(filepath)\n    for (const [key, value] of Object.entries(moduleLoaded)) {\n      this.context[key as keyof typeof this.context] = value\n    }\n  }\n\n  /**\n   * Same as `requireInContext` but allows to pass the code instead of a\n   * reference to a file. It will create a temporary file and then load\n   * it in the VM Context.\n   */\n  requireInlineInContext(code: string): void {\n    const file = tempFile(code)\n    this.requireInContext(file.path)\n    file.remove()\n  }\n}\n"]}