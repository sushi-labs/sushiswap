{"version":3,"file":"create-handler.js","sourceRoot":"","sources":["../../src/server/create-handler.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EdgeRuntime } from '../edge-runtime'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { Logger, NodeHeaders } from '../types'\nimport type { Primitives } from '@edge-runtime/vm'\nimport { getClonableBodyStream } from './body-streams'\nimport prettyMs from 'pretty-ms'\nimport status from 'http-status'\nimport timeSpan from 'time-span'\n\nexport interface Options<T extends Primitives> {\n  /**\n   * A logger interface. If none is provided there will be no logs.\n   */\n  logger?: Logger\n  /**\n   * The runtime where the FetchEvent will be triggered whenever the server\n   * receives a request.\n   */\n  runtime: EdgeRuntime<T>\n}\n\n/**\n * Creates an HHTP handler that can be used to create a Node.js HTTP server.\n * Whenever a request is handled it will transform it into a `dispatchFetch`\n * call for the given `EdgeRuntime`. Then it will transform the response\n * into an HTTP response.\n */\nexport function createHandler<T extends Primitives>(options: Options<T>) {\n  const awaiting: Set<Promise<unknown>> = new Set()\n\n  return {\n    handler: async (req: IncomingMessage, res: ServerResponse) => {\n      const start = timeSpan()\n\n      const body =\n        req.method !== 'GET' && req.method !== 'HEAD'\n          ? getClonableBodyStream(req, options.runtime.context.TransformStream)\n          : undefined\n\n      const response = await options.runtime.dispatchFetch(\n        String(getURL(req)),\n        {\n          headers: toRequestInitHeaders(req),\n          method: req.method,\n          body: body?.cloneBodyStream(),\n        }\n      )\n\n      const waitUntil = response.waitUntil()\n      awaiting.add(waitUntil)\n      waitUntil.finally(() => awaiting.delete(waitUntil))\n\n      res.statusCode = response.status\n      res.statusMessage = response.statusText\n\n      for (const [key, value] of Object.entries(\n        toNodeHeaders(response.headers)\n      )) {\n        if (key !== 'content-encoding' && value !== undefined) {\n          res.setHeader(key, value)\n        }\n      }\n\n      if (response.body) {\n        for await (const chunk of response.body as any) {\n          res.write(chunk)\n        }\n      }\n\n      const subject = `${req.socket.remoteAddress} ${req.method} ${req.url}`\n      const time = `${prettyMs(start())\n        .match(/[a-zA-Z]+|[0-9]+/g)\n        ?.join(' ')}`\n\n      const code = `${res.statusCode} ${status[res.statusCode]}`\n      options.logger?.debug(`${subject} â†’ ${code} in ${time}`)\n      res.end()\n    },\n\n    waitUntil: () => Promise.all(Array.from(awaiting)),\n  }\n}\n\n/**\n * Builds a full URL from the provided incoming message. Note this function\n * is not safe as one can set has a host anything based on headers. It is\n * useful to build the fetch request full URL.\n */\nfunction getURL(req: IncomingMessage) {\n  const proto = (req.socket as any)?.encrypted ? 'https' : 'http'\n  return new URL(String(req.url), `${proto}://${String(req.headers.host)}`)\n}\n\n/**\n * Takes headers from IncomingMessage and transforms them into the signature\n * accepted by fetch. It simply folds headers into a single value when they\n * hold an array. For others it just copies the value.\n */\nfunction toRequestInitHeaders(req: IncomingMessage): RequestInit['headers'] {\n  return Object.keys(req.headers).map((key) => {\n    const value = req.headers[key]\n    return [key, Array.isArray(value) ? value.join(', ') : value ?? '']\n  })\n}\n\n/**\n * Transforms WHATWG Headers into a Node Headers shape. Copies all items but\n * does a special case for Set-Cookie using the hidden method getAll which\n * allows to get all cookies instead of a folded value.\n */\nfunction toNodeHeaders(headers?: Headers): NodeHeaders {\n  const result: NodeHeaders = {}\n  if (headers) {\n    for (const [key, value] of headers.entries()) {\n      result[key] =\n        key.toLowerCase() === 'set-cookie'\n          ? // @ts-ignore getAll is hidden in Headers but exists.\n            headers.getAll('set-cookie')\n          : value\n    }\n  }\n  return result\n}\n"]}