'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

// Generated by CoffeeScript 2.6.0
var _snake_case; exports.clone = void 0; exports.compare = void 0; exports.is_object = void 0; exports.is_object_literal = void 0; exports.merge = void 0; exports.mutate = void 0; exports.snake_case = void 0;

exports.merge = function merge() {
  return exports.mutate.apply(void 0, [{}].concat(Array.prototype.slice.call(arguments)));
};

exports.clone = function clone(target) {
  if (Array.isArray(target)) {
    return target.map(function (element) {
      return exports.clone(element);
    });
  } else if (target && _typeof(target) === 'object') {
    return exports.mutate({}, target);
  } else {
    return target;
  }
};

exports.mutate = function mutate() {
  var i, j, name, ref, source, target, v;
  target = arguments[0];

  for (i = j = 1, ref = arguments.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
    source = arguments[i];

    if (exports.is_object_literal(source)) {
      if (!exports.is_object_literal(target)) {
        target = {};
      }

      for (name in source) {
        if (/__proto__|prototype/.test(name)) {
          // See
          // https://github.com/adaltas/node-mixme/issues/1
          // https://github.com/adaltas/node-mixme/issues/2
          // continue if /__proto__|constructor|prototype|eval|function|\*|\+|;|\s|\(|\)|!/.test name
          // Unless proven wrong, I consider ok to copy any properties named eval
          // or function, we are not executing those, only copying.
          continue;
        }

        target[name] = exports.mutate(target[name], source[name]);
      }
    } else if (Array.isArray(source)) {
      target = function () {
        var k, len, results;
        results = [];

        for (k = 0, len = source.length; k < len; k++) {
          v = source[k];
          results.push(exports.mutate(void 0, v));
        }

        return results;
      }();
    } else if (source !== void 0) {
      target = source;
    }
  }

  return target;
};

exports.snake_case = function snake_case(source) {
  var convert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var name, src, target, u;
  target = {};

  if (exports.is_object_literal(source)) {
    u = typeof convert === 'number' && convert > 0 ? convert - 1 : convert;

    for (name in source) {
      src = source[name];

      if (convert) {
        name = _snake_case(name);
      }

      target[name] = exports.snake_case(src, u);
    }
  } else {
    target = source;
  }

  return target;
};

exports.compare = function compare(el1, el2) {
  var i, j, k, key, keys1, keys2, len, ref;

  if (exports.is_object_literal(el1)) {
    if (!exports.is_object_literal(el2)) {
      return false;
    }

    keys1 = Object.keys(el1).sort();
    keys2 = Object.keys(el2).sort();

    if (keys1.length !== keys2.length) {
      return false;
    }

    for (i = j = 0, len = keys1.length; j < len; i = ++j) {
      key = keys1[i];

      if (key !== keys2[i]) {
        return false;
      }

      if (!exports.compare(el1[key], el2[key])) {
        return false;
      }
    }
  } else if (Array.isArray(el1)) {
    if (!Array.isArray(el2)) {
      return false;
    }

    if (el1.length !== el2.length) {
      return false;
    }

    for (i = k = 0, ref = el1.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      if (!exports.compare(el1[i], el2[i])) {
        return false;
      }
    }
  } else {
    if (el1 !== el2) {
      return false;
    }
  }

  return true;
};

_snake_case = function _snake_case(str) {
  return str.replace(/([A-Z])/g, function (_, match, index) {
    return '_' + match.toLowerCase();
  });
};

exports.is_object = function is_object(obj) {
  return obj && _typeof(obj) === 'object' && !Array.isArray(obj);
};

exports.is_object_literal = function is_object_literal(obj) {
  var test;
  test = obj;

  if (_typeof(obj) !== 'object' || obj === null) {
    return false;
  } else {
    if (Object.getPrototypeOf(test) === null) {
      return true;
    }

    while (!false) {
      if (Object.getPrototypeOf(test = Object.getPrototypeOf(test)) === null) {
        break;
      }
    }

    return Object.getPrototypeOf(obj) === test;
  }
};
