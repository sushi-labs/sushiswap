{"version":3,"file":"getGroupedRowModel.js","sources":["../../../src/utils/getGroupedRowModel.ts"],"sourcesContent":["import { createRow } from '../core/row'\nimport { Table, Row, RowModel, RowData } from '../types'\nimport { flattenBy, memo } from '../utils'\n\nexport function getGroupedRowModel<TData extends RowData>(): (\n  table: Table<TData>\n) => () => RowModel<TData> {\n  return table =>\n    memo(\n      () => [table.getState().grouping, table.getPreGroupedRowModel()],\n      (grouping, rowModel) => {\n        if (!rowModel.rows.length || !grouping.length) {\n          return rowModel\n        }\n\n        // Filter the grouping list down to columns that exist\n        const existingGrouping = grouping.filter(columnId =>\n          table.getColumn(columnId)\n        )\n\n        const groupedFlatRows: Row<TData>[] = []\n        const groupedRowsById: Record<string, Row<TData>> = {}\n        // const onlyGroupedFlatRows: Row[] = [];\n        // const onlyGroupedRowsById: Record<RowId, Row> = {};\n        // const nonGroupedFlatRows: Row[] = [];\n        // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n        // Recursively group the data\n        const groupUpRecursively = (\n          rows: Row<TData>[],\n          depth = 0,\n          parentId?: string\n        ) => {\n          // Grouping depth has been been met\n          // Stop grouping and simply rewrite thd depth and row relationships\n          if (depth >= existingGrouping.length) {\n            return rows.map(row => {\n              row.depth = depth\n\n              groupedFlatRows.push(row)\n              groupedRowsById[row.id] = row\n\n              if (row.subRows) {\n                row.subRows = groupUpRecursively(row.subRows, depth + 1)\n              }\n\n              return row\n            })\n          }\n\n          const columnId = existingGrouping[depth]!\n\n          // Group the rows together for this level\n          const rowGroupsMap = groupBy(rows, columnId)\n\n          // Peform aggregations for each group\n          const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map(\n            ([groupingValue, groupedRows], index) => {\n              let id = `${columnId}:${groupingValue}`\n              id = parentId ? `${parentId}>${id}` : id\n\n              // First, Recurse to group sub rows before aggregation\n              const subRows = groupUpRecursively(groupedRows, depth + 1, id)\n\n              // Flatten the leaf rows of the rows in this group\n              const leafRows = depth\n                ? flattenBy(groupedRows, row => row.subRows)\n                : groupedRows\n\n              const row = createRow(\n                table,\n                id,\n                leafRows[0]!.original,\n                index,\n                depth\n              )\n\n              Object.assign(row, {\n                groupingColumnId: columnId,\n                groupingValue,\n                subRows,\n                leafRows,\n                getValue: (columnId: string) => {\n                  // Don't aggregate columns that are in the grouping\n                  if (existingGrouping.includes(columnId)) {\n                    if (row._valuesCache.hasOwnProperty(columnId)) {\n                      return row._valuesCache[columnId]\n                    }\n\n                    if (groupedRows[0]) {\n                      row._valuesCache[columnId] =\n                        groupedRows[0].getValue(columnId) ?? undefined\n                    }\n\n                    return row._valuesCache[columnId]\n                  }\n\n                  if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                    return row._groupingValuesCache[columnId]\n                  }\n\n                  // Aggregate the values\n                  const column = table.getColumn(columnId)\n                  const aggregateFn = column.getAggregationFn()\n\n                  if (aggregateFn) {\n                    row._groupingValuesCache[columnId] = aggregateFn(\n                      columnId,\n                      leafRows,\n                      groupedRows\n                    )\n\n                    return row._groupingValuesCache[columnId]\n                  }\n                },\n              })\n\n              subRows.forEach(subRow => {\n                groupedFlatRows.push(subRow)\n                groupedRowsById[subRow.id] = subRow\n                // if (subRow.getIsGrouped?.()) {\n                //   onlyGroupedFlatRows.push(subRow);\n                //   onlyGroupedRowsById[subRow.id] = subRow;\n                // } else {\n                //   nonGroupedFlatRows.push(subRow);\n                //   nonGroupedRowsById[subRow.id] = subRow;\n                // }\n              })\n\n              return row\n            }\n          )\n\n          return aggregatedGroupedRows\n        }\n\n        const groupedRows = groupUpRecursively(rowModel.rows, 0, '')\n\n        groupedRows.forEach(subRow => {\n          groupedFlatRows.push(subRow)\n          groupedRowsById[subRow.id] = subRow\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        })\n\n        return {\n          rows: groupedRows,\n          flatRows: groupedFlatRows,\n          rowsById: groupedRowsById,\n        }\n      },\n      {\n        key: process.env.NODE_ENV === 'development' && 'getGroupedRowModel',\n        debug: () => table.options.debugAll ?? table.options.debugTable,\n        onChange: () => {\n          table._queue(() => {\n            table._autoResetExpanded()\n            table._autoResetPageIndex()\n          })\n        },\n      }\n    )\n}\n\nfunction groupBy<TData extends RowData>(rows: Row<TData>[], columnId: string) {\n  const groupMap = new Map<any, Row<TData>[]>()\n\n  return rows.reduce((map, row) => {\n    const resKey = `${row.getValue(columnId)}`\n    const previous = map.get(resKey)\n    if (!previous) {\n      map.set(resKey, [row])\n    } else {\n      map.set(resKey, [...previous, row])\n    }\n    return map\n  }, groupMap)\n}\n"],"names":["getGroupedRowModel","table","memo","getState","grouping","getPreGroupedRowModel","rowModel","rows","length","existingGrouping","filter","columnId","getColumn","groupedFlatRows","groupedRowsById","groupUpRecursively","depth","parentId","map","row","push","id","subRows","rowGroupsMap","groupBy","aggregatedGroupedRows","Array","from","entries","index","groupingValue","groupedRows","leafRows","flattenBy","createRow","original","Object","assign","groupingColumnId","getValue","includes","_valuesCache","hasOwnProperty","undefined","_groupingValuesCache","column","aggregateFn","getAggregationFn","forEach","subRow","flatRows","rowsById","key","process","env","NODE_ENV","debug","options","debugAll","debugTable","onChange","_queue","_autoResetExpanded","_autoResetPageIndex","groupMap","Map","reduce","resKey","previous","get","set"],"mappings":"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"}