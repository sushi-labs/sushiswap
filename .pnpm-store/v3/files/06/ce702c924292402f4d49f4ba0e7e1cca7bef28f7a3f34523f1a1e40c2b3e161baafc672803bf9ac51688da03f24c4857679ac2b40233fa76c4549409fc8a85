{"version":3,"file":"edge-runtime.js","sourceRoot":"","sources":["../src/edge-runtime.ts"],"names":[],"mappings":";;;AAGA,yCAAyC;AACzC,uCAAmC;AAWnC;;;GAGG;AACH,IAAI,QAA4B,CAAA;AAEhC;;;;GAIG;AACH,MAAa,WAAwC,SAAQ,WAAS;IAGpE,YAAY,OAAoB;QAC9B,KAAK,CAAC;YACJ,GAAG,OAAO;YACV,MAAM,EAAE,CAAC,OAAO,EAAE,EAAE;;gBAClB,OAAO,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,wDAAG,OAAO,CAAC,mCAAK,OAAiC,CAAA;YACzE,CAAC;SACF,CAAC,CAAA;QAEF,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,+BAA+B,EAAE;YACnE,KAAK,EAAE,CAAC,QAA4B,EAAE,EAAE,CAAC,CAAC,QAAQ,GAAG,QAAQ,CAAC;YAC9D,YAAY,EAAE,KAAK;YACnB,UAAU,EAAE,KAAK;YACjB,QAAQ,EAAE,IAAI;SACf,CAAC,CAAA;QAEF,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,qBAAqB,EAAE;YACjD,GAAG,EAAE,GAAG,EAAE,CAAC,QAAQ;YACnB,YAAY,EAAE,KAAK;YACnB,UAAU,EAAE,KAAK;SAClB,CAAC,CAAA;QAEF,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,eAAe,EAAE;YACnD,YAAY,EAAE,KAAK;YACnB,UAAU,EAAE,KAAK;YACjB,QAAQ,EAAE,KAAK;YACf,KAAK,EAAE,EAAE,OAAO,EAAE,iBAAO,EAAE;SAC5B,CAAC,CAAA;QAEF,IAAI,CAAC,QAAQ,CAAO,iBAAiB,EAAE,CAAC,CAAA;QACxC,IAAI,CAAC,QAAQ,CAAO,2BAA2B,EAAE,CAAC,CAAA;QAClD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,QAAQ,CAAgB,oBAAoB,EAAE,CAAC,CAAA;QACzE,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,EAAE;YACxB,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,CAAA;SACnC;IACH,CAAC;CACF;AAtCD,kCAsCC;AAED;;;GAGG;AACH,OAAO,CAAC,EAAE,CAAC,oBAAoB,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,EAAE;IACnD,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAA;AAC1D,CAAC,CAAC,CAAA;AAEF;;;GAGG;AACH,SAAS,iBAAiB;IACxB,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BN,CAAA;AACH,CAAC;AAED;;;;;GAKG;AACH,SAAS,2BAA2B;IAClC,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCN,CAAA;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,oBAAoB;IAC3B,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA6BJ,CAAA;AACL,CAAC","sourcesContent":["import type { DispatchFetch, RejectionHandler } from './types'\nimport type { Primitives, ExtendedDictionary } from '@edge-runtime/vm'\nimport type { EdgeVMOptions } from '@edge-runtime/vm'\nimport { EdgeVM } from '@edge-runtime/vm'\nimport { VERSION } from './version'\n\ninterface Options<T extends Primitives> extends EdgeVMOptions<T> {\n  /**\n   * Code to be evaluated as the VM for the Runtime is created. This is handy\n   * to run code directly instead of first creating the runtime and then\n   * evaluating.\n   */\n  initialCode?: string\n}\n\n/**\n * Store handlers that the user defined from code so that we can invoke them\n * from the Node.js realm.\n */\nlet HANDLERS: RejectionHandler[]\n\n/**\n * An EdgeVM that also allows to add and remove event listeners for unhandled\n * rejections and FetchEvent. It also allows to dispatch fetch events which\n * enables it to work behind a server.\n */\nexport class EdgeRuntime<T extends Primitives = any> extends EdgeVM<T> {\n  public readonly dispatchFetch: DispatchFetch\n\n  constructor(options?: Options<T>) {\n    super({\n      ...options,\n      extend: (context) => {\n        return options?.extend?.(context) ?? (context as ExtendedDictionary<T>)\n      },\n    })\n\n    Object.defineProperty(this.context, '__onUnhandledRejectionHandler', {\n      value: (handlers: RejectionHandler[]) => (HANDLERS = handlers),\n      configurable: false,\n      enumerable: false,\n      writable: true,\n    })\n\n    Object.defineProperty(this, '__rejectionHandlers', {\n      get: () => HANDLERS,\n      configurable: false,\n      enumerable: false,\n    })\n\n    Object.defineProperty(this.context, 'VercelRuntime', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: { version: VERSION },\n    })\n\n    this.evaluate<void>(getFetchEventCode())\n    this.evaluate<void>(getDefineEventListenersCode())\n    this.dispatchFetch = this.evaluate<DispatchFetch>(getDispatchFetchCode())\n    if (options?.initialCode) {\n      this.evaluate(options.initialCode)\n    }\n  }\n}\n\n/**\n * Define a system-level handler to make sure that we report to the user\n * whenever there is an unhandled rejection before the process crashes.\n */\nprocess.on('unhandledRejection', (reason, promise) => {\n  HANDLERS?.forEach((handler) => handler(reason, promise))\n})\n\n/**\n * Gets a string with polyfills for FetchEvent and PromiseRejection which\n * are required to dispatch event and to model unhandled rejection events.\n */\nfunction getFetchEventCode() {\n  return `\n    class FetchEvent extends Event {\n      constructor(request) {\n        super('fetch')\n        this.request = request\n        this.response = null\n        this.awaiting = new Set()\n      }\n\n      respondWith(response) {\n        this.response = response\n      }\n\n      waitUntil(promise) {\n        this.awaiting.add(promise)\n        promise.finally(() => this.awaiting.delete(promise))\n      }\n    }\n\n    class PromiseRejectionEvent extends Event {\n      constructor(type, init) {\n        super(type, { cancelable: true })\n        this.promise = init.promise\n        this.reason = init.reason\n      }\n    }\n  `\n}\n\n/**\n * Generates polyfills for addEventListener and removeEventListener. It keeps\n * all listeners in hidden property __listeners. It will also call a hook\n * `__onUnhandledRejectionHandler` when unhandled rejection events are added\n * or removed and prevent from having more than one FetchEvent handler.\n */\nfunction getDefineEventListenersCode() {\n  return `\n    Object.defineProperty(self, '__listeners', {\n      configurable: false,\n      enumerable: false,\n      value: {},\n      writable: true,\n    })\n\n    function addEventListener(type, handler) {\n      const eventType = type.toLowerCase();\n      if (eventType === 'fetch' && self.__listeners.fetch) {\n        throw new TypeError('You can register just one \"fetch\" event listener');\n      }\n\n      self.__listeners[eventType] = self.__listeners[eventType] || [];\n      self.__listeners[eventType].push(handler);\n\n      if (eventType === 'unhandledrejection') {\n        self.__onUnhandledRejectionHandler(self.__listeners.unhandledrejection)\n      }\n    }\n\n    function removeEventListener(type, handler) {\n      const eventType = type.toLowerCase();\n      if (self.__listeners[eventType]) {\n        self.__listeners[eventType] = self.__listeners[eventType].filter(item => {\n          return item !== handler;\n        });\n\n        if (self.__listeners[eventType].length === 0) {\n          delete self.__listeners[eventType];\n        }\n      }\n\n      if (eventType === 'unhandledrejection') {\n        self.__onUnhandledRejectionHandler(self.__listeners.unhandledrejection)\n      }\n    }\n  `\n}\n\n/**\n * Generates the code to dispatch a FetchEvent invoking the handlers defined\n * for such events. In case there is no event handler defined it will throw\n * an error.\n */\nfunction getDispatchFetchCode() {\n  return `(async function dispatchFetch(input, init) {\n    const request = new Request(input, init);\n    const event = new FetchEvent(request);\n    if (!self.__listeners.fetch) {\n      throw new Error(\"No fetch event listeners found\");\n    }\n\n    const getResponse = ({ response, error }) => {\n     if (error || !response || !(response instanceof Response)) {\n        console.error(error ? error : 'The event listener did not respond')\n        response = new Response(null, {\n          statusText: 'Internal Server Error',\n          status: 500\n        })\n      }\n\n      response.waitUntil = () => Promise.all(event.awaiting);\n      return response;\n    }\n\n    try {\n      await self.__listeners.fetch[0].call(event, event)\n    } catch (error) {\n      return getResponse({ error })\n    }\n\n    return Promise.resolve(event.response)\n      .then(response => getResponse({ response }))\n      .catch(error => getResponse({ error }))\n  })`\n}\n"]}