/**
 * table-core
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var row = require('../core/row.js');
var utils = require('../utils.js');

function getGroupedRowModel() {
  return instance => utils.memo(() => [instance.getState().grouping, instance.getPreGroupedRowModel()], (grouping, rowModel) => {
    if (!rowModel.rows.length || !grouping.length) {
      return rowModel;
    } // Filter the grouping list down to columns that exist


    const existingGrouping = grouping.filter(columnId => instance.getColumn(columnId));
    const groupedFlatRows = [];
    const groupedRowsById = {}; // const onlyGroupedFlatRows: Row[] = [];
    // const onlyGroupedRowsById: Record<RowId, Row> = {};
    // const nonGroupedFlatRows: Row[] = [];
    // const nonGroupedRowsById: Record<RowId, Row> = {};
    // Recursively group the data

    const groupUpRecursively = function (rows, depth, parentId) {
      if (depth === void 0) {
        depth = 0;
      }

      // This is the last level, just return the rows
      if (depth === existingGrouping.length) {
        return rows;
      }

      const columnId = existingGrouping[depth]; // Group the rows together for this level

      const rowGroupsMap = groupBy(rows, columnId); // Peform aggregations for each group

      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {
        let [groupingValue, groupedRows] = _ref;
        let id = columnId + ":" + groupingValue;
        id = parentId ? parentId + ">" + id : id; // First, Recurse to group sub rows before aggregation

        const subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group

        const leafRows = depth ? utils.flattenBy(groupedRows, row => row.subRows) : groupedRows;
        const row$1 = row.createRow(instance, id, undefined, index, depth);
        Object.assign(row$1, {
          groupingColumnId: columnId,
          groupingValue,
          subRows,
          leafRows,
          getValue: columnId => {
            // Don't aggregate columns that are in the grouping
            if (existingGrouping.includes(columnId)) {
              if (row$1._valuesCache.hasOwnProperty(columnId)) {
                return row$1._valuesCache[columnId];
              }

              if (groupedRows[0]) {
                var _groupedRows$0$getVal;

                row$1._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;
              }

              return row$1._valuesCache[columnId];
            }

            if (row$1._groupingValuesCache.hasOwnProperty(columnId)) {
              return row$1._groupingValuesCache[columnId];
            } // Aggregate the values


            const column = instance.getColumn(columnId);
            const aggregateFn = column.getAggregationFn();

            if (aggregateFn) {
              row$1._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);
              return row$1._groupingValuesCache[columnId];
            } else if (column.aggregationFn) {
              console.info({
                column
              });
              throw new Error(process.env.NODE_ENV !== 'production' ? "Table: Invalid column.aggregateType option for column listed above" : '');
            }
          }
        });
        subRows.forEach(subRow => {
          groupedFlatRows.push(subRow);
          groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {
          //   onlyGroupedFlatRows.push(subRow);
          //   onlyGroupedRowsById[subRow.id] = subRow;
          // } else {
          //   nonGroupedFlatRows.push(subRow);
          //   nonGroupedRowsById[subRow.id] = subRow;
          // }
        });
        return row$1;
      });
      return aggregatedGroupedRows;
    };

    const groupedRows = groupUpRecursively(rowModel.rows, 0, '');
    groupedRows.forEach(subRow => {
      groupedFlatRows.push(subRow);
      groupedRowsById[subRow.id] = subRow; // if (subRow.getIsGrouped?.()) {
      //   onlyGroupedFlatRows.push(subRow);
      //   onlyGroupedRowsById[subRow.id] = subRow;
      // } else {
      //   nonGroupedFlatRows.push(subRow);
      //   nonGroupedRowsById[subRow.id] = subRow;
      // }
    });
    return {
      rows: groupedRows,
      flatRows: groupedFlatRows,
      rowsById: groupedRowsById
    };
  }, {
    key: process.env.NODE_ENV === 'development' && 'getGroupedRowModel',
    debug: () => {
      var _instance$options$deb;

      return (_instance$options$deb = instance.options.debugAll) != null ? _instance$options$deb : instance.options.debugTable;
    },
    onChange: () => {
      instance._queue(() => {
        instance._autoResetExpanded();

        instance._autoResetPageIndex();
      });
    }
  });
}

function groupBy(rows, columnId) {
  const groupMap = new Map();
  return rows.reduce((map, row) => {
    const resKey = "" + row.getValue(columnId);
    const previous = map.get(resKey);

    if (!previous) {
      map.set(resKey, [row]);
    } else {
      map.set(resKey, [...previous, row]);
    }

    return map;
  }, groupMap);
}

exports.getGroupedRowModel = getGroupedRowModel;
//# sourceMappingURL=getGroupedRowModel.js.map
