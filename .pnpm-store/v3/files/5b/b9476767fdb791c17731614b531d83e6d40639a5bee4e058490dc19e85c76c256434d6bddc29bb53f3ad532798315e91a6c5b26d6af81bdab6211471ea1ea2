{"version":3,"names":["VALID_CALLEES","INVALID_METHODS","isValidCallee","val","includes","isInvalidMethod","evaluateTruthy","res","evaluate","confident","value","deopt","path","state","deoptPath","evaluateCached","node","seen","has","existing","get","resolved","item","set","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","undefined","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","key","computed","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","context","func","global","args","map","apply","raw","str","i","cooked","expr","String","Map"],"sources":["../../src/path/evaluation.ts"],"sourcesContent":["import type NodePath from \"./index\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"] as const;\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidCallee(val: string): val is typeof VALID_CALLEES[number] {\n  return VALID_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is typeof INVALID_METHODS[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding?.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n      const keyPath = (prop as NodePath<t.ObjectProperty>).get(\"key\");\n      let key;\n      // @ts-expect-error todo(flow->ts): type refinement issues ObjectMethod and SpreadElement somehow not excluded\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = (prop as NodePath<t.ObjectProperty>).get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right;\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      isValidCallee(callee.node.name)\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        // @ts-expect-error property may not exist in context object\n        func = context[property.node.name];\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n"],"mappings":";;;;;;;AAKA,MAAMA,aAAa,GAAG,CAAC,QAAD,EAAW,QAAX,EAAqB,MAArB,CAAtB;AACA,MAAMC,eAAe,GAAG,CAAC,QAAD,CAAxB;;AAEA,SAASC,aAAT,CAAuBC,GAAvB,EAAyE;EACvE,OAAOH,aAAa,CAACI,QAAd,CAELD,GAFK,CAAP;AAID;;AAED,SAASE,eAAT,CAAyBF,GAAzB,EAA6E;EAC3E,OAAOF,eAAe,CAACG,QAAhB,CAELD,GAFK,CAAP;AAID;;AAoBM,SAASG,cAAT,GAAiD;EACtD,MAAMC,GAAG,GAAG,KAAKC,QAAL,EAAZ;EACA,IAAID,GAAG,CAACE,SAAR,EAAmB,OAAO,CAAC,CAACF,GAAG,CAACG,KAAb;AACpB;;AAeD,SAASC,KAAT,CAAeC,IAAf,EAA+BC,KAA/B,EAA6C;EAC3C,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;EACtBI,KAAK,CAACC,SAAN,GAAkBF,IAAlB;EACAC,KAAK,CAACJ,SAAN,GAAkB,KAAlB;AACD;;AAUD,SAASM,cAAT,CAAwBH,IAAxB,EAAwCC,KAAxC,EAA2D;EACzD,MAAM;IAAEG;EAAF,IAAWJ,IAAjB;EACA,MAAM;IAAEK;EAAF,IAAWJ,KAAjB;;EAEA,IAAII,IAAI,CAACC,GAAL,CAASF,IAAT,CAAJ,EAAoB;IAClB,MAAMG,QAAQ,GAAGF,IAAI,CAACG,GAAL,CAASJ,IAAT,CAAjB;;IACA,IAAIG,QAAQ,CAACE,QAAb,EAAuB;MACrB,OAAOF,QAAQ,CAACT,KAAhB;IACD,CAFD,MAEO;MACLC,KAAK,CAACC,IAAD,EAAOC,KAAP,CAAL;MACA;IACD;EACF,CARD,MAQO;IACL,MAAMS,IAAY,GAAG;MAAED,QAAQ,EAAE;IAAZ,CAArB;IACAJ,IAAI,CAACM,GAAL,CAASP,IAAT,EAAeM,IAAf;;IAEA,MAAMnB,GAAG,GAAGqB,SAAS,CAACZ,IAAD,EAAOC,KAAP,CAArB;;IACA,IAAIA,KAAK,CAACJ,SAAV,EAAqB;MACnBa,IAAI,CAACD,QAAL,GAAgB,IAAhB;MACAC,IAAI,CAACZ,KAAL,GAAaP,GAAb;IACD;;IACD,OAAOA,GAAP;EACD;AACF;;AAED,SAASqB,SAAT,CAAmBZ,IAAnB,EAAmCC,KAAnC,EAAsD;EACpD,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;;EAEtB,IAAIG,IAAI,CAACa,oBAAL,EAAJ,EAAiC;IAC/B,MAAMC,KAAK,GAAGd,IAAI,CAACQ,GAAL,CAAS,aAAT,CAAd;IACA,OAAOL,cAAc,CAACW,KAAK,CAACA,KAAK,CAACC,MAAN,GAAe,CAAhB,CAAN,EAA0Bd,KAA1B,CAArB;EACD;;EAED,IACED,IAAI,CAACgB,eAAL,MACAhB,IAAI,CAACiB,gBAAL,EADA,IAEAjB,IAAI,CAACkB,gBAAL,EAHF,EAIE;IACA,OAAOlB,IAAI,CAACI,IAAL,CAAUN,KAAjB;EACD;;EAED,IAAIE,IAAI,CAACmB,aAAL,EAAJ,EAA0B;IACxB,OAAO,IAAP;EACD;;EAED,IAAInB,IAAI,CAACoB,iBAAL,EAAJ,EAA8B;IAC5B,OAAOC,cAAc,CAACrB,IAAD,EAAOA,IAAI,CAACI,IAAL,CAAUkB,MAAjB,EAAyBrB,KAAzB,CAArB;EACD;;EAED,IACED,IAAI,CAACuB,0BAAL,MACAvB,IAAI,CAACQ,GAAL,CAAS,KAAT,EAAgBgB,kBAAhB,EAFF,EAGE;IACA,MAAMC,MAAM,GAAGzB,IAAI,CAACQ,GAAL,CAAS,YAAT,CAAf;IACA,MAAM;MAEJJ,IAAI,EAAE;QAAEsB;MAAF;IAFF,IAGFD,MAHJ;IAIA,MAAME,QAAQ,GAAG3B,IAAI,CAACQ,GAAL,CAAS,cAAT,CAAjB;;IAEA,IACEiB,MAAM,CAACG,YAAP,MACAF,IAAI,KAAK,QADT,IAIA,CAAC1B,IAAI,CAAC6B,KAAL,CAAWC,UAAX,CAAsBJ,IAAtB,CAJD,IAKAC,QAAQ,CAACC,YAAT,EALA,IAMAD,QAAQ,CAACvB,IAAT,CAAcsB,IAAd,KAAuB,KAPzB,EAQE;MACA,OAAOL,cAAc,CAACrB,IAAD,EAAOA,IAAI,CAACI,IAAL,CAAU2B,KAAV,CAAgBT,MAAvB,EAA+BrB,KAA/B,EAAsC,IAAtC,CAArB;IACD;EACF;;EAED,IAAID,IAAI,CAACgC,uBAAL,EAAJ,EAAoC;IAClC,MAAMC,UAAU,GAAG9B,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,MAAT,CAAD,EAAmBP,KAAnB,CAAjC;IACA,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;;IACtB,IAAIoC,UAAJ,EAAgB;MACd,OAAO9B,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,YAAT,CAAD,EAAyBP,KAAzB,CAArB;IACD,CAFD,MAEO;MACL,OAAOE,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,WAAT,CAAD,EAAwBP,KAAxB,CAArB;IACD;EACF;;EAED,IAAID,IAAI,CAACkC,mBAAL,EAAJ,EAAgC;IAE9B,OAAO/B,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,YAAT,CAAD,EAAyBP,KAAzB,CAArB;EACD;;EAGD,IACED,IAAI,CAACwB,kBAAL,MACA,CAACxB,IAAI,CAACmC,UAAL,CAAgBC,gBAAhB,CAAiC;IAAEC,MAAM,EAAErC,IAAI,CAACI;EAAf,CAAjC,CAFH,EAGE;IACA,MAAMuB,QAAQ,GAAG3B,IAAI,CAACQ,GAAL,CAAS,UAAT,CAAjB;IACA,MAAMiB,MAAM,GAAGzB,IAAI,CAACQ,GAAL,CAAS,QAAT,CAAf;;IAEA,IAAIiB,MAAM,CAACa,SAAP,MAAsBX,QAAQ,CAACC,YAAT,EAA1B,EAAmD;MAEjD,MAAM9B,KAAK,GAAG2B,MAAM,CAACrB,IAAP,CAAYN,KAA1B;MACA,MAAMyC,IAAI,GAAG,OAAOzC,KAApB;;MACA,IAAIyC,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,QAAlC,EAA4C;QAC1C,OAAOzC,KAAK,CAAC6B,QAAQ,CAACvB,IAAT,CAAcsB,IAAf,CAAZ;MACD;IACF;EACF;;EAED,IAAI1B,IAAI,CAACwC,sBAAL,EAAJ,EAAmC;IACjC,MAAMC,OAAO,GAAGzC,IAAI,CAAC6B,KAAL,CAAWC,UAAX,CAAsB9B,IAAI,CAACI,IAAL,CAAUsB,IAAhC,CAAhB;;IAEA,IAAIe,OAAO,IAAIA,OAAO,CAACC,kBAAR,CAA2B3B,MAA3B,GAAoC,CAAnD,EAAsD;MACpD,OAAOhB,KAAK,CAAC0C,OAAO,CAACzC,IAAT,EAAeC,KAAf,CAAZ;IACD;;IAED,IAAIwC,OAAO,IAAIzC,IAAI,CAACI,IAAL,CAAUuC,KAAV,GAAkBF,OAAO,CAACzC,IAAR,CAAaI,IAAb,CAAkBwC,GAAnD,EAAwD;MACtD,OAAO7C,KAAK,CAAC0C,OAAO,CAACzC,IAAT,EAAeC,KAAf,CAAZ;IACD;;IAED,IAAIwC,OAAJ,YAAIA,OAAO,CAAEI,QAAb,EAAuB;MACrB,OAAOJ,OAAO,CAAC3C,KAAf;IACD,CAFD,MAEO;MACL,IAAIE,IAAI,CAACI,IAAL,CAAUsB,IAAV,KAAmB,WAAvB,EAAoC;QAClC,OAAOe,OAAO,GAAG1C,KAAK,CAAC0C,OAAO,CAACzC,IAAT,EAAeC,KAAf,CAAR,GAAgC6C,SAA9C;MACD,CAFD,MAEO,IAAI9C,IAAI,CAACI,IAAL,CAAUsB,IAAV,KAAmB,UAAvB,EAAmC;QACxC,OAAOe,OAAO,GAAG1C,KAAK,CAAC0C,OAAO,CAACzC,IAAT,EAAeC,KAAf,CAAR,GAAgC8C,QAA9C;MACD,CAFM,MAEA,IAAI/C,IAAI,CAACI,IAAL,CAAUsB,IAAV,KAAmB,KAAvB,EAA8B;QACnC,OAAOe,OAAO,GAAG1C,KAAK,CAAC0C,OAAO,CAACzC,IAAT,EAAeC,KAAf,CAAR,GAAgC+C,GAA9C;MACD;;MAED,MAAMvC,QAAQ,GAAGT,IAAI,CAACiD,OAAL,EAAjB;;MACA,IAAIxC,QAAQ,KAAKT,IAAjB,EAAuB;QACrB,OAAOD,KAAK,CAACC,IAAD,EAAOC,KAAP,CAAZ;MACD,CAFD,MAEO;QACL,OAAOE,cAAc,CAACM,QAAD,EAAWR,KAAX,CAArB;MACD;IACF;EACF;;EAED,IAAID,IAAI,CAACkD,iBAAL,CAAuB;IAAEC,MAAM,EAAE;EAAV,CAAvB,CAAJ,EAA8C;IAC5C,IAAInD,IAAI,CAACI,IAAL,CAAUgD,QAAV,KAAuB,MAA3B,EAAmC;MAEjC,OAAON,SAAP;IACD;;IAED,MAAMO,QAAQ,GAAGrD,IAAI,CAACQ,GAAL,CAAS,UAAT,CAAjB;;IACA,IACER,IAAI,CAACI,IAAL,CAAUgD,QAAV,KAAuB,QAAvB,KACCC,QAAQ,CAACC,UAAT,MAAyBD,QAAQ,CAACE,OAAT,EAD1B,CADF,EAGE;MACA,OAAO,UAAP;IACD;;IAED,MAAMC,GAAG,GAAGrD,cAAc,CAACkD,QAAD,EAAWpD,KAAX,CAA1B;IACA,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;;IACtB,QAAQG,IAAI,CAACI,IAAL,CAAUgD,QAAlB;MACE,KAAK,GAAL;QACE,OAAO,CAACI,GAAR;;MACF,KAAK,GAAL;QACE,OAAO,CAACA,GAAR;;MACF,KAAK,GAAL;QACE,OAAO,CAACA,GAAR;;MACF,KAAK,GAAL;QACE,OAAO,CAACA,GAAR;;MACF,KAAK,QAAL;QACE,OAAO,OAAOA,GAAd;IAVJ;EAYD;;EAED,IAAIxD,IAAI,CAACyD,iBAAL,EAAJ,EAA8B;IAC5B,MAAMC,GAAG,GAAG,EAAZ;IACA,MAAMC,KAAsB,GAAG3D,IAAI,CAACQ,GAAL,CAAS,UAAT,CAA/B;;IACA,KAAK,MAAMoD,IAAX,IAAmBD,KAAnB,EAA0B;MACxB,MAAME,SAAS,GAAGD,IAAI,CAAChE,QAAL,EAAlB;;MAEA,IAAIiE,SAAS,CAAChE,SAAd,EAAyB;QACvB6D,GAAG,CAACI,IAAJ,CAASD,SAAS,CAAC/D,KAAnB;MACD,CAFD,MAEO;QACL,OAAOC,KAAK,CAAC8D,SAAS,CAAC9D,KAAX,EAAkBE,KAAlB,CAAZ;MACD;IACF;;IACD,OAAOyD,GAAP;EACD;;EAED,IAAI1D,IAAI,CAAC+D,kBAAL,EAAJ,EAA+B;IAC7B,MAAMC,GAAG,GAAG,EAAZ;IACA,MAAMC,KAAK,GAAGjE,IAAI,CAACQ,GAAL,CAAS,YAAT,CAAd;;IACA,KAAK,MAAM0D,IAAX,IAAmBD,KAAnB,EAA0B;MACxB,IAAIC,IAAI,CAACC,cAAL,MAAyBD,IAAI,CAACE,eAAL,EAA7B,EAAqD;QACnD,OAAOrE,KAAK,CAACmE,IAAD,EAAOjE,KAAP,CAAZ;MACD;;MACD,MAAMoE,OAAO,GAAIH,IAAD,CAAqC1D,GAArC,CAAyC,KAAzC,CAAhB;MACA,IAAI8D,GAAJ;;MAEA,IAAIJ,IAAI,CAAC9D,IAAL,CAAUmE,QAAd,EAAwB;QACtBD,GAAG,GAAGD,OAAO,CAACzE,QAAR,EAAN;;QACA,IAAI,CAAC0E,GAAG,CAACzE,SAAT,EAAoB;UAClB,OAAOE,KAAK,CAACuE,GAAG,CAACvE,KAAL,EAAYE,KAAZ,CAAZ;QACD;;QACDqE,GAAG,GAAGA,GAAG,CAACxE,KAAV;MACD,CAND,MAMO,IAAIuE,OAAO,CAACzC,YAAR,EAAJ,EAA4B;QACjC0C,GAAG,GAAGD,OAAO,CAACjE,IAAR,CAAasB,IAAnB;MACD,CAFM,MAEA;QACL4C,GAAG,GACDD,OAAO,CAACjE,IADJ,CAEJN,KAFF;MAGD;;MACD,MAAM0E,SAAS,GAAIN,IAAD,CAAqC1D,GAArC,CAAyC,OAAzC,CAAlB;MACA,IAAIV,KAAK,GAAG0E,SAAS,CAAC5E,QAAV,EAAZ;;MACA,IAAI,CAACE,KAAK,CAACD,SAAX,EAAsB;QACpB,OAAOE,KAAK,CAACD,KAAK,CAACC,KAAP,EAAcE,KAAd,CAAZ;MACD;;MACDH,KAAK,GAAGA,KAAK,CAACA,KAAd;MAEAkE,GAAG,CAACM,GAAD,CAAH,GAAWxE,KAAX;IACD;;IACD,OAAOkE,GAAP;EACD;;EAED,IAAIhE,IAAI,CAACyE,mBAAL,EAAJ,EAAgC;IAG9B,MAAMC,YAAY,GAAGzE,KAAK,CAACJ,SAA3B;IACA,MAAM8E,IAAI,GAAGxE,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,MAAT,CAAD,EAAmBP,KAAnB,CAA3B;IACA,MAAM2E,aAAa,GAAG3E,KAAK,CAACJ,SAA5B;IACAI,KAAK,CAACJ,SAAN,GAAkB6E,YAAlB;IACA,MAAMG,KAAK,GAAG1E,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,OAAT,CAAD,EAAoBP,KAApB,CAA5B;IACA,MAAM6E,cAAc,GAAG7E,KAAK,CAACJ,SAA7B;;IAEA,QAAQG,IAAI,CAACI,IAAL,CAAUgD,QAAlB;MACE,KAAK,IAAL;QAGEnD,KAAK,CAACJ,SAAN,GAAkB+E,aAAa,KAAK,CAAC,CAACD,IAAF,IAAUG,cAAf,CAA/B;QACA,IAAI,CAAC7E,KAAK,CAACJ,SAAX,EAAsB;QAEtB,OAAO8E,IAAI,IAAIE,KAAf;;MACF,KAAK,IAAL;QACE5E,KAAK,CAACJ,SAAN,GAAkB+E,aAAa,KAAK,CAACD,IAAD,IAASG,cAAd,CAA/B;QACA,IAAI,CAAC7E,KAAK,CAACJ,SAAX,EAAsB;QAEtB,OAAO8E,IAAI,IAAIE,KAAf;;MACF,KAAK,IAAL;QACE5E,KAAK,CAACJ,SAAN,GAAkB+E,aAAa,KAAKD,IAAI,IAAI,IAAR,IAAgBG,cAArB,CAA/B;QACA,IAAI,CAAC7E,KAAK,CAACJ,SAAX,EAAsB;QAEtB,OAAO8E,IAAP,WAAOA,IAAP,GAAeE,KAAf;IAjBJ;EAmBD;;EAED,IAAI7E,IAAI,CAAC+E,kBAAL,EAAJ,EAA+B;IAC7B,MAAMJ,IAAI,GAAGxE,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,MAAT,CAAD,EAAmBP,KAAnB,CAA3B;IACA,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;IACtB,MAAMgF,KAAK,GAAG1E,cAAc,CAACH,IAAI,CAACQ,GAAL,CAAS,OAAT,CAAD,EAAoBP,KAApB,CAA5B;IACA,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;;IAEtB,QAAQG,IAAI,CAACI,IAAL,CAAUgD,QAAlB;MACE,KAAK,GAAL;QACE,OAAOuB,IAAI,GAAGE,KAAd;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,IAAL;QACE,gBAAOF,IAAP,EAAeE,KAAf;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,IAAL;QACE,OAAOF,IAAI,IAAIE,KAAf;;MACF,KAAK,IAAL;QACE,OAAOF,IAAI,IAAIE,KAAf;;MACF,KAAK,IAAL;QACE,OAAOF,IAAI,IAAIE,KAAf;;MACF,KAAK,IAAL;QACE,OAAOF,IAAI,IAAIE,KAAf;;MACF,KAAK,KAAL;QACE,OAAOF,IAAI,KAAKE,KAAhB;;MACF,KAAK,KAAL;QACE,OAAOF,IAAI,KAAKE,KAAhB;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,GAAL;QACE,OAAOF,IAAI,GAAGE,KAAd;;MACF,KAAK,IAAL;QACE,OAAOF,IAAI,IAAIE,KAAf;;MACF,KAAK,IAAL;QACE,OAAOF,IAAI,IAAIE,KAAf;;MACF,KAAK,KAAL;QACE,OAAOF,IAAI,KAAKE,KAAhB;IAxCJ;EA0CD;;EAED,IAAI7E,IAAI,CAACoC,gBAAL,EAAJ,EAA6B;IAC3B,MAAMC,MAAM,GAAGrC,IAAI,CAACQ,GAAL,CAAS,QAAT,CAAf;IACA,IAAIwE,OAAJ;IACA,IAAIC,IAAJ;;IAGA,IACE5C,MAAM,CAACT,YAAP,MACA,CAAC5B,IAAI,CAAC6B,KAAL,CAAWC,UAAX,CAAsBO,MAAM,CAACjC,IAAP,CAAYsB,IAAlC,CADD,IAEApC,aAAa,CAAC+C,MAAM,CAACjC,IAAP,CAAYsB,IAAb,CAHf,EAIE;MACAuD,IAAI,GAAGC,MAAM,CAAC7C,MAAM,CAACjC,IAAP,CAAYsB,IAAb,CAAb;IACD;;IAED,IAAIW,MAAM,CAACb,kBAAP,EAAJ,EAAiC;MAC/B,MAAMC,MAAM,GAAGY,MAAM,CAAC7B,GAAP,CAAW,QAAX,CAAf;MACA,MAAMmB,QAAQ,GAAGU,MAAM,CAAC7B,GAAP,CAAW,UAAX,CAAjB;;MAGA,IACEiB,MAAM,CAACG,YAAP,MACAD,QAAQ,CAACC,YAAT,EADA,IAEAtC,aAAa,CAACmC,MAAM,CAACrB,IAAP,CAAYsB,IAAb,CAFb,IAGA,CAACjC,eAAe,CAACkC,QAAQ,CAACvB,IAAT,CAAcsB,IAAf,CAJlB,EAKE;QACAsD,OAAO,GAAGE,MAAM,CAACzD,MAAM,CAACrB,IAAP,CAAYsB,IAAb,CAAhB;QAEAuD,IAAI,GAAGD,OAAO,CAACrD,QAAQ,CAACvB,IAAT,CAAcsB,IAAf,CAAd;MACD;;MAGD,IAAID,MAAM,CAACa,SAAP,MAAsBX,QAAQ,CAACC,YAAT,EAA1B,EAAmD;QAEjD,MAAMW,IAAI,GAAG,OAAOd,MAAM,CAACrB,IAAP,CAAYN,KAAhC;;QACA,IAAIyC,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,QAAlC,EAA4C;UAE1CyC,OAAO,GAAGvD,MAAM,CAACrB,IAAP,CAAYN,KAAtB;UACAmF,IAAI,GAAGD,OAAO,CAACrD,QAAQ,CAACvB,IAAT,CAAcsB,IAAf,CAAd;QACD;MACF;IACF;;IAED,IAAIuD,IAAJ,EAAU;MACR,MAAME,IAAI,GAAGnF,IAAI,CAACQ,GAAL,CAAS,WAAT,EAAsB4E,GAAtB,CAA0B5B,GAAG,IAAIrD,cAAc,CAACqD,GAAD,EAAMvD,KAAN,CAA/C,CAAb;MACA,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;MAEtB,OAAOoF,IAAI,CAACI,KAAL,CAAWL,OAAX,EAAoBG,IAApB,CAAP;IACD;EACF;;EAEDpF,KAAK,CAACC,IAAD,EAAOC,KAAP,CAAL;AACD;;AAED,SAASoB,cAAT,CACErB,IADF,EAEEsB,MAFF,EAGErB,KAHF,EAIEqF,GAAG,GAAG,KAJR,EAKE;EACA,IAAIC,GAAG,GAAG,EAAV;EAEA,IAAIC,CAAC,GAAG,CAAR;EACA,MAAM1E,KAAK,GAAGd,IAAI,CAACQ,GAAL,CAAS,aAAT,CAAd;;EAEA,KAAK,MAAMoD,IAAX,IAAmBtC,MAAnB,EAA2B;IAEzB,IAAI,CAACrB,KAAK,CAACJ,SAAX,EAAsB;IAGtB0F,GAAG,IAAID,GAAG,GAAG1B,IAAI,CAAC9D,KAAL,CAAWwF,GAAd,GAAoB1B,IAAI,CAAC9D,KAAL,CAAW2F,MAAzC;IAGA,MAAMC,IAAI,GAAG5E,KAAK,CAAC0E,CAAC,EAAF,CAAlB;IACA,IAAIE,IAAJ,EAAUH,GAAG,IAAII,MAAM,CAACxF,cAAc,CAACuF,IAAD,EAAOzF,KAAP,CAAf,CAAb;EACX;;EAED,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsB;EACtB,OAAO0F,GAAP;AACD;;AAkBM,SAAS3F,QAAT,GAIL;EACA,MAAMK,KAAY,GAAG;IACnBJ,SAAS,EAAE,IADQ;IAEnBK,SAAS,EAAE,IAFQ;IAGnBG,IAAI,EAAE,IAAIuF,GAAJ;EAHa,CAArB;EAKA,IAAI9F,KAAK,GAAGK,cAAc,CAAC,IAAD,EAAOF,KAAP,CAA1B;EACA,IAAI,CAACA,KAAK,CAACJ,SAAX,EAAsBC,KAAK,GAAGgD,SAAR;EAEtB,OAAO;IACLjD,SAAS,EAAEI,KAAK,CAACJ,SADZ;IAELE,KAAK,EAAEE,KAAK,CAACC,SAFR;IAGLJ,KAAK,EAAEA;EAHF,CAAP;AAKD"}