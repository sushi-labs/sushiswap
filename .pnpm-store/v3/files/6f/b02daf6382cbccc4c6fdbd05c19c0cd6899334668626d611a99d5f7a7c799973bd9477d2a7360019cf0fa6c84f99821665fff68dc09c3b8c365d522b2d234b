{"version":3,"file":"require.js","sourceRoot":"","sources":["../src/require.ts"],"names":[],"mappings":";;;AAEA,2BAAiC;AACjC,2BAAiC;AACjC,+BAA8B;AAE9B;;;;GAIG;AACH,SAAgB,mBAAmB,CAAC,MAOnC;IACC,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,YAAY,EAAE,GAAG,MAAM,CAAA;IACtD,MAAM,SAAS,GAAG,aAAa,CAAC,OAAO,EAAE,YAAY,CAAC,CAAA;IACtD,KAAK,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,YAAY,EAAE;QAC/C,MAAM,GAAG,GAAG,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAA;QACjC,KAAK,MAAM,MAAM,IAAI,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YAC5C,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,CAAA;SAC1C;KACF;AACH,CAAC;AAhBD,kDAgBC;AAED,SAAgB,aAAa,CAAC,OAAgB,EAAE,KAAuB;IACrE,OAAO,SAAS,SAAS,CAAC,QAAgB,EAAE,SAAiB;QAC3D,MAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,EAAE;YAC1C,KAAK,EAAE,CAAC,IAAA,cAAO,EAAC,QAAQ,CAAC,CAAC;SAC3B,CAAC,CAAA;QAEF,MAAM,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;QAClC,IAAI,MAAM,KAAK,SAAS,EAAE;YACxB,OAAO,MAAM,CAAC,OAAO,CAAA;SACtB;QAED,MAAM,MAAM,GAAG;YACb,OAAO,EAAE,EAAE;YACX,MAAM,EAAE,KAAK;YACb,EAAE,EAAE,QAAQ;SACb,CAAA;QAED,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAA;QAC3B,MAAM,EAAE,GAAG,IAAA,iBAAY,EACrB,2DAA2D,IAAA,iBAAY,EACrE,QAAQ,EACR,OAAO,CACR,MAAM,EACP,OAAO,CACR,CAAA;QAED,IAAI;YACF,EAAE,CACA,MAAM,EACN,MAAM,CAAC,OAAO,EACd,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,EAC9B,IAAA,cAAO,EAAC,QAAQ,CAAC,EACjB,QAAQ,CACT,CAAA;SACF;gBAAS;YACR,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAA;SACvB;QACD,MAAM,CAAC,MAAM,GAAG,IAAI,CAAA;QACpB,OAAO,MAAM,CAAC,OAAO,CAAA;IACvB,CAAC,CAAA;AACH,CAAC;AAxCD,sCAwCC","sourcesContent":["import type { Dictionary } from './types'\nimport type { Context } from 'vm'\nimport { readFileSync } from 'fs'\nimport { runInContext } from 'vm'\nimport { dirname } from 'path'\n\n/**\n * Allows to require a series of dependencies provided by their path\n * into a provided module context. It fills and accepts a require\n * cache to ensure each module is loaded once.\n */\nexport function requireDependencies(params: {\n  context: Context\n  requireCache: Map<string, Dictionary>\n  dependencies: Array<{\n    mapExports: { [key: string]: string }\n    path: string\n  }>\n}): void {\n  const { context, requireCache, dependencies } = params\n  const requireFn = createRequire(context, requireCache)\n  for (const { path, mapExports } of dependencies) {\n    const mod = requireFn(path, path)\n    for (const mapKey of Object.keys(mapExports)) {\n      context[mapExports[mapKey]] = mod[mapKey]\n    }\n  }\n}\n\nexport function createRequire(context: Context, cache: Map<string, any>) {\n  return function requireFn(referrer: string, specifier: string) {\n    const resolved = require.resolve(specifier, {\n      paths: [dirname(referrer)],\n    })\n\n    const cached = cache.get(resolved)\n    if (cached !== undefined) {\n      return cached.exports\n    }\n\n    const module = {\n      exports: {},\n      loaded: false,\n      id: resolved,\n    }\n\n    cache.set(resolved, module)\n    const fn = runInContext(\n      `(function(module,exports,require,__dirname,__filename) {${readFileSync(\n        resolved,\n        'utf-8'\n      )}\\n})`,\n      context\n    )\n\n    try {\n      fn(\n        module,\n        module.exports,\n        requireFn.bind(null, resolved),\n        dirname(resolved),\n        resolved\n      )\n    } finally {\n      cache.delete(resolved)\n    }\n    module.loaded = true\n    return module.exports\n  }\n}\n"]}