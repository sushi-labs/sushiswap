{"version":3,"file":"index.bundled.js","sources":["index.js"],"sourcesContent":["function string2ArrayBuffer(str) {\n    const buf = new ArrayBuffer(str.length);\n    const bufView = new Uint8Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\nfunction getDERfromPEM(pem) {\n    const pemB64 = pem\n        .trim()\n        .split(\"\\n\")\n        .slice(1, -1) // Remove the --- BEGIN / END PRIVATE KEY ---\n        .join(\"\");\n    const decoded = atob(pemB64);\n    return string2ArrayBuffer(decoded);\n}\nfunction getEncodedMessage(header, payload) {\n    return `${base64encodeJSON(header)}.${base64encodeJSON(payload)}`;\n}\nfunction base64encode(buffer) {\n    var binary = \"\";\n    var bytes = new Uint8Array(buffer);\n    var len = bytes.byteLength;\n    for (var i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return fromBase64(btoa(binary));\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction base64encodeJSON(obj) {\n    return fromBase64(btoa(JSON.stringify(obj)));\n}\n\nconst getToken = async ({ privateKey, payload }) => {\n    // WebCrypto only supports PKCS#8, unfortunately\n    if (/BEGIN RSA PRIVATE KEY/.test(privateKey)) {\n        throw new Error(\"[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#readme\");\n    }\n    const algorithm = {\n        name: \"RSASSA-PKCS1-v1_5\",\n        hash: { name: \"SHA-256\" }\n    };\n    const header = { alg: \"RS256\", typ: \"JWT\" };\n    const privateKeyDER = getDERfromPEM(privateKey);\n    const importedKey = await crypto.subtle.importKey(\"pkcs8\", privateKeyDER, algorithm, false, [\"sign\"]);\n    const encodedMessage = getEncodedMessage(header, payload);\n    const encodedMessageArrBuf = string2ArrayBuffer(encodedMessage);\n    const signatureArrBuf = await crypto.subtle.sign(algorithm.name, importedKey, encodedMessageArrBuf);\n    const encodedSignature = base64encode(signatureArrBuf);\n    return `${encodedMessage}.${encodedSignature}`;\n};\n\nasync function githubAppJwt({ id, privateKey, now = Math.floor(Date.now() / 1000), }) {\n    // When creating a JSON Web Token, it sets the \"issued at time\" (iat) to 30s\n    // in the past as we have seen people running situations where the GitHub API\n    // claimed the iat would be in future. It turned out the clocks on the\n    // different machine were not in sync.\n    const nowWithSafetyMargin = now - 30;\n    const expiration = nowWithSafetyMargin + 60 * 10; // JWT expiration time (10 minute maximum)\n    const payload = {\n        iat: nowWithSafetyMargin,\n        exp: expiration,\n        iss: id\n    };\n    const token = await getToken({\n        privateKey,\n        payload\n    });\n    return {\n        appId: id,\n        expiration,\n        token\n    };\n}\n\nexport { githubAppJwt };\n//# sourceMappingURL=index.js.map\n"],"names":["string2ArrayBuffer","str","buf","ArrayBuffer","length","bufView","Uint8Array","i","strLen","charCodeAt","fromBase64","base64","replace","base64encodeJSON","obj","btoa","JSON","stringify","pemB64","trim","split","slice","join","atob","header","payload","buffer","binary","bytes","len","byteLength","String","fromCharCode"],"mappings":"4TAAO,SAASA,EAAmBC,WACzBC,EAAM,IAAIC,YAAYF,EAAIG,QAC1BC,EAAU,IAAIC,WAAWJ,GACtBK,EAAI,EAAGC,EAASP,EAAIG,OAAQG,EAAIC,EAAQD,IAC7CF,EAAQE,GAAKN,EAAIQ,WAAWF,UAEzBL,EAuBX,SAASQ,EAAWC,UACTA,EACFC,QAAQ,KAAM,IACdA,QAAQ,MAAO,KACfA,QAAQ,MAAO,KAExB,SAASC,EAAiBC,UACfJ,EAAWK,KAAKC,KAAKC,UAAUH,0RA3BhCI,wDAAAA,IACDC,OACAC,MAAM,MACNC,MAAM,GAAI,GACVC,KAAK,IAEHtB,EADSuB,KAAKL,gEAGlB,SAA2BM,EAAQC,mBAC5BZ,EAAiBW,eAAWX,EAAiBY,yCAEpD,SAAsBC,WACrBC,EAAS,GACTC,EAAQ,IAAItB,WAAWoB,GACvBG,EAAMD,EAAME,WACPvB,EAAI,EAAGA,EAAIsB,EAAKtB,IACrBoB,GAAUI,OAAOC,aAAaJ,EAAMrB,WAEjCG,EAAWK,KAAKY"}