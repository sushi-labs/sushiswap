{"version":3,"names":["booleanLiteral","callExpression","cloneNode","directive","directiveLiteral","expressionStatement","identifier","isIdentifier","memberExpression","stringLiteral","valueToNode","variableDeclaration","variableDeclarator","rewriteModuleStatementsAndPrepareHeader","path","loose","exportName","strict","allowTopLevelThis","strictMode","noInterop","importInterop","lazy","esNamespaceOnly","filename","constantReexports","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","assert","isModule","node","sourceType","meta","normalizeModuleAndLoadMetadata","initializeReexports","rewriteThis","rewriteLiveReferences","hasStrict","directives","some","value","unshiftContainer","headers","hasExports","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","ensureStatementsHoisted","statements","forEach","header","_blockHoist","wrapInterop","programPath","expr","type","hub","addHelper","helper","Error","buildNamespaceInitStatements","metadata","sourceMetadata","srcNamespace","localName","importsNamespace","template","NAME","SOURCE","buildReexportsFromMeta","reexportNamespace","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","constantComputed","spec","namespace","stringSpecifiers","Array","from","reexports","importName","NAMESPACE_IMPORT","interop","has","astNodes","EXPORT_NAME","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","Object","create","data","local","values","names","hasReexport","source","keys","length","scope","generateUidIdentifier","default","initStatements","kind","buildInitStatement","reexportsStatements","i","sort","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","buildUndefinedNode","InitTemplate","computed","expression","exportNames","initExpr","reduce","acc","params","VALUE"],"sources":["../src/index.ts"],"sourcesContent":["import assert from \"assert\";\nimport {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport template from \"@babel/template\";\n\nimport { isModule } from \"@babel/helper-module-imports\";\n\nimport rewriteThis from \"./rewrite-this\";\nimport rewriteLiveReferences from \"./rewrite-live-references\";\nimport normalizeModuleAndLoadMetadata, {\n  hasExports,\n  isSideEffectImport,\n  validateImportInteropOption,\n} from \"./normalize-and-load-metadata\";\nimport type {\n  ImportInterop,\n  InteropType,\n  Lazy,\n  ModuleMetadata,\n  SourceModuleMetadata,\n} from \"./normalize-and-load-metadata\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport { default as getModuleName } from \"./get-module-name\";\nexport type { PluginOptions } from \"./get-module-name\";\n\nexport { hasExports, isSideEffectImport, isModule, rewriteThis };\n\nexport interface RewriteModuleStatementsAndPrepareHeaderOptions {\n  exportName?: string;\n  strict: boolean;\n  allowTopLevelThis?: boolean;\n  strictMode: boolean;\n  loose?: boolean;\n  importInterop?: ImportInterop;\n  noInterop?: boolean;\n  lazy?: Lazy;\n  esNamespaceOnly?: boolean;\n  filename: string | undefined;\n  constantReexports?: boolean | void;\n  enumerableModuleMeta?: boolean | void;\n  noIncompleteNsImportDetection?: boolean | void;\n}\n\n/**\n * Perform all of the generic ES6 module rewriting needed to handle initial\n * module processing. This function will rewrite the majority of the given\n * program to reference the modules described by the returned metadata,\n * and returns a list of statements for use when initializing the module.\n */\nexport function rewriteModuleStatementsAndPrepareHeader(\n  path: NodePath<t.Program>,\n  {\n    // TODO(Babel 8): Remove this\n    loose,\n\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    lazy,\n    esNamespaceOnly,\n    filename,\n\n    constantReexports = loose,\n    enumerableModuleMeta = loose,\n    noIncompleteNsImportDetection,\n  }: RewriteModuleStatementsAndPrepareHeaderOptions,\n) {\n  validateImportInteropOption(importInterop);\n  assert(isModule(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n\n  const meta = normalizeModuleAndLoadMetadata(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly,\n    filename,\n  });\n\n  if (!allowTopLevelThis) {\n    rewriteThis(path);\n  }\n\n  rewriteLiveReferences(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n    if (!hasStrict) {\n      path.unshiftContainer(\n        \"directives\",\n        directive(directiveLiteral(\"use strict\")),\n      );\n    }\n  }\n\n  const headers = [];\n  if (hasExports(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  // Create all of the statically known named exports.\n  headers.push(\n    ...buildExportInitializationStatements(\n      path,\n      meta,\n      constantReexports,\n      noIncompleteNsImportDetection,\n    ),\n  );\n\n  return { meta, headers };\n}\n\n/**\n * Flag a set of statements as hoisted above all else so that module init\n * statements all run before user code.\n */\nexport function ensureStatementsHoisted(statements: t.Statement[]) {\n  // Force all of the header fields to be at the top of the file.\n  statements.forEach(header => {\n    // @ts-expect-error Fixme: handle _blockHoist property\n    header._blockHoist = 3;\n  });\n}\n\n/**\n * Given an expression for a standard import object, like \"require('foo')\",\n * wrap it in a call to the interop helpers based on the type.\n */\nexport function wrapInterop(\n  programPath: NodePath,\n  expr: t.Expression,\n  type: InteropType,\n): t.CallExpression {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [\n      expr,\n      booleanLiteral(true),\n    ]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\n/**\n * Create the runtime initialization statements for a given requested source.\n * These will initialize all of the runtime import/export logic that\n * can't be handled statically by the statements created by\n * buildExportInitializationStatements().\n */\nexport function buildNamespaceInitStatements(\n  metadata: ModuleMetadata,\n  sourceMetadata: SourceModuleMetadata,\n  constantReexports: boolean | void = false,\n) {\n  const statements = [];\n\n  let srcNamespace: t.Node = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n\n    // Create and assign binding to namespace object\n    statements.push(\n      template.statement`var NAME = SOURCE;`({\n        NAME: localName,\n        SOURCE: cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    // Assign export to namespace object.\n    statements.push(\n      (sourceMetadata.lazy\n        ? template.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          `\n        : template.statement`EXPORTS.NAME = NAMESPACE;`)({\n        EXPORTS: metadata.exportName,\n        NAME: exportName,\n        NAMESPACE: cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(\n      metadata,\n      cloneNode(srcNamespace),\n      constantReexports,\n    );\n    statement.loc = sourceMetadata.reexportAll.loc;\n\n    // Iterate props creating getter for each prop.\n    statements.push(statement);\n  }\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: template.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: template.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `,\n};\n\nconst buildReexportsFromMeta = (\n  meta: ModuleMetadata,\n  metadata: SourceModuleMetadata,\n  constantReexports: boolean,\n) => {\n  const namespace = metadata.lazy\n    ? callExpression(identifier(metadata.name), [])\n    : identifier(metadata.name);\n\n  const { stringSpecifiers } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT: t.Expression = cloneNode(namespace);\n    if (importName === \"default\" && metadata.interop === \"node-default\") {\n      // Nothing, it's ok as-is\n    } else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        stringLiteral(importName),\n        true,\n      );\n    } else {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        identifier(importName),\n      );\n    }\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT,\n    };\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\n/**\n * Build an \"__esModule\" header statement setting the property on a given object.\n */\nfunction buildESModuleHeader(\n  metadata: ModuleMetadata,\n  enumerableModuleMeta: boolean | void = false,\n) {\n  return (\n    enumerableModuleMeta\n      ? template.statement`\n        EXPORTS.__esModule = true;\n      `\n      : template.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `\n  )({ EXPORTS: metadata.exportName });\n}\n\n/**\n * Create a re-export initialization loop for a specific imported namespace.\n */\nfunction buildNamespaceReexport(\n  metadata: ModuleMetadata,\n  namespace: t.Identifier | t.CallExpression,\n  constantReexports: boolean | void,\n) {\n  return (\n    constantReexports\n      ? template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      `\n      : // Also skip already assigned bindings if they are strictly equal\n        // to be somewhat more spec-compliant when a file has multiple\n        // namespace re-exports that would cause a binding to be exported\n        // multiple times. However, multiple bindings of the same name that\n        // export the same primitive value are silently skipped\n        // (the spec requires an \"ambigous bindings\" early error here).\n        template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `\n  )({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName\n      ? template`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({ EXPORTS_LIST: metadata.exportNameListName })\n      : null,\n  });\n}\n\n/**\n * Build a statement declaring a variable that contains all of the exported\n * variable names in an object so they can easily be referenced from an\n * export * from statement to check for conflicts.\n */\nfunction buildExportNameListDeclaration(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n) {\n  const exportedVars = Object.create(null);\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n\n  delete exportedVars.default;\n\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [\n      variableDeclarator(name, valueToNode(exportedVars)),\n    ]),\n  };\n}\n\n/**\n * Create a set of statements that will initialize all of the statically-known\n * export names with their expected values.\n */\nfunction buildExportInitializationStatements(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n  constantReexports: boolean | void = false,\n  noIncompleteNsImportDetection: boolean | void = false,\n) {\n  const initStatements: Array<[string, t.Statement | null]> = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {\n      // No-open since these are explicitly set with the \"reexports\" block.\n    } else if (data.kind === \"hoisted\") {\n      initStatements.push([\n        // data.names is always of length 1 because a hoisted export\n        // name must be id of a function declaration\n        data.names[0],\n        buildInitStatement(metadata, data.names, identifier(localName)),\n      ]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n  // The [Exports] list is ordered as if an Array of those String values\n  // had been sorted using %Array.prototype.sort% using undefined as comparefn\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n\n  const results = [];\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    // We generate init statements (`exports.a = exports.b = ... = void 0`)\n    // for every 100 exported names to avoid deeply-nested AST structures.\n    const chunkSize = 100;\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(\n              buildInitStatement(\n                metadata,\n                uninitializedExportNames,\n                programPath.scope.buildUndefinedNode(),\n              ),\n            );\n            // reset after uninitializedExportNames has been transformed\n            // to init statements\n            uninitializedExportNames = [];\n          }\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n      if (uninitializedExportNames.length > 0) {\n        results.push(\n          buildInitStatement(\n            metadata,\n            uninitializedExportNames,\n            programPath.scope.buildUndefinedNode(),\n          ),\n        );\n      }\n    }\n  }\n\n  return results;\n}\n\n/**\n * Given a set of export names, create a set of nested assignments to\n * initialize them all to a given expression.\n */\nconst InitTemplate = {\n  computed: template.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: template.expression`EXPORTS.NAME = VALUE`,\n};\n\nfunction buildInitStatement(\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  initExpr: t.Expression,\n) {\n  const { stringSpecifiers, exportName: EXPORTS } = metadata;\n  return expressionStatement(\n    exportNames.reduce((acc, exportName) => {\n      const params = {\n        EXPORTS,\n        NAME: exportName,\n        VALUE: acc,\n      };\n      if (stringSpecifiers.has(exportName)) {\n        return InitTemplate.computed(params);\n      } else {\n        return InitTemplate.default(params);\n      }\n    }, initExpr),\n  );\n}\n"],"mappings":"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"}