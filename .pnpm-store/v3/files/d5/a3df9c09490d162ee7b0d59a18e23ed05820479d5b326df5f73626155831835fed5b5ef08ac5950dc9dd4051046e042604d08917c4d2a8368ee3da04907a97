{"version":3,"names":["declare","api","options","assertVersion","iterableIsArray","assumption","loose","arrayLikeIsIterable","allowArrayLike","getSpreadLiteral","spread","scope","t","isIdentifier","argument","name","toArray","hasHole","elements","some","el","hasSpread","nodes","i","length","isSpreadElement","push","_props","arrayExpression","build","props","file","prop","spreadLiteral","isArrayExpression","callExpression","addHelper","visitor","ArrayExpression","path","node","first","replaceWith","shift","memberExpression","identifier","CallExpression","args","arguments","calleePath","skipTransparentExprWrappers","get","isSuper","buildCodeFrameError","contextLiteral","buildUndefinedNode","callee","isMemberExpression","temp","maybeGenerateMemoised","object","assignmentExpression","cloneNode","thisExpression","unshift","NewExpression","hub"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport type { File } from \"@babel/core\";\nimport { types as t } from \"@babel/core\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\n\ntype ListElement = t.SpreadElement | t.Expression;\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(7);\n\n  const iterableIsArray = api.assumption(\"iterableIsArray\") ?? options.loose;\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\");\n\n  function getSpreadLiteral(\n    spread: t.SpreadElement,\n    scope: Scope,\n  ): t.Expression {\n    if (\n      iterableIsArray &&\n      !t.isIdentifier(spread.argument, { name: \"arguments\" })\n    ) {\n      return spread.argument;\n    } else {\n      return scope.toArray(spread.argument, true, arrayLikeIsIterable);\n    }\n  }\n\n  function hasHole(spread: t.ArrayExpression): boolean {\n    return spread.elements.some(el => el === null);\n  }\n\n  function hasSpread(nodes: Array<t.Node>): boolean {\n    for (let i = 0; i < nodes.length; i++) {\n      if (t.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function push(_props: Array<ListElement>, nodes: Array<t.Expression>) {\n    if (!_props.length) return _props;\n    nodes.push(t.arrayExpression(_props));\n    return [];\n  }\n\n  function build(\n    props: Array<ListElement>,\n    scope: Scope,\n    file: File,\n  ): t.Expression[] {\n    const nodes: Array<t.Expression> = [];\n    let _props: Array<ListElement> = [];\n\n    for (const prop of props) {\n      if (t.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        let spreadLiteral = getSpreadLiteral(prop, scope);\n\n        if (t.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {\n          spreadLiteral = t.callExpression(\n            file.addHelper(\n              process.env.BABEL_8_BREAKING\n                ? \"arrayLikeToArray\"\n                : \"arrayWithoutHoles\",\n            ),\n            [spreadLiteral],\n          );\n        }\n\n        nodes.push(spreadLiteral);\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n\n    visitor: {\n      ArrayExpression(path): void {\n        const { node, scope } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n\n        const nodes = build(elements, scope, this.file);\n        let first = nodes[0];\n\n        // If there is only one element in the ArrayExpression and\n        // the element was transformed (Array.prototype.slice.call or toConsumableArray)\n        // we know that the transformed code already takes care of cloning the array.\n        // So we can simply return that element.\n        if (\n          nodes.length === 1 &&\n          first !== (elements[0] as t.SpreadElement).argument\n        ) {\n          path.replaceWith(first);\n          return;\n        }\n\n        // If the first element is a ArrayExpression we can directly call\n        // concat on it.\n        // `[..].concat(..)`\n        // If not then we have to use `[].concat(arr)` and not `arr.concat`\n        // because `arr` could be extended/modified (e.g. Immutable) and we do not know exactly\n        // what concat would produce.\n        if (!t.isArrayExpression(first)) {\n          first = t.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(first, t.identifier(\"concat\")),\n            nodes,\n          ),\n        );\n      },\n      CallExpression(path): void {\n        const { node, scope } = path;\n\n        const args = node.arguments as Array<ListElement>;\n        if (!hasSpread(args)) return;\n        const calleePath = skipTransparentExprWrappers(\n          path.get(\"callee\") as NodePath<t.Expression>,\n        );\n        if (calleePath.isSuper()) {\n          // NOTE: spread and classes have almost the same compat data, so this is very unlikely to happen in practice.\n          throw path.buildCodeFrameError(\n            \"It's not possible to compile spread arguments in `super()` without compiling classes.\\n\" +\n              \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n          );\n        }\n        let contextLiteral: t.Expression | t.Super = scope.buildUndefinedNode();\n        node.arguments = [];\n\n        let nodes: t.Expression[];\n        if (\n          args.length === 1 &&\n          t.isIdentifier((args[0] as t.SpreadElement).argument, {\n            name: \"arguments\",\n          })\n        ) {\n          nodes = [(args[0] as t.SpreadElement).argument];\n        } else {\n          nodes = build(args, scope, this.file);\n        }\n\n        const first = nodes.shift();\n        if (nodes.length) {\n          node.arguments.push(\n            t.callExpression(\n              t.memberExpression(first, t.identifier(\"concat\")),\n              nodes,\n            ),\n          );\n        } else {\n          node.arguments.push(first);\n        }\n\n        const callee = calleePath.node as t.MemberExpression;\n\n        if (t.isMemberExpression(callee)) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n          if (temp) {\n            callee.object = t.assignmentExpression(\n              \"=\",\n              temp,\n              // object must not be Super when `temp` is an identifier\n              callee.object as t.Expression,\n            );\n            contextLiteral = temp;\n          } else {\n            contextLiteral = t.cloneNode(callee.object);\n          }\n        }\n\n        // We use the original callee here, to preserve any types/parentheses\n        node.callee = t.memberExpression(\n          node.callee as t.Expression,\n          t.identifier(\"apply\"),\n        );\n        if (t.isSuper(contextLiteral)) {\n          contextLiteral = t.thisExpression();\n        }\n\n        node.arguments.unshift(t.cloneNode(contextLiteral));\n      },\n\n      NewExpression(path): void {\n        const { node, scope } = path;\n        if (!hasSpread(node.arguments)) return;\n\n        const nodes = build(\n          node.arguments as Array<ListElement>,\n          scope,\n          this.file,\n        );\n\n        const first = nodes.shift();\n\n        let args: t.Expression;\n        if (nodes.length) {\n          args = t.callExpression(\n            t.memberExpression(first, t.identifier(\"concat\")),\n            nodes,\n          );\n        } else {\n          args = first;\n        }\n\n        path.replaceWith(\n          t.callExpression(path.hub.addHelper(\"construct\"), [\n            node.callee as t.Expression,\n            args,\n          ]),\n        );\n      },\n    },\n  };\n});\n"],"mappings":"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"}