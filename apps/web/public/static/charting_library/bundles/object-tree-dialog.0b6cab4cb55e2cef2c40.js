;(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
  [4862],
  {
    81026: (e) => {
      e.exports = {
        container: 'container-WDZ0PRNh',
        'container-xxsmall': 'container-xxsmall-WDZ0PRNh',
        'container-xsmall': 'container-xsmall-WDZ0PRNh',
        'container-small': 'container-small-WDZ0PRNh',
        'container-medium': 'container-medium-WDZ0PRNh',
        'container-large': 'container-large-WDZ0PRNh',
        'intent-default': 'intent-default-WDZ0PRNh',
        focused: 'focused-WDZ0PRNh',
        readonly: 'readonly-WDZ0PRNh',
        disabled: 'disabled-WDZ0PRNh',
        'with-highlight': 'with-highlight-WDZ0PRNh',
        grouped: 'grouped-WDZ0PRNh',
        'adjust-position': 'adjust-position-WDZ0PRNh',
        'first-row': 'first-row-WDZ0PRNh',
        'first-col': 'first-col-WDZ0PRNh',
        stretch: 'stretch-WDZ0PRNh',
        'font-size-medium': 'font-size-medium-WDZ0PRNh',
        'font-size-large': 'font-size-large-WDZ0PRNh',
        'no-corner-top-left': 'no-corner-top-left-WDZ0PRNh',
        'no-corner-top-right': 'no-corner-top-right-WDZ0PRNh',
        'no-corner-bottom-right': 'no-corner-bottom-right-WDZ0PRNh',
        'no-corner-bottom-left': 'no-corner-bottom-left-WDZ0PRNh',
        'size-xxsmall': 'size-xxsmall-WDZ0PRNh',
        'size-xsmall': 'size-xsmall-WDZ0PRNh',
        'size-small': 'size-small-WDZ0PRNh',
        'size-medium': 'size-medium-WDZ0PRNh',
        'size-large': 'size-large-WDZ0PRNh',
        'intent-success': 'intent-success-WDZ0PRNh',
        'intent-warning': 'intent-warning-WDZ0PRNh',
        'intent-danger': 'intent-danger-WDZ0PRNh',
        'intent-primary': 'intent-primary-WDZ0PRNh',
        'border-none': 'border-none-WDZ0PRNh',
        'border-thin': 'border-thin-WDZ0PRNh',
        'border-thick': 'border-thick-WDZ0PRNh',
        highlight: 'highlight-WDZ0PRNh',
        shown: 'shown-WDZ0PRNh',
      }
    },
    7236: (e) => {
      e.exports = {
        'inner-slot': 'inner-slot-W53jtLjw',
        interactive: 'interactive-W53jtLjw',
        icon: 'icon-W53jtLjw',
        'inner-middle-slot': 'inner-middle-slot-W53jtLjw',
        'before-slot': 'before-slot-W53jtLjw',
        'after-slot': 'after-slot-W53jtLjw',
      }
    },
    30930: (e) => {
      e.exports = {
        input: 'input-RUSovanF',
        'size-xxsmall': 'size-xxsmall-RUSovanF',
        'size-xsmall': 'size-xsmall-RUSovanF',
        'size-small': 'size-small-RUSovanF',
        'size-medium': 'size-medium-RUSovanF',
        'size-large': 'size-large-RUSovanF',
        'with-start-slot': 'with-start-slot-RUSovanF',
        'with-end-slot': 'with-end-slot-RUSovanF',
      }
    },
    23490: (e) => {
      e.exports = {
        dropTargetInside: 'dropTargetInside-e_nPSSdZ',
        dropTarget: 'dropTarget-e_nPSSdZ',
        before: 'before-e_nPSSdZ',
        after: 'after-e_nPSSdZ',
      }
    },
    75564: (e) => {
      e.exports = {
        wrap: 'wrap-IEe5qpW4',
        selected: 'selected-IEe5qpW4',
        childOfSelected: 'childOfSelected-IEe5qpW4',
        disabled: 'disabled-IEe5qpW4',
        expandHandle: 'expandHandle-IEe5qpW4',
        expanded: 'expanded-IEe5qpW4',
      }
    },
    76106: (e) => {
      e.exports = {
        separator: 'separator-MgF6KBas',
        tree: 'tree-MgF6KBas',
        overlayScrollWrap: 'overlayScrollWrap-MgF6KBas',
        listContainer: 'listContainer-MgF6KBas',
      }
    },
    17742: (e) => {
      e.exports = {
        dialog: 'dialog-VUnQLSMH',
        buttons: 'buttons-VUnQLSMH',
        button: 'button-VUnQLSMH',
        disabled: 'disabled-VUnQLSMH',
      }
    },
    22813: (e) => {
      e.exports = {
        title: 'title-uNZ8yW1y',
        withoutIcon: 'withoutIcon-uNZ8yW1y',
        buttons: 'buttons-uNZ8yW1y',
        button: 'button-uNZ8yW1y',
        disabled: 'disabled-uNZ8yW1y',
        spacing: 'spacing-uNZ8yW1y',
        toolbar: 'toolbar-uNZ8yW1y',
      }
    },
    87769: (e) => {
      e.exports = {
        wrap: 'wrap-C8ln3wvp',
        dialog: 'dialog-C8ln3wvp',
        offset: 'offset-C8ln3wvp',
        title: 'title-C8ln3wvp',
        main: 'main-C8ln3wvp',
        disabled: 'disabled-C8ln3wvp',
        icon: 'icon-C8ln3wvp',
        pathIcon: 'pathIcon-C8ln3wvp',
        syncIconWrap: 'syncIconWrap-C8ln3wvp',
        syncIcon: 'syncIcon-C8ln3wvp',
        rightButtons: 'rightButtons-C8ln3wvp',
        hover: 'hover-C8ln3wvp',
        expandHandle: 'expandHandle-C8ln3wvp',
        button: 'button-C8ln3wvp',
        selected: 'selected-C8ln3wvp',
        childOfSelected: 'childOfSelected-C8ln3wvp',
        renameInput: 'renameInput-C8ln3wvp',
        warn: 'warn-C8ln3wvp',
        visible: 'visible-C8ln3wvp',
      }
    },
    6909: (e) => {
      e.exports = {
        wrap: 'wrap-ukH4sVzT',
        space: 'space-ukH4sVzT',
        tree: 'tree-ukH4sVzT',
      }
    },
    86928: (e) => {
      e.exports = {
        button: 'button-w6lVe_oI',
        hovered: 'hovered-w6lVe_oI',
        disabled: 'disabled-w6lVe_oI',
      }
    },
    27011: (e, t, n) => {
      function o(e, t) {
        return (
          t ||
          null == e ||
          (('string' == typeof e || Array.isArray(e)) && 0 === e.length)
        )
      }
      n.d(t, { isIconOnly: () => o })
    },
    86332: (e, t, n) => {
      n.d(t, { ControlGroupContext: () => o })
      const o = n(50959).createContext({
        isGrouped: !1,
        cellState: { isTop: !0, isRight: !0, isBottom: !0, isLeft: !0 },
      })
    },
    95604: (e, t, n) => {
      function o(e) {
        let t = 0
        return (
          (e.isTop && e.isLeft) || (t += 1),
          (e.isTop && e.isRight) || (t += 2),
          (e.isBottom && e.isLeft) || (t += 8),
          (e.isBottom && e.isRight) || (t += 4),
          t
        )
      }
      n.d(t, { getGroupCellRemoveRoundBorders: () => o })
    },
    67029: (e, t, n) => {
      n.d(t, { ControlSkeleton: () => b, InputClasses: () => g })
      var o = n(50959),
        r = n(97754),
        i = n(50151),
        s = n(38528),
        l = n(90186),
        a = n(86332),
        c = n(95604)
      var u = n(81026),
        d = n.n(u)
      function h(e) {
        let t = ''
        return (
          0 !== e &&
            (1 & e && (t = r(t, d()['no-corner-top-left'])),
            2 & e && (t = r(t, d()['no-corner-top-right'])),
            4 & e && (t = r(t, d()['no-corner-bottom-right'])),
            8 & e && (t = r(t, d()['no-corner-bottom-left']))),
          t
        )
      }
      function p(e, t, n, o) {
        const {
            removeRoundBorder: i,
            className: s,
            intent: l = 'default',
            borderStyle: a = 'thin',
            size: u,
            highlight: p,
            disabled: f,
            readonly: g,
            stretch: v,
            noReadonlyStyles: m,
            isFocused: b,
          } = e,
          _ = h(null != i ? i : (0, c.getGroupCellRemoveRoundBorders)(n))
        return r(
          d().container,
          d()[`container-${u}`],
          d()[`intent-${l}`],
          d()[`border-${a}`],
          u && d()[`size-${u}`],
          _,
          p && d()['with-highlight'],
          f && d().disabled,
          g && !m && d().readonly,
          b && d().focused,
          v && d().stretch,
          t && d().grouped,
          !o && d()['adjust-position'],
          n.isTop && d()['first-row'],
          n.isLeft && d()['first-col'],
          s,
        )
      }
      function f(e, t, n) {
        const { highlight: o, highlightRemoveRoundBorder: i } = e
        if (!o) return d().highlight
        const s = h(null != i ? i : (0, c.getGroupCellRemoveRoundBorders)(t))
        return r(d().highlight, d().shown, d()[`size-${n}`], s)
      }
      const g = {
          FontSizeMedium: (0, i.ensureDefined)(d()['font-size-medium']),
          FontSizeLarge: (0, i.ensureDefined)(d()['font-size-large']),
        },
        v = { passive: !1 }
      function m(e, t) {
        const {
            style: n,
            id: r,
            role: i,
            onFocus: c,
            onBlur: u,
            onMouseOver: d,
            onMouseOut: h,
            onMouseDown: g,
            onMouseUp: m,
            onKeyDown: b,
            onClick: _,
            tabIndex: S,
            startSlot: y,
            middleSlot: C,
            endSlot: T,
            onWheel: w,
            onWheelNoPassive: I = null,
            size: E,
          } = e,
          {
            isGrouped: M,
            cellState: D,
            disablePositionAdjustment: k = !1,
          } = (0, o.useContext)(a.ControlGroupContext),
          N = ((e, t = null, n) => {
            const r = (0, o.useRef)(null),
              i = (0, o.useRef)(null),
              s = (0, o.useCallback)(() => {
                if (null === r.current || null === i.current) return
                const [e, t, n] = i.current
                null !== t && r.current.addEventListener(e, t, n)
              }, []),
              l = (0, o.useCallback)(() => {
                if (null === r.current || null === i.current) return
                const [e, t, n] = i.current
                null !== t && r.current.removeEventListener(e, t, n)
              }, []),
              a = (0, o.useCallback)((e) => {
                l(), (r.current = e), s()
              }, [])
            return (
              (0, o.useEffect)(
                () => ((i.current = [e, t, n]), s(), l),
                [e, t, n],
              ),
              a
            )
          })('wheel', I, v)
        return o.createElement(
          'span',
          {
            style: n,
            id: r,
            role: i,
            className: p(e, M, D, k),
            tabIndex: S,
            ref: (0, s.useMergedRefs)([t, N]),
            onFocus: c,
            onBlur: u,
            onMouseOver: d,
            onMouseOut: h,
            onMouseDown: g,
            onMouseUp: m,
            onKeyDown: b,
            onClick: _,
            onWheel: w,
            ...(0, l.filterDataProps)(e),
            ...(0, l.filterAriaProps)(e),
          },
          y,
          C,
          T,
          o.createElement('span', { className: f(e, D, E) }),
        )
      }
      m.displayName = 'ControlSkeleton'
      const b = o.forwardRef(m)
    },
    78274: (e, t, n) => {
      n.d(t, {
        AfterSlot: () => u,
        EndSlot: () => c,
        MiddleSlot: () => a,
        StartSlot: () => l,
      })
      var o = n(50959),
        r = n(97754),
        i = n(7236),
        s = n.n(i)
      function l(e) {
        const {
          className: t,
          interactive: n = !0,
          icon: i = !1,
          children: l,
        } = e
        return o.createElement(
          'span',
          {
            className: r(
              s()['inner-slot'],
              n && s().interactive,
              i && s().icon,
              t,
            ),
          },
          l,
        )
      }
      function a(e) {
        const { className: t, children: n } = e
        return o.createElement(
          'span',
          { className: r(s()['inner-slot'], s()['inner-middle-slot'], t) },
          n,
        )
      }
      function c(e) {
        const {
          className: t,
          interactive: n = !0,
          icon: i = !1,
          children: l,
        } = e
        return o.createElement(
          'span',
          {
            className: r(
              s()['inner-slot'],
              n && s().interactive,
              i && s().icon,
              t,
            ),
          },
          l,
        )
      }
      function u(e) {
        const { className: t, children: n } = e
        return o.createElement(
          'span',
          { className: r(s()['after-slot'], t) },
          n,
        )
      }
    },
    31261: (e, t, n) => {
      n.d(t, { InputControl: () => b })
      var o = n(50959),
        r = n(97754),
        i = n(90186),
        s = n(47201),
        l = n(48907),
        a = n(38528),
        c = n(48027),
        u = n(29202),
        d = n(45812),
        h = n(67029),
        p = n(78274),
        f = n(30930),
        g = n.n(f)
      function v(e) {
        return !(0, i.isAriaAttribute)(e) && !(0, i.isDataAttribute)(e)
      }
      function m(e) {
        const {
            id: t,
            title: n,
            role: s,
            tabIndex: l,
            placeholder: a,
            name: c,
            type: u,
            value: d,
            defaultValue: f,
            draggable: m,
            autoComplete: b,
            autoFocus: _,
            maxLength: S,
            min: y,
            max: C,
            step: T,
            pattern: w,
            inputMode: I,
            onSelect: E,
            onFocus: M,
            onBlur: D,
            onKeyDown: k,
            onKeyUp: N,
            onKeyPress: L,
            onChange: x,
            onDragStart: A,
            size: R = 'small',
            className: j,
            inputClassName: O,
            disabled: B,
            readonly: P,
            containerTabIndex: z,
            startSlot: F,
            endSlot: W,
            reference: G,
            containerReference: H,
            onContainerFocus: V,
            ...U
          } = e,
          K = (0, i.filterProps)(U, v),
          Z = {
            ...(0, i.filterAriaProps)(U),
            ...(0, i.filterDataProps)(U),
            id: t,
            title: n,
            role: s,
            tabIndex: l,
            placeholder: a,
            name: c,
            type: u,
            value: d,
            defaultValue: f,
            draggable: m,
            autoComplete: b,
            autoFocus: _,
            maxLength: S,
            min: y,
            max: C,
            step: T,
            pattern: w,
            inputMode: I,
            onSelect: E,
            onFocus: M,
            onBlur: D,
            onKeyDown: k,
            onKeyUp: N,
            onKeyPress: L,
            onChange: x,
            onDragStart: A,
          }
        return o.createElement(h.ControlSkeleton, {
          ...K,
          disabled: B,
          readonly: P,
          tabIndex: z,
          className: r(g().container, j),
          size: R,
          ref: H,
          onFocus: V,
          startSlot: F,
          middleSlot: o.createElement(
            p.MiddleSlot,
            null,
            o.createElement('input', {
              ...Z,
              className: r(
                g().input,
                g()[`size-${R}`],
                O,
                F && g()['with-start-slot'],
                W && g()['with-end-slot'],
              ),
              disabled: B,
              readOnly: P,
              ref: G,
            }),
          ),
          endSlot: W,
        })
      }
      function b(e) {
        e = (0, c.useControl)(e)
        const {
            disabled: t,
            autoSelectOnFocus: n,
            tabIndex: r = 0,
            onFocus: i,
            onBlur: h,
            reference: p,
            containerReference: f = null,
          } = e,
          g = (0, o.useRef)(null),
          v = (0, o.useRef)(null),
          [b, _] = (0, u.useFocus)(),
          S = t ? void 0 : b ? -1 : r,
          y = t ? void 0 : b ? r : -1,
          {
            isMouseDown: C,
            handleMouseDown: T,
            handleMouseUp: w,
          } = (0, d.useIsMouseDown)(),
          I = (0, s.createSafeMulticastEventHandler)(
            _.onFocus,
            (e) => {
              n && !C.current && (0, l.selectAllContent)(e.currentTarget)
            },
            i,
          ),
          E = (0, s.createSafeMulticastEventHandler)(_.onBlur, h),
          M = (0, o.useCallback)(
            (e) => {
              ;(g.current = e),
                p &&
                  ('function' == typeof p && p(e),
                  'object' == typeof p && (p.current = e))
            },
            [g, p],
          )
        return o.createElement(m, {
          ...e,
          isFocused: b,
          containerTabIndex: S,
          tabIndex: y,
          onContainerFocus: (e) => {
            v.current === e.target && null !== g.current && g.current.focus()
          },
          onFocus: I,
          onBlur: E,
          reference: M,
          containerReference: (0, a.useMergedRefs)([v, f]),
          onMouseDown: T,
          onMouseUp: w,
        })
      }
    },
    48027: (e, t, n) => {
      n.d(t, { useControl: () => i })
      var o = n(47201),
        r = n(29202)
      function i(e) {
        const {
            onFocus: t,
            onBlur: n,
            intent: i,
            highlight: s,
            disabled: l,
          } = e,
          [a, c] = (0, r.useFocus)(void 0, l),
          u = (0, o.createSafeMulticastEventHandler)(l ? void 0 : c.onFocus, t),
          d = (0, o.createSafeMulticastEventHandler)(l ? void 0 : c.onBlur, n)
        return {
          ...e,
          intent: i || (a ? 'primary' : 'default'),
          highlight: null != s ? s : a,
          onFocus: u,
          onBlur: d,
        }
      }
    },
    29202: (e, t, n) => {
      n.d(t, { useFocus: () => r })
      var o = n(50959)
      function r(e, t) {
        const [n, r] = (0, o.useState)(!1)
        ;(0, o.useEffect)(() => {
          t && n && r(!1)
        }, [t, n])
        const i = {
          onFocus: (0, o.useCallback)(
            (t) => {
              ;(void 0 !== e && e.current !== t.target) || r(!0)
            },
            [e],
          ),
          onBlur: (0, o.useCallback)(
            (t) => {
              ;(void 0 !== e && e.current !== t.target) || r(!1)
            },
            [e],
          ),
        }
        return [n, i]
      }
    },
    125: (e, t, n) => {
      n.d(t, { useForceUpdate: () => r })
      var o = n(50959)
      const r = () => {
        const [, e] = (0, o.useReducer)((e) => e + 1, 0)
        return e
      }
    },
    76974: (e, t, n) => {
      n.d(t, { useIsMounted: () => r })
      var o = n(50959)
      const r = () => {
        const e = (0, o.useRef)(!1)
        return (
          (0, o.useEffect)(
            () => (
              (e.current = !0),
              () => {
                e.current = !1
              }
            ),
            [],
          ),
          e
        )
      }
    },
    45812: (e, t, n) => {
      n.d(t, { useIsMouseDown: () => r })
      var o = n(50959)
      function r() {
        const e = (0, o.useRef)(!1),
          t = (0, o.useCallback)(() => {
            e.current = !0
          }, [e]),
          n = (0, o.useCallback)(() => {
            e.current = !1
          }, [e])
        return { isMouseDown: e, handleMouseDown: t, handleMouseUp: n }
      }
    },
    38528: (e, t, n) => {
      n.d(t, { useMergedRefs: () => i })
      var o = n(50959),
        r = n(53017)
      function i(e) {
        return (0, o.useCallback)((0, r.mergeRefs)(e), e)
      }
    },
    48907: (e, t, n) => {
      function o(e) {
        null !== e && e.setSelectionRange(0, e.value.length)
      }
      n.d(t, { selectAllContent: () => o })
    },
    47201: (e, t, n) => {
      function o(...e) {
        return (t) => {
          for (const n of e) void 0 !== n && n(t)
        }
      }
      n.d(t, { createSafeMulticastEventHandler: () => o })
    },
    40104: (e, t, n) => {
      n.d(t, { retries: () => i, retriesWithDelays: () => s })
      var o = n(45884)
      async function r(e, t, n) {
        let o
        for (let r = 0; r < t; ++r)
          try {
            return await e(o)
          } catch (e) {
            ;(o = e), await n(r)
          }
        throw o
      }
      async function i(e, t) {
        return r(e, t, () => Promise.resolve())
      }
      async function s(e, t) {
        return r(e, t.length + 1, (e) =>
          e < t.length ? (0, o.delay)(null, t[e]) : Promise.resolve(),
        )
      }
    },
    37404: (e, t, n) => {
      n.d(t, { showManageDrawingsDialog: () => r })
      let o = null
      function r(e) {
        return Promise.all([
          n.e(4781),
          n.e(9465),
          n.e(7413),
          n.e(3263),
          n.e(1702),
        ])
          .then(n.bind(n, 41662))
          .then((t) => {
            const n = new (0, t.ManageDrawingsDialogRenderer)(e)
            return null !== o && o.hide(), n.show(), (o = n), n
          })
      }
    },
    56396: (e, t, n) => {
      n.r(t), n.d(t, { ObjectTreeDialogRenderer: () => ir })
      var o = n(50959),
        r = n(962),
        i = n(40104),
        s = n(59224)
      const l = (0, s.getLogger)('DataSourcesIcons')
      let a = null
      function c() {
        const e = n.c[57673]
        return e
          ? Promise.resolve(e.exports.lineToolsIcons)
          : n
              .e(1890)
              .then(n.bind(n, 57673))
              .then((e) => e.lineToolsIcons)
      }
      function u() {
        const e = n.c[45876]
        return e
          ? Promise.resolve(e.exports.SERIES_ICONS)
          : n
              .e(9685)
              .then(n.bind(n, 45876))
              .then((e) => e.SERIES_ICONS)
      }
      let d = null
      function h() {
        return (
          null === d &&
            (d = (() => {
              const e = (0, i.retries)(c, 2)
                  .then((e) => e)
                  .catch((e) => (l.logWarn(e), {})),
                t = (0, i.retries)(u, 2)
                  .then((e) => e)
                  .catch((e) => (l.logWarn(e), {}))
              return Promise.all([e, t])
            })()),
          d.then((e) => ((a = { linetool: e[0], series: e[1] }), a))
        )
      }
      var p = n(11542),
        f = n(97754),
        g = n.n(f),
        v = n(125),
        m = n(76974),
        b = n(41590),
        _ = n(37558),
        S = n(90692),
        y = n(35057),
        C = n(24437),
        T = n(23263),
        w = (n(37404), n(36349)),
        I = n(32563),
        E = n(68335),
        M = n(50151),
        D = n(9745),
        k = n(16396),
        N = n(50298),
        L = n(36947)
      const x = o.createContext(null)
      var A = n(48889),
        R = n(54079),
        j = n(16838),
        O = n(36296),
        B = n(74059),
        P = n(80465),
        z = n(22813),
        F = n(51768)
      function W(e) {
        const { hideTitle: t } = e,
          { viewModel: r } = (0, M.ensureNotNull)((0, o.useContext)(x)),
          i = (0, L.useForceUpdate)(),
          s = r.selection()
        ;(0, o.useEffect)(() => {
          const e = {}
          return (
            r.onChange().subscribe(e, () => i()),
            () => {
              r.onChange().unsubscribeAll(e)
            }
          )
        }, [r]),
          (0, o.useEffect)(() => {
            const e = {}
            return (
              s.onChange().subscribe(e, () => i()),
              () => {
                s.onChange().unsubscribeAll(e)
              }
            )
          }, [s]),
          (0, o.useEffect)(() => {
            ;(0, j.updateTabIndexes)()
          }, [])
        const l = !r.canSelectionBeUnmerged(),
          a = r.isSelectionCopiable(),
          c = r.isSelectionCloneable(),
          u = !a && !c,
          d = r.canSelectionBeGrouped(),
          h = !1
        return o.createElement(
          R.Toolbar,
          { orientation: 'horizontal', className: z.toolbar },
          !t &&
            o.createElement(
              'div',
              { className: f(z.title, z.withoutIcon) },
              p.t(null, void 0, n(31095)),
              h,
            ),
          o.createElement(
            'div',
            { className: z.buttons },
            o.createElement(A.ToolbarIconButton, {
              className: f(z.button, !d && z.disabled),
              icon: P,
              onClick: () => {
                r.createGroupFromSelection()
              },
              isDisabled: !d,
              tooltip: p.t(null, void 0, n(91073)),
              'data-name': 'group-button',
            }),
            o.createElement(
              N.ToolbarMenuButton,
              {
                className: f(z.button, u && z.disabled),
                isDisabled: u,
                content: o.createElement(D.Icon, { icon: O }),
                tooltip: p.t(null, void 0, n(98129)),
                arrow: !1,
                isShowTooltip: !0,
                'data-name': 'copy-clone-button',
              },
              a &&
                o.createElement(k.PopupMenuItem, {
                  'data-name': 'copy',
                  label: p.t(null, void 0, n(35216)),
                  onClick: () => {
                    r.copySelection()
                  },
                }),
              c &&
                o.createElement(k.PopupMenuItem, {
                  'data-name': 'clone',
                  label: p.t(null, void 0, n(52977)),
                  onClick: () => {
                    r.cloneSelection()
                  },
                }),
            ),
            o.createElement(
              N.ToolbarMenuButton,
              {
                className: f(z.button, l && z.disabled),
                isDisabled: l,
                content: o.createElement(D.Icon, { icon: B }),
                tooltip: p.t(null, void 0, n(45828)),
                arrow: !1,
                isShowTooltip: !0,
                'data-name': 'move-to-button',
              },
              o.createElement(k.PopupMenuItem, {
                'data-name': 'new-pane-above',
                label: p.t(null, void 0, n(40887)),
                onClick: () => {
                  r.unmergeSelectionUp()
                },
              }),
              o.createElement(k.PopupMenuItem, {
                'data-name': 'new-pane-below',
                label: p.t(null, void 0, n(96712)),
                onClick: () => {
                  r.unmergeSelectionDown()
                },
              }),
            ),
            t &&
              o.createElement(
                o.Fragment,
                null,
                o.createElement('div', { className: z.spacing }),
                o.createElement(A.ToolbarIconButton, {
                  className: z.button,
                  icon: manageDrawingsIcon,
                  tooltip: p.t(null, void 0, n(72357)),
                  'data-name': 'manage-drawings-button',
                  onClick: g,
                }),
              ),
          ),
        )
        function g() {
          h
        }
      }
      var G = n(54773),
        H = n(86942),
        V = n(10170),
        U = n(7809),
        K = n(23642)
      const Z = ((Y = 'OBJECT_TREE'), (e) => Y + '__' + e)
      var Y
      const $ = Z('SET_NODES'),
        q = Z('SYNC_NODES'),
        Q = Z('UPDATE_NODE'),
        X = Z('UPDATE_NODES'),
        J = Z('RESET_TREE'),
        ee = Z('SET_SELECTED_IDS'),
        te = Z('DROP_SELECTION'),
        ne = Z('SELECT_PREVIOUS'),
        oe = Z('SELECT_NEXT'),
        re = Z('MULTI_SELECT_PREVIOUS'),
        ie = Z('MULTI_SELECT_NEXT'),
        se = Z('PROCESS_DROP_TARGET'),
        le = Z('UPDATE_DROP_TARGET'),
        ae = Z('HIDE_DROP_TARGET'),
        ce = Z('START_MULTI_SELECT'),
        ue = Z('STOP_MULTI_SELECT'),
        de = (Z('REMOVE_NODE'), Z('SET_FOCUSED_NODE')),
        he = Z('SCROLL_TO_ID'),
        pe = Z('SET_IS_SELECTED'),
        fe = Z('SET_IS_EXPANDED'),
        ge = Z('SET_DISABLED_NODES'),
        ve = Z('MOVE_NODES'),
        me = (Z('START_DRAG'), Z('END_DRAG')),
        be = () => ({ type: ne }),
        _e = () => ({ type: oe }),
        Se = () => ({ type: re }),
        ye = () => ({ type: ie }),
        Ce = (e, t, n, o, r) => ({
          type: se,
          dropTarget: e,
          dropType: t,
          isHoveredLeft: n,
          boundBox: o,
          isLastChild: r,
        }),
        Te = () => ({ type: te }),
        we = (e) => ({ type: ee, ids: e }),
        Ie = (e, t, n) => ({ type: ve, ids: e, targetId: t, dropType: n }),
        Ee = () => ({ type: ce }),
        Me = () => ({ type: ue }),
        De = (e) => ({ type: de, nodeId: e }),
        ke = (e) => ({ type: he, nodeId: e }),
        Ne = (e, t, n = 0) => ({ type: pe, nodeId: e, isSelected: t, mode: n }),
        Le = (e, t) => ({ type: fe, nodeId: e, isExpanded: t }),
        xe = (e) => ({ type: ge, ids: e }),
        Ae = () => ({ type: me })
      var Re = n(77145)
      const je = (e) => e.nodes,
        Oe = (e) => e.selection,
        Be = (e) => e.dropTarget,
        Pe = (e) => e.expanded,
        ze = (e) => e.scrollToId,
        Fe = (e, t) => t,
        We = (0, Re.createSelector)([je, Fe], (e, t) => e[t]),
        Ge = (0, Re.createSelector)([Oe, Fe], (e, t) => e.ids.includes(t)),
        He = (0, Re.createSelector)([Pe, Fe], (e, t) => e.includes(t)),
        Ve = (0, Re.createSelector)(
          [(e) => e.disabled, Oe, Fe],
          (e, t, n) => !t.ids.includes(n) && e.includes(n),
        ),
        Ue = (0, Re.createSelector)(je, (e) => Object.keys(e)),
        Ke = (0, Re.createSelector)(Oe, ({ ids: e }) => e),
        Ze = (0, Re.createSelector)(Oe, ({ lastFocusedNodeId: e }) => e),
        Ye = (0, Re.createSelector)(Oe, ({ isMultiSelecting: e }) => e),
        $e = (0, Re.createSelector)([je, Ke], (e, t) => t.map((t) => e[t])),
        qe = (0, Re.createSelector)(je, (e) =>
          Object.values(e).filter((e) => 0 === e.level),
        ),
        Qe = (0, Re.createSelector)([je, qe], (e, t) =>
          t.reduce((t, n) => [...t, ...Xe(e, (0, M.ensureDefined)(n))], []),
        )
      function Xe(e, t) {
        const n = []
        for (const o of t.children) n.push(e[o]), n.push(...Xe(e, e[o]))
        return n
      }
      const Je = (0, Re.createSelector)([je, qe, Pe], (e, t, n) => {
          const o = new Set(n)
          return t.reduce(
            (t, n) => [...t, ...tt(e, (0, M.ensureDefined)(n), o)],
            [],
          )
        }),
        et = (0, Re.createSelector)([je, Ke, Pe], (e, t, n) => {
          const o = new Set(n)
          return [{ id: 'drag-list', level: -1, children: t }].reduce(
            (t, n) => [...t, ...tt(e, (0, M.ensureDefined)(n), o)],
            [],
          )
        })
      function tt(e, t, n) {
        const o = []
        for (const r of t.children) {
          const t = e[r]
          void 0 !== t && (o.push(t), n.has(r) && o.push(...tt(e, t, n)))
        }
        return o
      }
      function* nt(e) {
        const { selectedIds: t, nodes: n } = yield (0, w.call)(e),
          o = {}
        for (let e = 0; e < n.length; ++e) {
          const t = n[e]
          o[t.id] = t
        }
        yield (0, w.put)(((e) => ({ type: $, nodes: e }))(o)),
          yield (0, w.put)(we(t))
        !Ze(yield (0, w.select)()) &&
          t.length > 0 &&
          (yield (0, w.put)(De(t[0])), yield (0, w.put)(ke(t[0])))
      }
      function* ot(e) {
        for (;;) {
          if ((yield (0, w.take)([ce, ue])).type === ce) {
            const t = Ue(yield (0, w.select)()).filter((t) => !e(t))
            yield (0, w.put)(xe(t))
          } else yield (0, w.put)(xe([]))
        }
      }
      function* rt() {
        for (;;) {
          const { type: e } = yield (0, w.take)([ie, re]),
            t = yield (0, w.select)(),
            n = Qe(t),
            o = n.length,
            r = Ze(t),
            i = [...Ke(t)],
            s = 1 === i.length && i[0] !== r,
            l = n.findIndex((e) => e.id === (s ? i[0] : r))
          if ((e === re && 0 === l) || (e === ie && l === o - 1)) continue
          const a = dt(t, e === ie ? 'next' : 'previous', n, l),
            { id: c } = a
          i.includes(c) && r
            ? (yield (0, w.put)(Ne(r, !1, 1)), yield (0, w.put)(De(c)))
            : yield (0, w.put)(Ne(c, !0, 1)),
            yield (0, w.put)(ke(c))
        }
      }
      function* it(e, t) {
        for (;;) {
          const { type: n } = yield (0, w.take)([oe, ne]),
            o = yield (0, w.select)(),
            r = Qe(o),
            i = $e(o),
            s = Ze(o)
          if (1 === i.length && i[0].id !== s && !s) {
            if (n === oe) {
              yield (0, w.put)(De(i[0].id))
              continue
            }
            if (n === ne) {
              const e = r.findIndex((e) => e.id === i[0].id),
                t = dt(o, 'previous', r, e)
              yield (0, w.put)(De(t.id))
              continue
            }
          }
          const l = r.findIndex((e) => e.id === s),
            a = n === oe ? 'next' : 'previous',
            c = dt(o, a, r, l),
            { id: u } = c
          e ? e([u], a) : yield (0, w.put)(we([u])),
            t && t(u),
            yield (0, w.put)(De(u))
        }
      }
      function* st(e, t = () => !0) {
        for (;;) {
          const { mode: n, nodeId: o, isSelected: r } = yield (0, w.take)(pe)
          let i = [...Ke(yield (0, w.select)())]
          const s = Qe(yield (0, w.select)())
          if (1 === n) r ? i.push(o) : i.splice(i.indexOf(o), 1)
          else if (2 === n && i.length > 0) {
            const e = Ze(yield (0, w.select)())
            let n = s.findIndex((t) => t.id === e)
            ;-1 === n &&
              (n = s.reduce((e, t, n) => (i.includes(t.id) ? n : e), -1))
            const r = s.findIndex((e) => e.id === o)
            if (n !== r)
              for (let e = Math.min(n, r); e <= Math.max(n, r); e++) {
                const n = s[e].id
                !i.includes(n) && t(n) && i.push(n)
              }
          } else i = o ? [o] : []
          const l = new Set(i)
          ;(i = s.reduce((e, t) => (l.has(t.id) && e.push(t.id), e), [])),
            e ? e(i) : yield (0, w.put)(we(i)),
            yield (0, w.put)(De(o))
        }
      }
      function* lt(e = () => !0, t) {
        const {
            dropTarget: n,
            dropType: o,
            isHoveredLeft: r,
            boundBox: i,
            isLastChild: s,
          } = t,
          l = Be(yield (0, w.select)()),
          a = We(yield (0, w.select)(), (0, M.ensureDefined)(n.parentId)),
          c = s && 'after' === o,
          u = $e(yield (0, w.select)()),
          d = !c || (!r && e(u, n, o)) ? n : a,
          h = (l.node && l.node.id !== d.id) || l.dropType !== o
        u.map((e) => e.id).includes(d.id)
          ? yield (0, w.put)({ type: ae })
          : h &&
            e(u, d, o) &&
            (yield (0, w.put)(
              ((e, t, n) => ({ type: le, node: e, dropType: t, boundBox: n }))(
                d,
                o,
                i,
              ),
            ))
      }
      function* at(e) {
        yield (0, w.throttle)(0, se, lt, e)
      }
      function* ct(e) {
        for (;;) {
          yield (0, w.take)(te)
          const t = $e(yield (0, w.select)()),
            { node: n, dropType: o } = Be(yield (0, w.select)())
          if (n && o) {
            const r = new CustomEvent('tree-node-drop', {
              detail: { nodes: t, target: n.id, type: o },
            })
            if ((e && e(r), !r.defaultPrevented)) {
              const e = Ke(yield (0, w.select)())
              yield (0, w.put)(Ie(e, n.id, o))
            }
          }
        }
      }
      function* ut(e) {
        for (;;) {
          yield (0, w.take)(ve)
          e(je(yield (0, w.select)()))
        }
      }
      function dt(e, t, n, o) {
        const r = n.length
        let i
        ;-1 === o && 'previous' === t && (o = r)
        let s = 0
        while (
          !i ||
          (Math.abs(s) < r &&
            (l = i).level > 1 &&
            !He(e, (0, M.ensureDefined)(l.parentId)))
        )
          (s += 'next' === t ? 1 : -1), (i = n[(o + s + r) % r])
        var l
        return i
      }
      function* ht(e = {}) {
        const {
            saga: t,
            onDrop: n,
            canMove: o,
            onMove: r,
            onSelect: i,
            onKeyboardSelect: s,
            initState: l,
            canBeAddedToSelection: a,
          } = e,
          c = [
            (0, w.fork)(at, o),
            (0, w.fork)(ct, n),
            (0, w.fork)(st, i, a),
            (0, w.fork)(it, i, s),
            (0, w.fork)(rt),
          ]
        for (
          t && c.push((0, w.fork)(t)),
            r && c.push((0, w.fork)(ut, r)),
            a && c.push((0, w.fork)(ot, a));
          ;
        ) {
          l && (yield (0, w.call)(nt, l))
          const e = yield (0, w.all)(c)
          yield (0, w.take)(J)
          for (const t of e) yield (0, w.cancel)(t)
        }
      }
      var pt = n(91622),
        ft = n(1722)
      const gt = (0, s.getLogger)('Platform.GUI.ObjectTree.CallApi')
      const vt = { ids: [], lastFocusedNodeId: void 0, isMultiSelecting: !1 }
      const mt = { node: void 0, dropType: void 0, boundBox: void 0 }
      const bt = (0, pt.combineReducers)({
        nodes: (e = {}, t) => {
          switch (t.type) {
            case $:
              return t.nodes
            case q: {
              const { nodes: n } = t,
                o = n.map((e) => e.id),
                r = { ...e }
              for (const t of Object.keys(e))
                if (!o.includes(t)) {
                  const { parentId: e } = r[t]
                  e &&
                    (r[e] = {
                      ...r[e],
                      children: r[e].children.filter((e) => e !== t),
                    }),
                    delete r[t]
                }
              for (const e of n) {
                const t = e.id
                if (Object.hasOwn(r, t)) {
                  !(0, ft.deepEquals)(r[t].children, e.children)[0] &&
                    (r[t] = { ...r[t], children: [...e.children] })
                } else {
                  r[t] = e
                  const { parentId: n } = e
                  if (n && !r[n].children.includes(t))
                    throw new Error('Not implemented')
                }
              }
              return r
            }
            case Q: {
              const { type: n, nodeId: o, ...r } = t
              return { ...e, [o]: { ...e[o], ...r } }
            }
            case X: {
              const { nodes: n } = t,
                o = { ...e }
              return (
                Object.keys(n).forEach((e) => {
                  o[e] = { ...o[e], ...n[e] }
                }),
                { ...e, ...o }
              )
            }
            case ve: {
              const { ids: n, targetId: o, dropType: r } = t,
                i = (0, M.ensureDefined)(e[o].parentId),
                s = e[i],
                l = {}
              for (const t of n) {
                const n = e[t]
                if (n.parentId) {
                  const o = l[n.parentId] || e[n.parentId]
                  l[n.parentId] = {
                    ...o,
                    children: o.children.filter((e) => e !== t),
                  }
                }
                l[t] = { ...n, parentId: i, level: s.level + 1 }
              }
              const a = s.children.filter((e) => !n.includes(e))
              return (
                a.splice(
                  ((e, t, n) => {
                    switch (n) {
                      case 'before':
                        return e.indexOf((0, M.ensureDefined)(t))
                      case 'inside':
                        return e.length
                      case 'after':
                        return e.indexOf((0, M.ensureDefined)(t)) + 1
                      default:
                        return 0
                    }
                  })(a, o, r),
                  0,
                  ...n,
                ),
                (l[i] = { ...e[i], children: a, isExpanded: !0 }),
                { ...e, ...l }
              )
            }
            default:
              return e
          }
        },
        selection: (e = vt, t) => {
          switch (t.type) {
            case ee: {
              const { ids: n } = t
              return {
                ...e,
                ids: n,
                lastFocusedNodeId: n.length > 0 ? e.lastFocusedNodeId : void 0,
              }
            }
            case ce:
              return { ...e, isMultiSelecting: !0 }
            case ue:
              return { ...e, isMultiSelecting: !1 }
            case de:
              return { ...e, lastFocusedNodeId: t.nodeId }
            case q: {
              const n = new Set(t.nodes.map((e) => e.id))
              return (
                e.lastFocusedNodeId &&
                  !n.has(e.lastFocusedNodeId) &&
                  delete e.lastFocusedNodeId,
                { ...e, ids: e.ids.filter((e) => n.has(e)) }
              )
            }
            default:
              return e
          }
        },
        dropTarget: (e = mt, t) => {
          switch (t.type) {
            case le: {
              const { node: n, dropType: o, boundBox: r } = t
              return { ...e, node: n, dropType: o, boundBox: r }
            }
            case ae:
            case me:
            case J:
              return { ...mt }
            default:
              return e
          }
        },
        expanded: (e = [], t) => {
          if (t.type === fe) {
            const { nodeId: n, isExpanded: o } = t
            if (o) return [...e, n]
            const r = [...e]
            return r.splice(e.indexOf(n), 1), r
          }
          return e
        },
        disabled: (e = [], t) => (t.type === ge ? [...t.ids] : e),
        scrollToId: (e = null, t) =>
          t.type === he ? (null === t.nodeId ? null : { id: t.nodeId }) : e,
      })
      var _t = n(40933),
        St = n(20037),
        yt = n(49483)
      var Ct = n(42357),
        Tt = n(98314),
        wt = n(47201),
        It = n(70412)
      const Et = o.createContext({ size: 0, smallSizeTreeNodeAction: 1 }),
        Mt = { [E.Modifiers.Mod]: 1, [E.Modifiers.Shift]: 2 }
      var Dt = n(69533),
        kt = n(75564)
      const Nt = () => {}
      class Lt extends o.PureComponent {
        constructor() {
          super(...arguments),
            (this._ref = null),
            (this._handleRef = (e) => {
              this._ref = e
              const {
                connectDragSource: t,
                connectDropTarget: n,
                connectDragPreview: o,
              } = this.props
              ;(0, M.ensureDefined)(n)(this._ref),
                (0, M.ensureDefined)(t)(this._ref),
                (0, M.ensureDefined)(o)((0, Tt.getEmptyImage)(), {
                  captureDraggingState: !0,
                })
            }),
            (this._handleTouchStart = (e) => {
              const t = (e, t) => {
                  const n = ((e, t) => {
                    try {
                      const n = document.createEvent('TouchEvent')
                      return (
                        n.initTouchEvent(
                          e,
                          !0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          void 0,
                          t.touches,
                          t.targetTouches,
                          t.changedTouches,
                        ),
                        n
                      )
                    } catch (e) {
                      return null
                    }
                  })(e, t)
                  if (n) return n
                  const o = Array.from(t.changedTouches),
                    r = Array.from(t.touches),
                    i = Array.from(t.targetTouches)
                  return new TouchEvent(e, {
                    bubbles: !0,
                    changedTouches: o,
                    touches: r,
                    targetTouches: i,
                  })
                },
                n = e.target
              if (n instanceof Element) {
                const e = (e) => {
                    const o = e
                    if (!n.isConnected) {
                      o.preventDefault()
                      const e = t('touchmove', o)
                      document.body.dispatchEvent(e)
                    }
                  },
                  o = (r) => {
                    const i = r
                    if (!n.isConnected) {
                      i.preventDefault()
                      const e = t('touchend', i)
                      document.body.dispatchEvent(e)
                    }
                    n.removeEventListener('touchend', o),
                      n.removeEventListener('touchmove', e)
                  }
                n.addEventListener('touchend', o),
                  n.addEventListener('touchmove', e)
              }
            })
        }
        componentDidMount() {
          var e
          null === (e = this._ref) ||
            void 0 === e ||
            e.addEventListener('touchstart', this._handleTouchStart)
        }
        componentWillUnmount() {
          var e
          null === (e = this._ref) ||
            void 0 === e ||
            e.removeEventListener('touchstart', this._handleTouchStart)
        }
        render() {
          return o.createElement(xt, {
            ...this.props,
            reference: this._handleRef,
          })
        }
        getNode() {
          return (0, M.ensureNotNull)(this._ref)
        }
      }
      const xt = (e) => {
          const {
              id: t,
              isSelected: n,
              isOffset: r,
              isExpandable: i,
              setIsSelected: s,
              isDisabled: l,
              isExpanded: a,
              onClick: c,
              parentId: u,
              setIsExpanded: d,
              reference: h,
              isFirstListItem: p,
              isLastListItem: g,
              nodeRenderer: v,
              isChildOfSelected: m = !1,
            } = e,
            { size: b, smallSizeTreeNodeAction: _ } = (0, o.useContext)(Et),
            S = (0, o.useRef)(null),
            y = (0, wt.createSafeMulticastEventHandler)(
              (e) => (S.current = e),
              h,
            )
          let [C, T] = (0, It.useHover)()
          return (
            (yt.CheckMobile.any() || yt.CheckMobile.isIPad()) &&
              ((C = n), (T = { onMouseOut: Nt, onMouseOver: Nt })),
            o.createElement(
              'div',
              {
                className: f(
                  kt.wrap,
                  n && kt.selected,
                  m && kt.childOfSelected,
                  l && kt.disabled,
                  i && kt.expandable,
                ),
                onClick:
                  1 === b && 0 === _
                    ? w
                    : (e) => {
                        if (e.defaultPrevented) return
                        const o = Mt[(0, E.modifiersFromEvent)(e)] || 0
                        !l && s && s(t, !n, o)
                        c && 0 === o && c(e, t)
                      },
                onContextMenu: w,
                ref: y,
                ...T,
              },
              i &&
                o.createElement(D.Icon, {
                  icon: Dt,
                  className: f(kt.expandHandle, a && kt.expanded),
                  onClick: (e) => {
                    e.preventDefault(), i && d(t, !a)
                  },
                  onMouseDown: (e) => {
                    e.preventDefault()
                  },
                }),
              v({
                id: t,
                isOffset: r,
                parentId: u,
                isDisabled: l,
                isSelected: n,
                isChildOfSelected: m,
                isHovered: C,
                isExpanded: a,
                isFirstListItem: p,
                isLastListItem: g,
              }),
            )
          )
          function w() {
            l || n || !s || s(t, !0)
          }
        },
        At = o.createContext({})
      function Rt(e, t) {
        const { id: n } = t,
          o = We(e, n),
          r = Ge(e, n)
        let i = !1,
          s = o.parentId
        while (s && !i) (i = Ge(e, s)), (s = We(e, s).parentId)
        return {
          ...o,
          isSelected: r,
          isChildOfSelected: i,
          isExpanded: o.children.length > 0 && He(e, n),
          isExpandable: o.children.length > 0,
          isDisabled: Ve(e, n),
        }
      }
      function jt(e) {
        return (0, pt.bindActionCreators)(
          {
            setIsExpanded: Le,
            processDropTarget: Ce,
            dropSelection: Te,
            selectNext: _e,
            selectPrevious: be,
            setIsSelected: Ne,
            endDrag: Ae,
          },
          e,
        )
      }
      const Ot = (0, H.connect)(Rt, jt, null, { context: At })((e) => {
          const t = (0, o.useRef)(null),
            [, n, r] = (0, Ct.useDrag)({
              type: 'node',
              item: (t) => {
                const { id: n, isDisabled: o, isSelected: r } = e
                return o || r || e.setIsSelected(n, !0), e
              },
              end: (e) => {
                e.endDrag()
              },
            }),
            [, i] = (0, _t.useDrop)({
              accept: 'node',
              hover: (n, o) => {
                const r = t.current
                if (!r) return
                const i = r.getNode(),
                  s = i.getBoundingClientRect(),
                  l = s.bottom - s.top,
                  a = o.getClientOffset()
                if (a) {
                  const t = a.y - s.top
                  let n, o
                  if (
                    ((n =
                      0 === e.children.length
                        ? t < l / 2
                          ? 'before'
                          : 'after'
                        : t < l / 3
                          ? 'before'
                          : e.isExpanded || (t >= l / 3 && t < (2 * l) / 3)
                            ? 'inside'
                            : 'after'),
                    void 0 !== e.getContainerElement)
                  ) {
                    const t = e.getContainerElement().getBoundingClientRect()
                    o = {
                      top: s.top - t.top,
                      left: s.left - t.left,
                      bottom: s.top - t.top + s.height,
                      right: s.left - t.left + s.width,
                      height: s.height,
                      width: s.width,
                    }
                  } else
                    o = {
                      top: i.offsetTop,
                      left: i.offsetLeft,
                      bottom: i.offsetTop + i.offsetHeight,
                      right: i.offsetLeft + i.offsetWidth,
                      height: i.offsetHeight,
                      width: i.offsetWidth,
                    }
                  e.processDropTarget(e, n, a.x - s.left < 48, o, e.isLastChild)
                }
              },
            })
          return o.createElement(Lt, {
            ...e,
            connectDragSource: n,
            connectDropTarget: i,
            connectDragPreview: r,
            ref: t,
          })
        }),
        Bt = (0, H.connect)(Rt, jt, null, { context: At })(xt)
      var Pt = n(35749),
        zt = n(85783),
        Ft = n(42842)
      function Wt(e) {
        const t = e(),
          n = (0, o.useRef)(t)
        n.current = t
        const [r, i] = (0, o.useState)(n.current),
          s = (0, o.useRef)(null)
        return (
          (0, o.useEffect)(() => {
            null === s.current &&
              (s.current = requestAnimationFrame(() => {
                ;(s.current = null), i(n.current)
              }))
          }),
          (0, o.useEffect)(
            () => () => {
              s.current && cancelAnimationFrame(s.current)
            },
            [],
          ),
          r
        )
      }
      function Gt(e) {
        const { dropTargetOffset: t, mousePosition: n } = e
        if (!t) return { display: 'none' }
        const { x: o, y: r } = t,
          i = n && t ? n.y - t.y : 0,
          s = `translate(${o + (n && t ? n.x - t.x : 0)}px, ${r + i}px)`
        return { transform: s, WebkitTransform: s }
      }
      const Ht = {
        top: 0,
        left: 0,
        position: 'fixed',
        pointerEvents: 'none',
        zIndex: 100,
        opacity: 0.5,
        width: 300,
        backgroundColor: 'red',
      }
      function Vt(e) {
        return {
          isDragging: e.isDragging() && 'node' === e.getItemType(),
          mousePosition: e.getClientOffset(),
          dropTargetOffset: e.getSourceClientOffset(),
        }
      }
      const Ut = (0, H.connect)((e) => ({ items: et(e) }), null, null, {
        context: At,
      })((e) => {
        const {
          items: t,
          isDragging: n,
          nodeRenderer: r,
          dragPreviewRenderer: i,
        } = e
        return Wt(() =>
          n
            ? o.createElement(
                Ft.Portal,
                null,
                o.createElement(
                  'div',
                  { style: { ...Ht, ...Gt(e) } },
                  t.map((e) => {
                    if (i) {
                      const t = i
                      return o.createElement(t, { key: e.id, ...e })
                    }
                    return o.createElement(Bt, {
                      id: e.id,
                      key: e.id,
                      nodeRenderer: r,
                      isDragPreview: !0,
                      isOffset: e.level > 1,
                    })
                  }),
                ),
              )
            : null,
        )
      })
      function Kt(e) {
        return o.createElement(Ut, { ...e, ...(0, zt.useDragLayer)(Vt) })
      }
      var Zt = n(3085),
        Yt = n(33127)
      const $t = o.forwardRef((e, t) => {
        const n = (0, o.useRef)(null)
        return (
          e.connectDropTarget(n),
          (0, o.useImperativeHandle)(
            t,
            () => ({ getNode: () => (0, M.ensureNotNull)(n.current) }),
            [],
          ),
          o.createElement('div', {
            ref: n,
            style: { height: '100%', width: '100%' },
          })
        )
      })
      function qt(e) {
        const t = (0, o.useRef)(null),
          [, n] = (0, _t.useDrop)({
            accept: 'node',
            hover: (n, o) => {
              if (!t.current) return
              const r = o.getClientOffset()
              if (null === r) return
              const i = e.getOrderedNodes()
              if (0 === i.length) return
              const s = t.current.getNode().getBoundingClientRect(),
                l = e.getContainerElement().getBoundingClientRect()
              if ('first' === e.type) {
                const t = {
                  top: s.top - l.top + s.height,
                  left: s.left - l.left,
                  bottom: s.top - l.top + s.height,
                  right: s.left - l.left + s.width,
                  height: 0,
                  width: s.width,
                }
                e.processDropTarget(i[0], 'before', !1, t, !1)
              }
              if ('last' === e.type) {
                const t = r.x - s.left < 48,
                  n = i[i.length - 1],
                  o =
                    t && 2 === n.level
                      ? (0, M.ensureDefined)(i.find((e) => e.id === n.parentId))
                      : n,
                  a = {
                    top: s.top - l.top,
                    left: s.left - l.left,
                    bottom: s.top - l.top,
                    right: s.left - l.left + s.width,
                    height: s.height,
                    width: s.width,
                  }
                e.processDropTarget(o, 'after', t, a, !1)
              }
            },
          })
        return o.createElement($t, { ...e, connectDropTarget: n, ref: t })
      }
      const Qt = o.createContext({ isOver: !1, transform: void 0 })
      var Xt = n(23490)
      function Jt(e) {
        const { dropType: t, boundBox: n } = e,
          { top: o, bottom: r, left: i } = (0, M.ensureDefined)(n)
        return [i, 'before' === t || 'inside' === t ? o : r]
      }
      function en(e) {
        return { isDragging: e.isDragging() }
      }
      const tn = (0, H.connect)(
        (e) => {
          const { boundBox: t, dropType: n, node: o } = Be(e)
          return { boundBox: t, dropType: n, level: o ? o.level : void 0 }
        },
        null,
        null,
        { context: At },
      )((e) => {
        const {
          dropType: t,
          boundBox: n,
          isDragging: r,
          level: i,
          transform: s = Jt,
        } = e
        return Wt(() => {
          if (!r || !t || !n) return null
          const l = {
              [Xt.dropTarget]: 'inside' !== t,
              [Xt.dropTargetInside]: 'inside' === t,
            },
            { width: a, height: c } = n,
            [u, d] = s(e),
            h = `translate(${u}px, ${d}px)`
          return o.createElement('div', {
            className: f(l),
            style: {
              position: 'absolute',
              transform: h,
              WebkitTransform: h,
              top: 0,
              left: 2 === i ? '46px' : 0,
              width: 2 === i ? a - 46 + 'px' : a,
              height: 'inside' === t ? c : '2px',
            },
          })
        })
      })
      function nn(e) {
        const { isDragging: t } = (0, zt.useDragLayer)(en)
        return o.createElement(tn, { ...e, isDragging: t })
      }
      const on = o.forwardRef((e, t) => {
        const n = (0, o.useContext)(Qt)
        return o.createElement(
          'div',
          { ...e, ref: t },
          e.children,
          n.isOver && o.createElement(nn, { transform: n.transform }),
        )
      })
      var rn = n(38223),
        sn = n(76106)
      const ln = 38 + E.Modifiers.Shift,
        an = 40 + E.Modifiers.Shift
      const cn = o.forwardRef((e, t) => {
        const {
            navigationKeys: n,
            renderList: r,
            stopMultiSelect: i,
            startMultiSelect: s,
            isMultiSelecting: l,
            nodeRenderer: a,
            dragPreviewRenderer: c,
            className: u,
            connectDropTarget: d,
            readOnly: h,
            onClick: p,
            dropLayerTransform: f,
            setFocusedNode: v,
            scrollToId: m,
            rowHeight: b,
            onMultiSelectPrevious: _,
            onMultiSelectNext: S,
            onMoveCursorToNext: y,
            onMoveCursorToPrevious: C,
            onKeyDown: T,
            outerRef: w,
            width: I,
            height: D,
            isOver: k,
            processDropTarget: N,
            autofocus: L,
          } = e,
          A = (0, o.useContext)(x),
          R = (0, o.useRef)(null)
        ;(0, o.useEffect)(() => {
          var e
          L && (null === (e = R.current) || void 0 === e || e.focus())
        }, []),
          (0, o.useEffect)(() => {
            const e = (e) => {
                ;[E.Modifiers.Mod, E.Modifiers.Shift].includes(
                  (0, E.modifiersFromEvent)(e),
                ) && s()
              },
              t = (e) => {
                l &&
                  ![E.Modifiers.Mod, E.Modifiers.Shift].includes(
                    (0, E.modifiersFromEvent)(e),
                  ) &&
                  i()
              }
            return (
              document.addEventListener('keydown', e),
              document.addEventListener('keyup', t),
              document.addEventListener('mousemove', t),
              () => {
                document.removeEventListener('keydown', e),
                  document.removeEventListener('keyup', t),
                  document.removeEventListener('mousemove', t)
              }
            )
          }, [l]),
          ((e) => {
            ;(0, o.useEffect)(() => {
              if (yt.isEdge) {
                let t = null
                const n = (0, M.ensureNotNull)(e.current),
                  o = (e) => {
                    if (e.target instanceof Element) {
                      const n = (0, M.ensureNotNull)(
                        e.target.closest('[draggable]'),
                      )
                      n instanceof HTMLElement &&
                        ((n.style.opacity = '0'),
                        (t = requestAnimationFrame(
                          () => (n.style.opacity = '1'),
                        )))
                    }
                  }
                return (
                  n.addEventListener('dragstart', o),
                  () => {
                    n.removeEventListener('dragstart', o),
                      null !== t && cancelAnimationFrame(t)
                  }
                )
              }
              return () => {}
            }, [])
          })(R)
        const O = (0, o.useCallback)(() => (0, M.ensureNotNull)($.current), []),
          B = (0, o.useCallback)(() => r, [r]),
          P = (0, o.useMemo)(() => {
            const e = h ? Bt : Ot,
              t = []
            let n
            t.push({
              type: 'padding',
              node: o.createElement(qt, {
                type: 'first',
                key: 'padding-top',
                getContainerElement: O,
                getOrderedNodes: B,
                processDropTarget: N,
              }),
            })
            for (let i = 0; i < r.length; i++) {
              const s = r[i]
              1 === s.level &&
                (void 0 !== n &&
                  n !== s.parentId &&
                  t.push({
                    type: 'separator',
                    node: o.createElement('div', {
                      key: n + '_separator',
                      className: sn.separator,
                    }),
                  }),
                (n = s.parentId)),
                t.push({
                  type: 'node',
                  node: o.createElement(e, {
                    id: s.id,
                    key: s.id,
                    isFirstListItem: 0 === i,
                    isLastListItem: i === r.length - 1,
                    isExpandable: s.children.length > 0,
                    nodeRenderer: a,
                    readOnly: h,
                    onClick: p,
                    isOffset: s.level > 1,
                    getContainerElement: O,
                  }),
                })
            }
            return (
              t.push({
                type: 'padding',
                node: o.createElement(qt, {
                  type: 'last',
                  key: 'padding-bottom',
                  getContainerElement: O,
                  getOrderedNodes: B,
                  processDropTarget: N,
                }),
              }),
              t
            )
          }, [r]),
          z = (0, o.useRef)([])
        z.current = P
        const F = (0, o.useCallback)((e) => {
            let { style: t } = e
            const { index: n } = e
            return (
              n === z.current.length - 1 &&
                ((t = { ...t, bottom: 0, minHeight: t.height }),
                delete t.height),
              o.createElement('div', { style: t }, z.current[n].node)
            )
          }, []),
          W = (0, o.useCallback)(
            (e) => {
              const t = z.current[e]
              return 'padding' === t.type
                ? 6
                : 'function' == typeof b
                  ? b(e, t)
                  : b
            },
            [b],
          ),
          G = (0, o.useCallback)(
            (e) => (0, M.ensure)(z.current[e].node.key),
            [],
          ),
          H = (0, o.useMemo)(
            () =>
              null === m
                ? { index: -1 }
                : { index: z.current.findIndex((e) => e.node.key === m.id) },
            [m],
          )
        d(R)
        const [V, U, K, Z] = (0, Yt.useOverlayScroll)(),
          Y = (0, o.useRef)(null)
        ;(0, o.useEffect)(
          () => (0, M.ensureNotNull)(Y.current).resetAfterIndex(0, !0),
          [P],
        ),
          (0, o.useEffect)(
            () => (0, M.ensureNotNull)(Y.current).scrollToItem(H.index),
            [H],
          )
        const $ = (0, o.useRef)(null),
          q = (0, o.useMemo)(() => ({ isOver: k, transform: f }), [k, f]),
          Q = (0, o.useRef)(null),
          X = (0, o.useRef)({
            startScroll(e) {
              const t = () => {
                null !== K.current &&
                  ((Q.current = requestAnimationFrame(t)),
                  K.current.scrollBy({ top: e }))
              }
              this.stopScroll(), t()
            },
            stopScroll() {
              null !== Q.current &&
                (cancelAnimationFrame(Q.current), (Q.current = null))
            },
            getListElement: () => K.current,
          })
        return (
          (0, o.useImperativeHandle)(t, () => X.current, []),
          (0, o.useEffect)(() => () => X.current.stopScroll(), [k]),
          (0, o.useEffect)(() => {
            if (!R.current || !j.PLATFORM_ACCESSIBILITY_ENABLED) return
            function e(e) {
              if (!t.matches(':focus-visible')) return
              if (!A) return
              const { viewModel: n } = A,
                o = n.selection()
              e.defaultPrevented ||
                e.currentTarget !== e.target ||
                o.selected().length ||
                y()
            }
            const t = R.current
            return (
              t.addEventListener('focus', e),
              () => {
                t.removeEventListener('focus', e)
              }
            )
          }, [R, y, A]),
          o.createElement(
            Qt.Provider,
            { value: q },
            o.createElement(
              'div',
              {
                ...U,
                className: g()(sn.tree, u),
                ref: R,
                'data-name': 'tree',
                tabIndex: j.PLATFORM_ACCESSIBILITY_ENABLED ? 0 : -1,
                onKeyDown: (e) => {
                  const t = (0, E.hashFromEvent)(e)
                  if (
                    e.defaultPrevented ||
                    (0, Pt.isNativeUIInteraction)(t, e.target)
                  )
                    return
                  const o = (0, M.ensureDefined)(V.scrollPosTop),
                    r = (0, M.ensureDefined)(V.contentHeight),
                    i = (0, M.ensureDefined)(V.containerHeight)
                  if (i) {
                    const n = 0.875 * i,
                      s = o + i === r
                    switch (t) {
                      case 35:
                        s || (e.preventDefault(), J(r))
                        break
                      case 36:
                        0 !== o && (e.preventDefault(), J(0))
                        break
                      case 33:
                        0 !== o && (e.preventDefault(), J(Math.max(0, o - n)))
                        break
                      case 34:
                        s || (e.preventDefault(), J(Math.min(o + n, r)))
                    }
                  }
                  A || t !== ln || (e.preventDefault(), _())
                  A || t !== an || (e.preventDefault(), S())
                  ;(38 === t || (void 0 !== n && 'previous' === n[t])) &&
                    (e.preventDefault(), C())
                  ;(40 === t || (void 0 !== n && 'next' === n[t])) &&
                    (e.preventDefault(), y())
                  if ((8 === t || 46 === t) && A) {
                    const { viewModel: e } = A,
                      t = e.selection(),
                      n = t.selected()
                    if (1 !== n.length) return
                    const o = e.getNextNodeIdAfterRemove(n[0])
                    if (null === o) return
                    e.onChange().subscribe(
                      null,
                      () => {
                        if (t.selected().length) return
                        const n = e.entity(o)
                        n && (t.set([n]), v(o))
                      },
                      !0,
                    )
                  }
                  null == T || T(e)
                },
              },
              o.createElement(Zt.OverlayScrollContainer, {
                ...V,
                className: sn.overlayScrollWrap,
              }),
              o.createElement(St.VariableSizeList, {
                ref: (e) => {
                  Y.current = e
                },
                className: sn.listContainer,
                width: I,
                height: D,
                itemCount: P.length,
                itemSize: W,
                children: F,
                itemKey: G,
                outerRef: (e) => {
                  ;(K.current = e), w && w(e)
                },
                innerRef: (e) => {
                  $.current = e
                },
                innerElementType: on,
                onItemsRendered: () => {
                  Z()
                },
                overscanCount: 20,
                direction: (0, rn.isRtl)() ? 'rtl' : 'ltr',
              }),
              o.createElement(Kt, { dragPreviewRenderer: c, nodeRenderer: a }),
            ),
          )
        )
        function J(e) {
          var t
          null === (t = K.current) ||
            void 0 === t ||
            t.scrollTo({ left: 0, top: e })
        }
      })
      const un = (0, H.connect)(
          (e) => ({
            renderList: Je(e),
            orderedNodes: Qe(e),
            isMultiSelecting: Ye(e),
            selectedIds: Ke(e),
            scrollToId: ze(e),
          }),
          (e) =>
            (0, pt.bindActionCreators)(
              {
                startMultiSelect: Ee,
                stopMultiSelect: Me,
                setFocusedNode: De,
                processDropTarget: Ce,
                onMoveCursorToNext: _e,
                onMoveCursorToPrevious: be,
                onMultiSelectPrevious: Se,
                onMultiSelectNext: ye,
              },
              e,
            ),
          null,
          { context: At },
        )((e) => {
          const t = (0, o.useRef)(null),
            [{ isOver: n }, r] = (0, _t.useDrop)({
              accept: 'node',
              drop: (n, o) => {
                var r
                ;('touch' === e.drag || yt.isFF) &&
                  (null === (r = t.current) || void 0 === r || r.stopScroll()),
                  o.getItem().dropSelection()
              },
              hover: (n, o) => {
                var r, i
                if ('touch' !== e.drag && !yt.isFF) return
                const s = o.getClientOffset()
                if (null === s) return
                const l =
                  null !==
                    (i =
                      null === (r = t.current) || void 0 === r
                        ? void 0
                        : r.getListElement()) && void 0 !== i
                    ? i
                    : null
                if (null === l) return
                const a = l.getBoundingClientRect()
                ;((n, o, r) => {
                  var i
                  const s = Math.abs(n - r),
                    l = Math.abs(n - o)
                  if ((l > 40 && s > 40) || (s <= 40 && l <= 40))
                    return void (
                      null === (i = t.current) ||
                      void 0 === i ||
                      i.stopScroll()
                    )
                  ;((n, o, r, i) => {
                    var s, l, a, c
                    o || n
                      ? 'touch' === e.drag
                        ? null === (s = t.current) ||
                          void 0 === s ||
                          s.startScroll(o ? -5 : 5)
                        : null === (l = t.current) ||
                          void 0 === l ||
                          l.startScroll(o ? -2 : 2)
                      : (r || i) &&
                        ('touch' === e.drag
                          ? null === (a = t.current) ||
                            void 0 === a ||
                            a.startScroll(r ? -10 : 10)
                          : null === (c = t.current) ||
                            void 0 === c ||
                            c.startScroll(r ? -5 : 5))
                  })(l > 20 && l <= 40, s > 20 && s <= 40, s <= 20, l <= 20)
                })(s.y, a.bottom, a.top)
              },
              collect: (e) => ({ isOver: e.isOver() }),
            })
          return o.createElement(cn, {
            ...e,
            isOver: n,
            connectDropTarget: r,
            ref: t,
          })
        }),
        dn = { delayTouchStart: 100 }
      function hn(e) {
        const {
            canBeAddedToSelection: t,
            initState: n,
            onSelect: r,
            canMove: i,
            onDrop: s,
            onMove: l,
            nodes: a,
            selectedIds: c,
            onKeyboardSelect: u,
            saga: d,
            lastFocusedNodeObject: h,
            lastSyncTimestampRef: p,
            scrollToId: f,
            ...g
          } = e,
          [v, m] = (0, o.useState)(null)
        return (
          (0, o.useEffect)(() => {
            const e = (0, G.default)()
            m(
              ((e) => {
                const t = (0, pt.applyMiddleware)(e)
                return (0, pt.createStore)(bt, t)
              })(e),
            )
            const o = e.run(ht, {
              initState: n,
              onKeyboardSelect: u,
              saga: d,
              canMove: i,
              onMove: l,
              onDrop: s,
              onSelect: r,
              canBeAddedToSelection: t,
            })
            return () => o.cancel()
          }, []),
          (0, o.useEffect)(
            () => (
              null !== v &&
                a &&
                (p && (p.current = performance.now()),
                v.dispatch(((e) => ({ type: q, nodes: e }))(a))),
              () => {}
            ),
            [v, a],
          ),
          (0, o.useEffect)(() => {
            null !== v && c && v.dispatch(we(c))
          }, [v, c]),
          (0, o.useEffect)(() => {
            null !== v && (null == h ? void 0 : h.id) && v.dispatch(De(h.id))
          }, [v, h]),
          null === v
            ? null
            : o.createElement(pn, { store: v, scrollToId: f, ...g })
        )
      }
      const pn = o.memo((e) => {
        const { store: t, scrollToId: n, ...r } = e,
          i = 'touch' === e.drag ? U.TouchBackend : V.HTML5Backend
        return (
          (0, o.useEffect)(() => {
            var e
            t.dispatch(
              ke(
                null !== (e = null == n ? void 0 : n.id) && void 0 !== e
                  ? e
                  : null,
              ),
            )
          }, [n]),
          o.createElement(
            K.DndProvider,
            { backend: i, options: dn },
            o.createElement(
              H.Provider,
              { store: t, context: At },
              o.createElement(un, { ...r }),
            ),
          )
        )
      })
      function fn(e, t) {
        ;(0, F.trackEvent)('Object Tree', e, t)
      }
      function gn(e) {
        return e.length > 1 ? 'Multi select' : e[0].gaLabel()
      }
      function vn(e) {
        return (0, G.eventChannel)((t) => {
          const n = {}
          return (
            e.onChange().subscribe(n, () => t({ type: J })),
            e.onGroupCreated().subscribe(n, (e) => t(Le(e, !0))),
            e
              .selection()
              .onChange()
              .subscribe(n, (e) => t(we(e))),
            () => {
              e.onChange().unsubscribeAll(n),
                e.selection().onChange().unsubscribeAll(n),
                e.onGroupCreated().unsubscribeAll(n)
            }
          )
        }, G.buffers.expanding())
      }
      function* mn() {
        for (;;) yield (0, w.take)([oe, ne]), fn('Select', 'Arrow')
      }
      function* bn() {
        for (;;) {
          const { mode: e } = yield (0, w.take)(pe)
          1 === e && fn('Multi select', 'Ctrl'),
            2 === e && fn('Multi select', 'Shift')
        }
      }
      function* _n(e) {
        for (;;) {
          yield (0, w.take)(te)
          const { node: t, dropType: n } = Be(yield (0, w.select)())
          if (t) {
            const o = $e(yield (0, w.select)()),
              r = o.map((t) => (0, M.ensureNotNull)(e.entity(t.id)))
            let i = 'Drag'
            1 === t.level && 'inside' !== n && o.some((e) => 2 === e.level)
              ? (i = 'From the group')
              : (2 !== t.level && 'inside' !== n) ||
                  !o.some((e) => 1 === e.level)
                ? 1 === o.length &&
                  o[0].parentId !== t.parentId &&
                  (i = 'Existing pane')
                : (i = 'To the group'),
              fn(i, gn(r))
          }
        }
      }
      function* Sn(e) {
        yield (0, w.fork)(mn), yield (0, w.fork)(bn), yield (0, w.fork)(_n, e)
      }
      function* yn(e) {
        yield (0, w.fork)(Sn, e)
        const t = yield (0, w.call)(vn, e)
        gt.logNormal('Opened object tree data source channel')
        try {
          for (;;) {
            const e = yield (0, w.take)(t)
            yield (0, w.put)(e)
          }
        } finally {
          gt.logNormal('Closed object tree data source channel'), t.close()
        }
      }
      const Cn = o.createContext(null)
      var Tn = n(21861),
        wn = n(898),
        In = n(6909)
      const En = I.mobiletouch ? 'touch' : 'native'
      function Mn(e) {
        const {
            viewModel: t,
            showHeader: n = !0,
            nodeRenderer: r,
            isDialog: i = !1,
            hideHeaderTitle: s = !1,
          } = e,
          l = (0, o.useRef)(null),
          a = ((e) => {
            const [t, n] = (0, o.useState)(e.getChartId()),
              r = (0, o.useRef)(t)
            return (
              (r.current = t),
              (0, o.useEffect)(() => {
                return (
                  e.onChange().subscribe(null, t),
                  () => {
                    e.onChange().unsubscribe(null, t)
                  }
                )
                function t() {
                  const t = e.getChartId()
                  r.current !== t && n(t)
                }
              }, []),
              t
            )
          })(t),
          [c, u] = (0, wn.useDimensions)(),
          [d, h] = (0, o.useState)(null),
          p = (0, o.useMemo)(() => ({ isTouch: I.touch, isDialog: i }), [i])
        return o.createElement(
          Cn.Provider,
          { value: p },
          o.createElement(
            x.Provider,
            { value: { viewModel: t } },
            o.createElement(
              'div',
              {
                className: In.wrap,
                onContextMenu: Tn.preventDefaultForContextMenu,
              },
              n && o.createElement(W, { hideTitle: s }),
              o.createElement(
                'div',
                {
                  className: In.space,
                  onClick: (e) => {
                    if (e.defaultPrevented) return
                    if (!(e.target instanceof Element) || null === l.current)
                      return
                    e.target === l.current && t.selection().set([])
                  },
                  ref: c,
                },
                null !== u &&
                  o.createElement(hn, {
                    key: a,
                    height: u.height,
                    width: u.width,
                    canBeAddedToSelection: (e) => {
                      const n = t.entity(e)
                      return t.selection().canBeAddedToSelection(n)
                    },
                    nodeRenderer: r,
                    initState: () => {
                      const { nodes: e, selection: n } = t.getState()
                      return { selectedIds: n, nodes: e }
                    },
                    canMove: (e, n, o) => t.isSelectionDropable(n.id, o),
                    drag: En,
                    rowHeight: Dn,
                    onSelect: (e) => {
                      const n = e
                        .map((e) => t.entity(e))
                        .filter((e) => null !== e)
                      t.selection().set(n)
                    },
                    onDrop: (e) => {
                      e.preventDefault()
                      const {
                        detail: { target: n, type: o },
                      } = e
                      t.insertSelection(n, o)
                    },
                    scrollToId: d,
                    saga: function* () {
                      yield (0, w.fork)(yn, t)
                    },
                    onKeyboardSelect: (e) => {
                      h({ id: e })
                    },
                    outerRef: (e) => {
                      l.current = e
                    },
                    onKeyDown: (e) => {
                      if (13 === (0, E.hashFromEvent)(e)) {
                        e.preventDefault()
                        const n = t.selection().selected(),
                          o = n.length > 0 ? t.entity(n[0]) : void 0
                        o && t.openProperties(o)
                      }
                    },
                    autofocus: i,
                  }),
              ),
            ),
          ),
        )
      }
      function Dn(e, t) {
        switch (t.type) {
          case 'node':
            return 38
          case 'separator':
            return 13
        }
      }
      var kn,
        Nn = n(14483)
      !((e) => {
        e.Svg = 'svg'
      })(kn || (kn = {}))
      var Ln = n(31261),
        xn = n(86928)
      function An(e) {
        const { className: t, disabled: n, ...r } = e
        return o.createElement(D.Icon, {
          className: g()(xn.button, n && xn.disabled, t),
          ...r,
        })
      }
      var Rn = n(77975)
      const jn = p.t(null, void 0, n(91073)),
        On = p.t(null, void 0, n(35038)),
        Bn = p.t(null, void 0, n(15101)),
        Pn = p.t(null, void 0, n(42284)),
        zn = p.t(null, void 0, n(31971)),
        Fn = p.t(null, void 0, n(81428)),
        Wn = p.t(null, void 0, n(34596))
      var Gn = n(14787),
        Hn = n(33765),
        Vn = n(52870),
        Un = n(49756),
        Kn = n(94007),
        Zn = n(62766),
        Yn = n(87769)
      function $n(e) {
        const { id: t } = e,
          n = (0, o.useContext)(x),
          { viewModel: r } = (0, M.ensureNotNull)(n),
          i = r.entity(t)
        return null === i ? null : o.createElement(qn, { ...e, entity: i })
      }
      function qn(e) {
        const {
            id: t,
            isOffset: r,
            isDisabled: i,
            isSelected: s,
            isChildOfSelected: l,
            isHovered: a,
            parentId: c,
            entity: u,
            isExpanded: d,
          } = e,
          h = (0, o.useContext)(x),
          { viewModel: g } = (0, M.ensureNotNull)(h),
          v = (0, o.useContext)(Cn),
          { size: m } = (0, o.useContext)(Et),
          [b, _] = (0, o.useState)(!1),
          S = (0, o.useRef)(null),
          [y, C] = (0, o.useState)(u.title().value()),
          [T, w] = (0, o.useState)(u.getIcon()),
          [I, k] = (0, o.useState)(u.isLocked()),
          [N, L] = (0, o.useState)(u.isVisible()),
          [A, R] = (0, o.useState)(u.isActualInterval()),
          [j, O] = (0, o.useState)(u.getDrawingSyncState()),
          [B, P] = (0, o.useState)(!1),
          [z, F] =
            ((0, Rn.useWatchedValueReadonly)({
              watchedValue: g.getChartLayout(),
            }),
            (0, o.useState)(!1)),
          W = (0, o.useRef)(null)
        ;(0, o.useEffect)(() => {
          const e = {}
          u.onLockChanged().subscribe(e, () => k(u.isLocked())),
            u.onVisibilityChanged().subscribe(e, () => L(u.isVisible()))
          const t = u.title().spawn()
          t.subscribe((e) => C(e)),
            u
              .onIsActualIntervalChange()
              .subscribe(e, () => R(u.isActualInterval())),
            u
              .onSyncStateChanged()
              .subscribe(e, () => O(u.getDrawingSyncState()))
          const n = u.onIconChanged ? u.onIconChanged() : void 0
          return (
            n && n.subscribe(e, () => w(u.getIcon())),
            () => {
              u.onIsActualIntervalChange().unsubscribeAll(e),
                u.onLockChanged().unsubscribeAll(e),
                u.onVisibilityChanged().unsubscribeAll(e),
                u.onSyncStateChanged().unsubscribeAll(e),
                t.destroy(),
                W.current && clearTimeout(W.current),
                n && n.unsubscribeAll(e)
            }
          )
        }, [u]),
          (0, o.useEffect)(() => {
            b &&
              S.current &&
              (S.current.focus(), S.current.setSelectionRange(0, y.length))
          }, [b]),
          (0, o.useEffect)(() => {
            const e = {}
            return (
              g.hoveredObjectChanged().subscribe(e, J),
              () => {
                g.hoveredObjectChanged().unsubscribeAll(e)
              }
            )
          }, [d]),
          (0, o.useEffect)(() => {
            g.setHoveredObject(a ? t : null)
          }, [a]),
          (0, o.useEffect)(() => {
            !s && W.current && (clearTimeout(W.current), (W.current = null)),
              _(!1)
          }, [s])
        const G = {}
        if (c) {
          const e = g.entity(c)
          e && (G['data-parent-name'] = e.title().value()),
            (G['data-type'] = u.hasChildren() ? 'group' : 'data-source')
        }
        const H = Nn.enabled('test_show_object_tree_debug')
            ? `<${u.id()}> (${u.zOrder()}) ${u.title()}`
            : u.title().value(),
          V = a || B,
          U = b && s,
          K = !!v && v.isTouch,
          Z = !!v && v.isDialog,
          Y = A && N ? Kn : Zn,
          $ = u.hasChildren()
            ? p.t(null, void 0, n(38207))
            : p.t(null, void 0, n(39781))
        let q = null
        return (
          T &&
            T.type === kn.Svg &&
            (q = o.createElement(D.Icon, {
              icon: T.content || '',
              className: Yn.icon,
            })),
          o.createElement(
            'span',
            {
              className: f(
                Yn.wrap,
                i && Yn.disabled,
                s && Yn.selected,
                r && Yn.offset,
                l && Yn.childOfSelected,
                B && !i && !s && !l && Yn.hover,
                Z && !i && !s && !l && Yn.dialog,
              ),
              onMouseDown: (e) => {
                b &&
                  !(0, M.ensureNotNull)(S.current).contains(e.target) &&
                  F(!0)
              },
              onClick:
                1 === m
                  ? Q
                  : (e) => {
                      if (e.defaultPrevented) return
                      if (0 !== (0, E.modifiersFromEvent)(e)) return
                      if (W.current)
                        e.preventDefault(),
                          clearTimeout(W.current),
                          (W.current = null),
                          g.openProperties(u),
                          F(!1)
                      else {
                        const e = g.selection().selected()
                        W.current = setTimeout(() => {
                          ;(W.current = null),
                            s &&
                              !z &&
                              1 === e.length &&
                              g.rename(u, () => _(!0)),
                            F(!1)
                        }, 500)
                      }
                    },
              onContextMenu: K ? void 0 : Q,
            },
            !U &&
              o.createElement(
                o.Fragment,
                null,
                q,
                !1,
                o.createElement(
                  'span',
                  {
                    className: f(
                      Yn.title,
                      g.isMain(u) && Yn.main,
                      (!u.isVisible() || !A) && Yn.disabled,
                    ),
                    ...G,
                  },
                  H,
                ),
                o.createElement(
                  'span',
                  { className: Yn.rightButtons },
                  u.canBeLocked() &&
                    o.createElement(An, {
                      title: I ? Bn : Pn,
                      icon: I ? Vn : Un,
                      className: f(
                        Yn.button,
                        (V || I) && Yn.visible,
                        'apply-common-tooltip',
                      ),
                      onClick: (e) => {
                        if (e.defaultPrevented) return
                        e.preventDefault(), g.setIsLocked(t, !u.isLocked())
                      },
                      'data-role': 'button',
                      'data-name': 'lock',
                      'data-active': I,
                    }),
                  o.createElement(An, {
                    icon: Y,
                    className: f(
                      Yn.button,
                      !A && Yn.warn,
                      (V || !N || !A) && Yn.visible,
                      'apply-common-tooltip',
                    ),
                    onClick: A
                      ? (e) => {
                          if (e.defaultPrevented) return
                          e.preventDefault(), g.setIsVisible(t, !u.isVisible())
                        }
                      : (e) => {
                          if (e.defaultPrevented) return
                          e.preventDefault(),
                            g.openProperties(u, Gn.TabNames.visibility)
                        },
                    title: (() => {
                      if (!A) return $
                      return N ? zn : Fn
                    })(),
                    'data-role': 'button',
                    'data-name': 'hide',
                    'data-active': !N,
                  }),
                  u.canBeRemoved() &&
                    o.createElement(An, {
                      title: Wn,
                      icon: Hn,
                      className: f(
                        Yn.button,
                        (K || V) && Yn.visible,
                        'apply-common-tooltip',
                      ),
                      onClick: (e) => {
                        if (e.defaultPrevented) return
                        e.preventDefault(), e.stopPropagation(), g.remove(t)
                      },
                      'data-role': 'button',
                      'data-name': 'remove',
                    }),
                ),
              ),
            U &&
              o.createElement(Ln.InputControl, {
                value: y,
                onChange: (e) => {
                  C(e.currentTarget.value)
                },
                onClick: Tn.preventDefault,
                className: Yn.renameInput,
                onKeyDown: (e) => {
                  27 === (0, E.hashFromEvent)(e)
                    ? (e.preventDefault(), C(u.title().value()), _(!1))
                    : 13 === (0, E.hashFromEvent)(e) &&
                      (e.preventDefault(), X())
                },
                reference: (e) => {
                  S.current = e
                },
                onBlur: X,
                onDragStart: (e) => {
                  e.preventDefault(), e.stopPropagation()
                },
                draggable: !0,
                stretch: !0,
              }),
          )
        )
        function Q(e) {
          e.defaultPrevented ||
            b ||
            !u.fullyConstructed() ||
            (e.preventDefault(),
            e.persist(),
            g.openContextMenu(u, () => _(!0), e))
        }
        function X() {
          '' !== y && u.setName(y), C(u.title().value()), _(!1)
        }
        function J(e) {
          if (u.hasChildren() && !d) {
            const t = null !== e && u.childrenIds().has(e)
            P(t)
          } else P(t === e)
        }
      }
      var Qn = n(50813),
        Xn = n(17742)
      function Jn(e) {
        const { viewModel: t, onClose: r, activeChartWidget: i } = e,
          [s, l] = (0, o.useState)(!1),
          [a, c] = (0, o.useState)(!1),
          [u, d] = (0, o.useState)(!1),
          h = (0, o.useRef)(null),
          g = (0, v.useForceUpdate)(),
          w = ((0, m.useIsMounted)(), t.selection()),
          I = t.canSelectionBeGrouped()
        return (
          (0, o.useEffect)(() => {
            const e = window.matchMedia(C.DialogBreakpoints.TabletSmall)
            return e.addListener(E), () => e.removeListener(E)
          }, []),
          (0, o.useEffect)(
            () => (
              w.onChange().subscribe(null, () => g()),
              () => {
                w.onChange().unsubscribeAll(null)
              }
            ),
            [w],
          ),
          (0, o.useEffect)(() => {
            const e = (e) => d(e)
            return (
              t.isContextMenuOpened().subscribe(e),
              () => {
                t.isContextMenuOpened().unsubscribe(e)
              }
            )
          }, [t]),
          o.createElement(
            o.Fragment,
            null,
            o.createElement(
              S.MatchMedia,
              { rule: C.DialogBreakpoints.TabletSmall },
              (e) =>
                o.createElement(y.AdaptivePopupDialog, {
                  additionalElementPos: 'after',
                  additionalHeaderElement: o.createElement(
                    'div',
                    { className: Xn.buttons },
                    o.createElement(Qn.ToolWidgetIconButton, {
                      className: f(Xn.button, !I && Xn.disabled),
                      icon: P,
                      onClick: D,
                      isDisabled: !I,
                      title: p.t(null, void 0, n(91073)),
                      'data-name': 'group-button',
                    }),
                    !1,
                  ),
                  className: Xn.dialog,
                  dataName: 'object-tree-dialog',
                  isOpened: !0,
                  onClickOutside: a || e || u ? () => {} : r,
                  onClose: r,
                  ref: h,
                  render: () =>
                    o.createElement(eo, { isSmallTablet: e, viewModel: t }),
                  title: p.t(null, void 0, n(31095)),
                  showSeparator: !0,
                }),
            ),
            o.createElement(
              _.DrawerManager,
              null,
              s &&
                o.createElement(
                  b.Drawer,
                  { onClose: M, position: 'Bottom' },
                  o.createElement(T.ManageDrawings, {
                    onClose: M,
                    chartWidget: i,
                    isMobile: !0,
                  }),
                ),
            ),
          )
        )
        function E() {
          s &&
            !window.matchMedia(C.DialogBreakpoints.TabletSmall).matches &&
            l(!1)
        }
        function M() {
          l(!1)
        }
        function D() {
          t.createGroupFromSelection()
        }
      }
      function eo(e) {
        const { isSmallTablet: t, viewModel: n } = e,
          r = (0, o.useMemo)(
            () => ({ size: t ? 1 : 0, smallSizeTreeNodeAction: 0 }),
            [t],
          )
        return o.createElement(
          Et.Provider,
          { value: r },
          o.createElement(Mn, {
            nodeRenderer: $n,
            showHeader: !1,
            viewModel: n,
            isDialog: !0,
          }),
        )
      }
      var to = n(16216),
        no = n(98310),
        oo = n(57898)
      var ro = n(32112)
      function io(e, t) {
        return `${e}:${t}`
      }
      function so(e) {
        const t = e.split(':')
        return { persistentId: t[0], instanceId: t[1] }
      }
      class lo {
        constructor(e) {
          ;(this._onChange = new oo.Delegate()),
            (this._recalculate = () => {
              const e = this._groupModel
                  .groups()
                  .map((e) => io(e.id, e.instanceId())),
                t = this._selectionApi.allSources()
              ;(this._selected = this._selected.filter(
                (n) => e.includes(n) || t.includes(n),
              )),
                this._onChange.fire(this._selected)
            }),
            (this._model = e),
            (this._selectionApi = new ro.SelectionApi(this._model)),
            (this._groupModel = this._model.lineToolsGroupModel()),
            (this._selected = this._getSelectedIds()),
            this._selectionApi.onChanged().subscribe(this, () => {
              ;(this._selected = this._getSelectedIds()),
                this._onChange.fire(this._selected)
            }),
            this._groupModel.onChanged().subscribe(this, this._recalculate)
        }
        destroy() {
          this._selectionApi.onChanged().unsubscribeAll(this),
            this._groupModel.onChanged().unsubscribeAll(this)
        }
        set(e) {
          const t = []
          let n = e.map((e) => e.id())
          for (const o of e)
            if (o.hasChildren()) {
              const e = o.childrenIds()
              t.push(...Array.from(e.values())),
                (n = n.filter((t) => !e.has(t)))
            } else t.push(o.id())
          this._selectionApi.set(t.map((e) => so(e).persistentId)),
            (this._selected = n),
            this._onChange.fire(this._selected)
        }
        canBeAddedToSelection(e) {
          return null !== e && e.canBeAddedToSelection()
        }
        onChange() {
          return this._onChange
        }
        selected() {
          return this._selected
        }
        _getSelectedIds() {
          return this._selectionApi
            .allSources()
            .map((e) => this._model.dataSourceForId(e))
            .filter(ft.notNull)
            .filter((e) => e.showInObjectTree())
            .map((e) => io(e.id(), e.instanceId()))
        }
      }
      class ao {
        constructor(e, t) {
          ;(this._controller = e),
            (this._facade = t),
            (this._groupModel = e.model().lineToolsGroupModel())
        }
        buildTree() {
          const e = {}
          for (const t of this._controller.model().panes()) {
            const n = t
              .sourcesByGroup()
              .all()
              .filter((e) => e.showInObjectTree())
            e[t.id()] = co(t.id(), 0)
            for (const n of this._groupModel.groups()) {
              const o = io(n.id, n.instanceId()),
                r = (0, M.ensureNotNull)(this._facade.getObjectById(o))
              if (r.pane() === t) {
                const o = [...n.lineTools()]
                  .sort((e, t) => (e.zorder() > t.zorder() ? -1 : 1))
                  .map((e) => io(e.id(), e.instanceId()))
                ;(e[r.id()] = co(r.id(), 1, t.id(), o)),
                  e[t.id()].children.push(r.id())
                for (const t of o) e[t] = co(t, 2, r.id())
              }
            }
            for (const o of n) {
              const n = io(o.id(), o.instanceId())
              e[n] || ((e[n] = co(n, 1, t.id())), e[t.id()].children.push(n))
            }
            e[t.id()].children.sort((e, t) => {
              const n = (0, M.ensureNotNull)(this._facade.getObjectById(e)),
                o = (0, M.ensureNotNull)(this._facade.getObjectById(t))
              return (
                (0, M.ensureNotNull)(o.zOrder()) -
                (0, M.ensureNotNull)(n.zOrder())
              )
            })
          }
          return this._facade.invalidateCache(new Set(Object.keys(e))), e
        }
      }
      function co(e, t, n, o = []) {
        return { id: e, level: t, parentId: n, children: o }
      }
      var uo = n(36298),
        ho = n(97145),
        po = n(92249),
        fo = n(28853),
        go = n(14292),
        vo = n(49152),
        mo = n(18611),
        bo = n(24120),
        _o = n(88348),
        So = n(37591),
        yo = n(7295),
        Co = n(28824),
        To = n(57674)
      const wo = new uo.TranslatedString(
          'show {title}',
          p.t(null, void 0, n(87358)),
        ),
        Io = new uo.TranslatedString(
          'hide {title}',
          p.t(null, void 0, n(70301)),
        ),
        Eo = new uo.TranslatedString(
          'lock {title}',
          p.t(null, void 0, n(50193)),
        ),
        Mo = new uo.TranslatedString(
          'unlock {title}',
          p.t(null, void 0, n(92421)),
        ),
        Do = new uo.TranslatedString(
          'change {sourceTitle} title to {newSourceTitle}',
          p.t(null, void 0, n(40001)),
        ),
        ko = new uo.TranslatedString(
          'insert source(s) after',
          p.t(null, void 0, n(8343)),
        ),
        No = !1
      function Lo(e, t) {
        return t.every(
          (t) => !(t.pane() !== e && !t.allowsMovingbetweenPanes()),
        )
      }
      function xo(e) {
        return e instanceof go.DataSource && e.showInObjectTree()
          ? io(e.id(), e.instanceId())
          : null
      }
      function Ao(e) {
        return new uo.TranslatedString(
          e.name(),
          e.title(So.TitleDisplayTarget.DataWindow),
        )
      }
      const Ro = new oo.Delegate(),
        jo = Nn.enabled('saveload_separate_drawings_storage')
      function Oo(e) {
        return 0 === e ? 0 : 1 === e ? 1 : 2
      }
      class Bo {
        constructor(e, t) {
          ;(this._syncStateChanged = new oo.Delegate()),
            (this._updateSyncState = () => {
              this._syncStateChanged.fire(
                (0, M.ensureNotNull)(this.getDrawingSyncState()),
              )
            }),
            (this._undoModel = e),
            (this._dataSource = t),
            (0, po.isLineTool)(t)
              ? (t.linkKey().subscribe(this._updateSyncState),
                t.sharingMode().subscribe(this._updateSyncState),
                (this._title = (0, vo.createWVFromGetterAndSubscription)(
                  () => t.properties().title.value() || t.translatedType(),
                  t.properties().title,
                )))
              : (0, mo.isSymbolSource)(t)
                ? (this._title = (0, vo.createWVFromGetterAndSubscriptions)(
                    () =>
                      t.symbolTitle(
                        So.TitleDisplayTarget.DataWindow,
                        void 0,
                        void 0,
                        (0, yt.onWidget)() ? 'exchange' : 'listed_exchange',
                      ),
                    [t.symbolChanged(), t.symbolResolved()],
                  ))
                : (0, fo.isStudy)(t)
                  ? (this._title = (0, vo.createWVFromGetterAndSubscriptions)(
                      () => t.title(So.TitleDisplayTarget.DataWindow),
                      [
                        t.properties().childs().inputs,
                        this._undoModel
                          .model()
                          .properties()
                          .childs()
                          .paneProperties.childs()
                          .legendProperties.childs().showStudyArguments,
                        t.onParentSourcesChanges(),
                      ],
                    ))
                  : (this._title = new ho.WatchedValue(
                      t.title(So.TitleDisplayTarget.DataWindow),
                    ).spawn())
          const n = this._undoModel.lineBeingCreated()
          null !== n &&
            n === t &&
            n.isSynchronizable() &&
            _o.isToolCreatingNow.subscribe(this._updateSyncState)
        }
        destroy() {
          ;(0, po.isLineTool)(this._dataSource) &&
            (this._dataSource.linkKey().unsubscribe(this._updateSyncState),
            this._dataSource.sharingMode().unsubscribe(this._updateSyncState)),
            this._title.destroy(),
            _o.isToolCreatingNow.unsubscribe(this._updateSyncState)
        }
        id() {
          return io(this._dataSource.id(), this._dataSource.instanceId())
        }
        title() {
          return this._title
        }
        gaLabel() {
          return (0, fo.isStudy)(this._dataSource)
            ? 'Study'
            : (0, po.isLineTool)(this._dataSource)
              ? 'Drawing'
              : 'Symbol'
        }
        canBeLocked() {
          return (
            (0, po.isLineTool)(this._dataSource) &&
            this._dataSource.userEditEnabled()
          )
        }
        canBeRemoved() {
          return (
            this._undoModel.mainSeries() !== this._dataSource &&
            this._dataSource.isUserDeletable()
          )
        }
        canBeHidden() {
          return this._dataSource.canBeHidden()
        }
        canBeRenamed() {
          return (0, po.isLineTool)(this._dataSource)
        }
        fullyConstructed() {
          return this._undoModel.lineBeingCreated() !== this._dataSource
        }
        isVisible() {
          return this._dataSource.properties().visible.value()
        }
        isActualInterval() {
          return (
            (!(0, po.isLineTool)(this._dataSource) &&
              !(0, fo.isStudy)(this._dataSource)) ||
            this._dataSource.isActualInterval()
          )
        }
        onIsActualIntervalChange() {
          return (0, po.isLineTool)(this._dataSource) ||
            (0, fo.isStudy)(this._dataSource)
            ? this._dataSource.onIsActualIntervalChange()
            : Ro
        }
        isLocked() {
          return (
            !!(0, po.isLineTool)(this._dataSource) &&
            this._dataSource.properties().frozen.value()
          )
        }
        onVisibilityChanged() {
          return this._dataSource.properties().visible.listeners()
        }
        onLockChanged() {
          return (0, po.isLineTool)(this._dataSource)
            ? this._dataSource.properties().frozen.listeners()
            : Ro
        }
        getIcon() {
          const e = a,
            t = this._dataSource.getSourceIcon(),
            n = (0, fo.isStudyStrategy)(this._dataSource)
          let o = { type: kn.Svg, content: n ? yo : Co }
          if (e && t)
            if ('loadSvg' === t.type) {
              const [n, r] = t.svgId.split('.'),
                i = 'linetool' === n ? e.linetool[r] : e.series[Number(r)]
              o = { type: kn.Svg, content: i || Co }
            } else
              'svgContent' === t.type &&
                (o = { type: kn.Svg, content: t.content })
          return o
        }
        onIconChanged() {
          if (this._dataSource.onSourceIconChanged)
            return this._dataSource.onSourceIconChanged()
        }
        setVisible(e) {
          const t = (e ? wo : Io).format({ title: Ao(this._dataSource) })
          this._undoModel.setProperty(
            this._dataSource.properties().visible,
            e,
            t,
          )
        }
        setLocked(e) {
          if ((0, po.isLineTool)(this._dataSource)) {
            const t = (e ? Eo : Mo).format({ title: Ao(this._dataSource) })
            this._undoModel.setProperty(
              this._dataSource.properties().frozen,
              e,
              t,
            )
          }
        }
        setName(e) {
          if ((0, po.isLineTool)(this._dataSource)) {
            const t = Do.format({
              sourceTitle:
                this._dataSource.properties().title.value() ||
                Ao(this._dataSource),
              newSourceTitle: e,
            })
            this._undoModel.setProperty(
              this._dataSource.properties().title,
              e,
              t,
              No,
            )
          }
        }
        isCopiable() {
          return this._dataSource.copiable()
        }
        isClonable() {
          return this._dataSource.cloneable()
        }
        zOrder() {
          return this._dataSource.zorder()
        }
        remove() {
          this._undoModel.removeSource(this._dataSource, !1)
        }
        canBeAddedToSelection() {
          return this._undoModel
            .selection()
            .canBeAddedToSelection(this._dataSource)
        }
        setAsSelection() {
          this._undoModel.model().selectionMacro((e) => {
            e.clearSelection(), e.addSourceToSelection(this._dataSource)
          })
        }
        addToSelection() {
          this._undoModel.model().selectionMacro((e) => {
            e.addSourceToSelection(this._dataSource)
          })
        }
        addSourcesToArray(e) {
          return e.push(this._dataSource), e
        }
        insertSourcesBeforeThis(e) {
          this._insertSources(e, (e) =>
            this._undoModel.insertBefore(e, this._dataSource),
          )
        }
        insertSourcesAfterThis(e) {
          this._insertSources(e, (e) =>
            this._undoModel.insertAfter(e, this._dataSource),
          )
        }
        childrenIds() {
          return new Set()
        }
        hasChildren() {
          return !1
        }
        pane() {
          return (0, M.ensureNotNull)(
            this._undoModel.model().paneForSource(this._dataSource),
          )
        }
        allowsMovingbetweenPanes() {
          return !(0, po.isLineTool)(this._dataSource)
        }
        canBeAddedToGroup() {
          return (
            (0, po.isLineTool)(this._dataSource) &&
            this._dataSource.boundToSymbol()
          )
        }
        canInsertBeforeThis(e) {
          return this._canInsertBeforeOrAfter(e)
        }
        canInsertAfterThis(e) {
          return this._canInsertBeforeOrAfter(e)
        }
        detachFromParent() {
          if ((0, po.isLineTool)(this._dataSource)) {
            const e = this._undoModel.model(),
              t = this._undoModel.lineToolsGroupController(),
              n = e.lineToolsGroupModel().groupForLineTool(this._dataSource)
            null !== n && t.excludeLineToolFromGroup(n, this._dataSource)
          }
        }
        canBeSyncedInLayout() {
          return (
            (0, po.isLineTool)(this._dataSource) &&
            this._dataSource.isSynchronizable()
          )
        }
        onSyncStateChanged() {
          return this._syncStateChanged
        }
        setDrawingSyncState(e) {
          if (!this.canBeSyncedInLayout() || !this.fullyConstructed()) return
          const t = this._dataSource
          switch (e) {
            case 0:
              if (null === t.linkKey().value()) return
              this._undoModel.unlinkLines([t])
              break
            case 1:
              if (null !== t.linkKey().value()) return
              this._undoModel.shareLineTools([t], 1)
          }
        }
        getDrawingSyncState() {
          return this.canBeSyncedInLayout()
            ? jo
              ? this.fullyConstructed()
                ? Oo(this._dataSource.sharingMode().value())
                : 0
              : this.fullyConstructed() &&
                  null !== this._dataSource.linkKey().value()
                ? 1
                : 0
            : null
        }
        doNotAffectChartInvalidation() {
          return (0, po.isLineTool)(this._dataSource) && No
        }
        _canInsertBeforeOrAfter(e) {
          const t = this._undoModel.model()
          if (!Lo(this.pane(), e)) return !1
          if ((0, po.isLineTool)(this._dataSource)) {
            if (
              null !==
                t.lineToolsGroupModel().groupForLineTool(this._dataSource) &&
              e.some((e) => !e.canBeAddedToGroup())
            )
              return !1
          }
          return !0
        }
        _insertSources(e, t) {
          const n = this._undoModel.model(),
            o = this._undoModel.lineToolsGroupController()
          this._undoModel.beginUndoMacro(ko)
          const r = () => {
              e.forEach((e) => e.detachFromParent())
            },
            i = e.reduce((e, t) => t.addSourcesToArray(e), [])
          if ((0, po.isLineTool)(this._dataSource)) {
            const t = n.lineToolsGroupModel().groupForLineTool(this._dataSource)
            null !== t
              ? ((0, M.assert)(!e.some((e) => e.hasChildren())),
                i.forEach((e) => {
                  ;(0, po.isLineTool)(e) &&
                    (t.containsLineTool(e) || o.addLineToolToGroup(t, e))
                }))
              : r()
          } else r()
          t(i), this._undoModel.endUndoMacro()
        }
      }
      class Po {
        constructor(e, t) {
          ;(this._onVisibilityChanged = new oo.Delegate()),
            (this._onLockChanged = new oo.Delegate()),
            (this._onIsActualIntervalChanged = new oo.Delegate()),
            (this._syncStateChanged = new oo.Delegate()),
            (this._linkKeyChangedBound = this._linkKeyChanged.bind(this)),
            (this._undoModel = e),
            (this._group = t),
            (this._lineTools = t.lineTools()),
            (this._paneId = (0, M.ensureNotNull)(
              e.model().paneForSource(this._lineTools[0]),
            ).id())
          const n = () => {
            this._lineTools.forEach((e) => {
              e
                .properties()
                .visible.listeners()
                .subscribe(this, () => this._onVisibilityChanged.fire()),
                e
                  .properties()
                  .frozen.listeners()
                  .subscribe(this, () => this._onLockChanged.fire()),
                e
                  .onIsActualIntervalChange()
                  .subscribe(this, () =>
                    this._onIsActualIntervalChanged.fire(),
                  ),
                e.linkKey().subscribe(this._linkKeyChangedBound),
                e.sharingMode().subscribe(this._linkKeyChangedBound)
            })
          }
          this._group.onChanged().subscribe(this, (e) => {
            this._unsubscribeFromAllLineTools(),
              (this._lineTools = this._group.lineTools()),
              n(),
              e.lockedChanged && this._onLockChanged.fire(),
              e.visibilityChanged && this._onVisibilityChanged.fire(),
              e.isActualIntervalChanged &&
                this._onIsActualIntervalChanged.fire()
            const t = this.getDrawingSyncState()
            null !== t && this._syncStateChanged.fire(t)
          }),
            n(),
            (this._lastActualZOrder = this.zOrder()),
            (this._lastIsVisible = this.isVisible()),
            (this._lastIsActualInterval = this.isActualInterval()),
            (this._lastIsLocked = this.isLocked())
        }
        destroy() {
          this._unsubscribeFromAllLineTools(),
            this._group.onChanged().unsubscribeAll(this)
        }
        id() {
          return io(this._group.id, this._group.instanceId())
        }
        title() {
          return this._group.name()
        }
        gaLabel() {
          return 'Group'
        }
        getIcon() {
          return { type: kn.Svg, content: To }
        }
        canBeRemoved() {
          return !0
        }
        canBeHidden() {
          return !0
        }
        canBeLocked() {
          return !0
        }
        canBeRenamed() {
          return !0
        }
        fullyConstructed() {
          return !0
        }
        isVisible() {
          return (
            this._group.lineTools().length > 0 &&
              (this._lastIsVisible = 'Invisible' !== this._group.visibility()),
            this._lastIsVisible
          )
        }
        isActualInterval() {
          return (
            this._group.lineTools().length > 0 &&
              (this._lastIsActualInterval = this._group
                .lineTools()
                .some((e) => e.isActualInterval())),
            this._lastIsActualInterval
          )
        }
        onIsActualIntervalChange() {
          return this._onIsActualIntervalChanged
        }
        isLocked() {
          return (
            this._group.lineTools().length > 0 &&
              (this._lastIsLocked = 'Locked' === this._group.locked()),
            this._lastIsLocked
          )
        }
        onVisibilityChanged() {
          return this._onVisibilityChanged
        }
        onLockChanged() {
          return this._onLockChanged
        }
        setVisible(e) {
          this._undoModel
            .lineToolsGroupController()
            .setGroupVisibility(this._group, e)
        }
        setLocked(e) {
          this._undoModel
            .lineToolsGroupController()
            .setGroupLock(this._group, e)
        }
        setName(e) {
          this._undoModel
            .lineToolsGroupController()
            .setGroupName(this._group, e)
        }
        isCopiable() {
          return !1
        }
        isClonable() {
          return !1
        }
        zOrder() {
          return (
            this._group.lineTools().length > 0 &&
              (this._lastActualZOrder = this._group.lineTools()[0].zorder()),
            this._lastActualZOrder
          )
        }
        remove() {
          this._undoModel.lineToolsGroupController().removeGroup(this._group)
        }
        canBeAddedToSelection() {
          const e = this._undoModel.model()
          return this._lineTools.every((t) =>
            e.selection().canBeAddedToSelection(t),
          )
        }
        setAsSelection() {
          this._undoModel.model().selectionMacro((e) => {
            e.clearSelection(),
              this._lineTools.forEach((t) => e.addSourceToSelection(t))
          })
        }
        addToSelection() {
          this._undoModel.model().selectionMacro((e) => {
            this._lineTools.forEach((t) => e.addSourceToSelection(t))
          })
        }
        addSourcesToArray(e) {
          return e.push(...this._lineTools), e
        }
        detachFromParent() {}
        insertSourcesBeforeThis(e) {
          const t = this._insertBeforeTarget()
          this._insertSources(e, (e) => this._undoModel.insertBefore(e, t))
        }
        insertSourcesAfterThis(e) {
          const t = this._insertAfterTarget()
          this._insertSources(e, (e) => this._undoModel.insertAfter(e, t))
        }
        childrenIds() {
          const e = [...this._lineTools]
          return (
            e.sort((e, t) => t.zorder() - e.zorder()),
            new Set(e.map((e) => io(e.id(), e.instanceId())))
          )
        }
        hasChildren() {
          return !0
        }
        pane() {
          return (0, M.ensureDefined)(
            this._undoModel
              .model()
              .panes()
              .find((e) => e.id() === this._paneId),
          )
        }
        allowsMovingbetweenPanes() {
          return !1
        }
        canBeAddedToGroup() {
          return !1
        }
        canInsertBeforeThis(e) {
          return this._canInsertBeforeOrAfter(e)
        }
        canInsertAfterThis(e) {
          return this._canInsertBeforeOrAfter(e)
        }
        canBeSyncedInLayout() {
          return (
            this._lineTools.length > 0 && this._lineTools[0].isSynchronizable()
          )
        }
        onSyncStateChanged() {
          return this._syncStateChanged
        }
        setDrawingSyncState(e) {
          if (this.canBeSyncedInLayout())
            switch (e) {
              case 0:
                const e = this._lineTools.filter(
                  (e) => null !== e.linkKey().value(),
                )
                e.length > 0 && this._undoModel.unlinkLines(e)
                break
              case 1:
                const t = this._lineTools.filter(
                  (e) => null === e.linkKey().value(),
                )
                t.length > 0 && this._undoModel.shareLineTools(t, 1)
            }
        }
        getDrawingSyncState() {
          var e
          if (!this.canBeSyncedInLayout()) return null
          if (jo) {
            const t =
              null === (e = this._lineTools[0]) || void 0 === e
                ? void 0
                : e.sharingMode().value()
            if (void 0 === t) return null
            let n = t
            if (0 !== n)
              for (const e of this._lineTools)
                if (e.sharingMode().value() !== n) {
                  n = 0
                  break
                }
            return Oo(n)
          }
          return this._lineTools.every((e) => null !== e.linkKey().value())
            ? 1
            : 0
        }
        doNotAffectChartInvalidation() {
          return No
        }
        _linkKeyChanged() {
          this._syncStateChanged.fire(
            (0, M.ensureNotNull)(this.getDrawingSyncState()),
          )
        }
        _canInsertBeforeOrAfter(e) {
          return Lo(this.pane(), e)
        }
        _insertSources(e, t) {
          this._undoModel.beginUndoMacro(ko)
          const n = e.reduce((e, t) => t.addSourcesToArray(e), [])
          e.forEach((e) => e.detachFromParent()),
            t(n),
            this._undoModel.endUndoMacro()
        }
        _insertBeforeTarget() {
          return (0, M.ensureNotNull)(
            this._lineTools.reduce(
              (e, t) => (null === e ? t : e.zorder() < t.zorder() ? e : t),
              null,
            ),
          )
        }
        _insertAfterTarget() {
          return (0, M.ensureNotNull)(
            this._lineTools.reduce(
              (e, t) => (null === e ? t : e.zorder() > t.zorder() ? e : t),
              null,
            ),
          )
        }
        _unsubscribeFromAllLineTools() {
          this._lineTools.forEach((e) => {
            e.properties().visible.listeners().unsubscribeAll(this),
              e.properties().frozen.listeners().unsubscribeAll(this),
              e.onIsActualIntervalChange().unsubscribeAll(this),
              e.linkKey().unsubscribe(this._linkKeyChangedBound),
              e.sharingMode().unsubscribe(this._linkKeyChangedBound)
          })
        }
      }
      class zo {
        constructor(e) {
          ;(this._hoveredObjectChanged = new oo.Delegate()),
            (this._entitiesCache = new Map()),
            (this._undoModel = e),
            this._undoModel
              .model()
              .hoveredSourceChanged()
              .subscribe(this, this._onModelHoveredSourceChanged)
        }
        destroy() {
          for (const e of this._entitiesCache.values()) null == e || e.destroy()
          this._undoModel
            .model()
            .hoveredSourceChanged()
            .unsubscribe(this, this._onModelHoveredSourceChanged)
        }
        getObjectById(e) {
          if (this._entitiesCache.has(e))
            return (0, M.ensureDefined)(this._entitiesCache.get(e))
          const t = this._createObjectById(e)
          return this._entitiesCache.set(e, t), t
        }
        invalidateCache(e) {
          Array.from(this._entitiesCache.keys()).forEach((t) => {
            var n
            e.has(t) ||
              (null === (n = this._entitiesCache.get(t)) ||
                void 0 === n ||
                n.destroy(),
              this._entitiesCache.delete(t))
          })
        }
        canBeGroupped(e) {
          if (0 === e.length || (1 === e.length && e[0].hasChildren()))
            return !1
          const t = []
          if (
            (e.forEach((e) => e.addSourcesToArray(t)),
            t.some((e) => !(0, po.isLineTool)(e) || !e.boundToSymbol()))
          )
            return !1
          const n = this._undoModel.model(),
            o = t.map((e) => n.paneForSource(e))
          if (new Set(o).size > 1) return !1
          if (!jo) return !0
          const r = t.map((e) => e.sharingMode().value())
          return 1 === new Set(r).size
        }
        contextMenuActions(e, t, n) {
          const o = new bo.ActionsProvider(e, n),
            r = []
          return (
            t.forEach((e) => e.addSourcesToArray(r)),
            o.contextMenuActionsForSources(r)
          )
        }
        insertBefore(e, t) {
          t.insertSourcesAfterThis(e)
        }
        insertAfter(e, t) {
          t.insertSourcesBeforeThis(e)
        }
        setHoveredObject(e) {
          const t = this._undoModel.model()
          if (null === e) return void t.setHoveredSource(null, null)
          const n = t.dataSourceForId(e)
          null !== n && t.setHoveredSource(n, null)
        }
        hoveredObjectId() {
          return xo(this._undoModel.model().hoveredSource())
        }
        hoveredObjectChanged() {
          return this._hoveredObjectChanged
        }
        _onModelHoveredSourceChanged(e) {
          this._hoveredObjectChanged.fire(xo(e))
        }
        _createObjectById(e) {
          const t = so(e).persistentId,
            n = this._undoModel.model(),
            o = n.dataSourceForId(t)
          if (null !== o) return new Bo(this._undoModel, o)
          const r = n.lineToolsGroupModel().groupForId(t)
          return null !== r ? new Po(this._undoModel, r) : null
        }
      }
      Error
      var Fo = n(80842),
        Wo = n(10643),
        Go = n(39347),
        Ho = n(97874),
        Vo = n(2872),
        Uo = n(84959),
        Ko = n(91730),
        Zo = n(33055),
        Yo = n(35149),
        $o = n(76544)
      const qo = (0, s.getLogger)('Platform.GUI.ObjectTree')
      const Qo = new uo.TranslatedString(
          'move objects',
          p.t(null, void 0, n(40566)),
        ),
        Xo = new uo.TranslatedString(
          'lock objects',
          p.t(null, void 0, n(68163)),
        ),
        Jo = new uo.TranslatedString(
          'unlock objects',
          p.t(null, void 0, n(66824)),
        ),
        er = new uo.TranslatedString(
          'show objects',
          p.t(null, void 0, n(63549)),
        ),
        tr = new uo.TranslatedString(
          'hide objects',
          p.t(null, void 0, n(28506)),
        ),
        nr = new uo.TranslatedString(
          'remove objects',
          p.t(null, void 0, n(57428)),
        )
      class or {
        constructor(e) {
          ;(this._nodes = {}),
            (this._onChange = new oo.Delegate()),
            (this._onGroupCreated = new oo.Delegate()),
            (this._subscriptions = []),
            (this._removeSourcesPromise = null),
            (this._timeout = null),
            (this._objects = []),
            (this._options = {
              general: !0,
              mainSeries: !0,
              mainSeriesTrade: !0,
              esdStudies: !0,
              fundamentals: !0,
              studies: !0,
              lineTools: !0,
              publishedCharts: !0,
              ordersAndPositions: !0,
              alerts: !1,
              chartEvents: !0,
              objectTree: !1,
              gotoLineTool: !0,
            }),
            (this._isContextMenuOpened = new ho.WatchedValue(!1)),
            (this._getObjectsToModify = (e) => {
              const t = this.selection().selected()
              return t.find((t) => t === e)
                ? t.map(this._ensuredEntity)
                : [this._ensuredEntity(e)]
            }),
            (this._onActiveChartChanged = () => {
              this._cleanup(), this._init()
            }),
            (this._cleanup = () => {
              null !== this._timeout &&
                (clearTimeout(this._timeout), (this._timeout = null)),
                this._subscriptions.forEach((e) => {
                  e.unsubscribeAll(this)
                }),
                this._selection.destroy(),
                this._chart.unsubscribe(this._onActiveChartChanged),
                null !== this._removeSourcesPromise &&
                  this._removeSourcesPromise.cancel(),
                this._facade.destroy()
            }),
            (this._init = () => {
              const e = this._chart.value()
              e.hasModel() &&
                ((this._controller = e.model()),
                (this._groupController =
                  this._controller.lineToolsGroupController()),
                (this._model = this._controller.model()),
                (this._groupModel = this._model.lineToolsGroupModel()),
                (this._facade = new zo(this._controller)),
                (this._subscriptions = [
                  this._model.mainSeries().onStyleChanged(),
                  this._model.mainSeries().dataEvents().symbolResolved(),
                  this._model.mainSeries().onIntervalChanged(),
                  this._model.panesCollectionChanged(),
                  this._model.dataSourceCollectionChanged(),
                  this._groupModel.onChanged(),
                ]),
                this._subscriptions.forEach((e) => {
                  e.subscribe(this, this._update)
                }),
                this._chart.subscribe(this._onActiveChartChanged),
                (this._selection = new lo(this._model)),
                this._update())
            }),
            (this._update = () => {
              null === this._timeout &&
                (this._timeout = setTimeout(() => {
                  this._recalculateTree(),
                    this._onChange.fire(),
                    (this._timeout = null)
                }))
            }),
            (this._ensuredEntity = (e) =>
              (0, M.ensureNotNull)(this._getEntityById(e))),
            (this._chart = e),
            this._init()
        }
        destroy() {
          this._cleanup()
        }
        getState() {
          return {
            nodes: Object.values(this._nodes),
            selection: this._selection.selected(),
          }
        }
        getChartId() {
          return this._chart.value().id()
        }
        insertSelection(e, t) {
          const n = this._facade,
            o = this.selection().selected().map(this._ensuredEntity),
            [r, i] = this._normalizeTargetAndDropType(e, t)
          this._controller.withMacro(Qo, () => {
            switch (i) {
              case 'before':
                n.insertBefore(o, r)
                break
              case 'after':
                n.insertAfter(o, r)
            }
          }),
            this._update()
        }
        entity(e) {
          return this._facade.getObjectById(e)
        }
        isMain(e) {
          return so(e.id()).persistentId === this._controller.mainSeries().id()
        }
        selection() {
          return this._selection
        }
        setIsLocked(e, t) {
          const n = this._getObjectsToModify(e),
            o = n.every((e) => e.doNotAffectChartInvalidation()),
            r = t ? Xo : Jo
          this._controller.withMacro(
            r,
            () => {
              for (const e of n) e.setLocked(t)
            },
            o,
          ),
            fn('Lock', gn(n))
        }
        setIsVisible(e, t) {
          const n = this._getObjectsToModify(e),
            o = n.every((e) => e.doNotAffectChartInvalidation()),
            r = t ? er : tr
          this._controller.withMacro(
            r,
            () => {
              for (const e of n) e.setVisible(t)
            },
            o,
          ),
            fn('Hide', gn(n))
        }
        remove(e) {
          const t = () => {
              const e = n.every((e) => e.doNotAffectChartInvalidation())
              this._controller.withMacro(
                nr,
                () => {
                  for (const e of n) e.remove()
                },
                e,
              ),
                fn('Delete', gn(n)),
                this._update()
            },
            n = this._getObjectsToModify(e)
          t()
        }
        canSelectionBeGrouped() {
          const e = this._getSelectedEntities()
          return this._facade.canBeGroupped(e)
        }
        createGroupFromSelection() {
          const e = this._groupController.createGroupFromSelection()
          fn('Create Group')
          const t = io(e.id, e.instanceId())
          this.selection().set([this._ensuredEntity(t)]),
            this._onGroupCreated.fire(t),
            this._update()
        }
        isSelectionDropable(e, t) {
          const n = this.selection().selected().map(this._ensuredEntity),
            [o, r] = this._normalizeTargetAndDropType(e, t)
          switch (r) {
            case 'after':
              return o.canInsertAfterThis(n)
            case 'before':
              return o.canInsertBeforeThis(n)
          }
        }
        onChange() {
          return this._onChange
        }
        onGroupCreated() {
          return this._onGroupCreated
        }
        isSelectionCloneable() {
          const e = this._getSelectedEntities()
          return e.length > 0 && e.every((e) => e.isClonable())
        }
        isSelectionCopiable() {
          const e = this._getSelectedEntities()
          return e.length > 0 && e.every((e) => e.isCopiable())
        }
        openProperties(e, t) {
          const n = this._model.dataSourceForId(so(e.id()).persistentId)
          this.selection().selected().length > 1 &&
          this.selection().selected().includes(e.id())
            ? this._chart.value().showSelectedSourcesProperties(t)
            : (this.selection().set([e]),
              null !== n
                ? this._controller.mainSeries() === n
                  ? this._chart
                      .value()
                      .showGeneralChartProperties(void 0, {
                        shouldReturnFocus: !0,
                      })
                  : ((0, po.isLineTool)(n) || (0, fo.isStudy)(n)) &&
                    this._chart
                      .value()
                      .showChartPropertiesForSource(n, t, {
                        shouldReturnFocus: !0,
                      })
                : this._chart
                    .value()
                    .showChartPropertiesForSources({
                      sources: this._chart
                        .value()
                        .model()
                        .selection()
                        .lineDataSources(),
                      title: e.title().value(),
                      tabName: t,
                      renamable: !0,
                    }))
        }
        canSelectionBeUnmerged() {
          const e = this._getSelectedEntities()
          return (
            1 === e.length &&
            this.canNodeWithIdBeUnmerged(so(e[0].id()).persistentId)
          )
        }
        canNodeWithIdBeUnmerged(e) {
          const t = this._model.dataSourceForId(e)
          return (
            null !== t &&
            (0, Fo.isPriceDataSource)(t) &&
            this._model.isUnmergeAvailableForSource(t)
          )
        }
        unmergeSelectionUp() {
          this._unmergeSelection(0)
        }
        unmergeSelectionDown() {
          this._unmergeSelection(1)
        }
        copySelection() {
          const e = this._getSelectedEntities(),
            t = e.map((e) =>
              (0, M.ensureNotNull)(
                this._model.dataSourceForId(so(e.id()).persistentId),
              ),
            )
          this._chart
            .value()
            .chartWidgetCollection()
            .clipboard.uiRequestCopy(t),
            fn('Copy', gn(e))
        }
        cloneSelection() {
          const e = this._getSelectedEntities(),
            t = e.map((e) =>
              (0, M.ensureNotNull)(
                this._model.dataSourceForId(so(e.id()).persistentId),
              ),
            )
          t.every(po.isLineTool) &&
            (this._controller.cloneLineTools([...t], !1), fn('Clone', gn(e)))
        }
        rename(e, t) {
          const n = this._getObjectsToModify(e.id())
          1 === n.length &&
            n.some((e) => e.canBeRenamed()) &&
            (t(), fn('Rename', gn(n)))
        }
        async openContextMenu(e, t, n) {
          var o
          this._objects = this._getObjectsToModify(e.id())
          const r = this._facade.canBeGroupped(this._objects)
          let i
          if (this._objects.some((e) => e.hasChildren()))
            i = this._getActionsForGroupItem(e, t, r)
          else {
            const e = await this._facade.contextMenuActions(
              this._chart.value(),
              this._objects,
              this._options,
            )
            if (
              ((i = Array.from(e).filter(
                (e, t, n) =>
                  'separator' !== e.type ||
                  !n[t + 1] ||
                  'separator' !== n[t + 1].type,
              )),
              1 === this._objects.length && this._objects[0].canBeRenamed())
            ) {
              const e = i.findIndex((e) => 'Copy' === e.id)
              i.splice(-1 === e ? i.length : e + 1, 0, this._getRenameAction(t))
            }
            if (r) {
              const e = i.findIndex((e) => 'Clone' === e.id)
              i.splice(-1 === e ? 0 : e, 0, this._getGroupAction())
            }
          }
          if (i.length > 0) {
            this._chart.value().updateActions()
            const t = so(e.id()).persistentId,
              r = this._model.dataSourceForId(t),
              s = r instanceof $o.Series,
              l = 0 !== e.childrenIds().size
            let a
            ;(a = s
              ? {
                  menuName: 'ObjectTreeContextMenu',
                  detail: { type: 'series', id: r.instanceId() },
                }
              : (0, po.isLineTool)(r)
                ? {
                    menuName: 'ObjectTreeContextMenu',
                    detail: {
                      type: 'shape',
                      id:
                        null !== (o = null == r ? void 0 : r.id()) &&
                        void 0 !== o
                          ? o
                          : null,
                    },
                  }
                : l
                  ? {
                      menuName: 'ObjectTreeContextMenu',
                      detail: {
                        type: 'groupOfShapes',
                        id: t || null,
                      },
                    }
                  : {
                      menuName: 'ObjectTreeContextMenu',
                      detail: {
                        type: 'study',
                        id: (null == r ? void 0 : r.id()) || null,
                      },
                    }),
              Wo.ContextMenuManager.showMenu(
                i,
                n,
                { takeFocus: !0, returnFocus: !0 },
                a,
                () => {
                  this._isContextMenuOpened.setValue(!1)
                },
              ).then(() => {
                this._isContextMenuOpened.setValue(!0)
              })
          }
        }
        setHoveredObject(e) {
          this._facade.setHoveredObject(e)
        }
        hoveredObjectChanged() {
          return this._facade.hoveredObjectChanged()
        }
        getNextNodeIdAfterRemove(e) {
          var t
          const { nodes: n } = this.getState(),
            o = so(e).persistentId,
            r = n.find((t) => t.id === e),
            i = this.entity(e)
          if (!(r && r.parentId && i && i.canBeRemoved())) return null
          if (
            (null === (t = i.pane().mainDataSource()) || void 0 === t
              ? void 0
              : t.id()) === o &&
            !this.canNodeWithIdBeUnmerged(o)
          ) {
            const e = n.filter((e) => 0 === e.level).map((e) => e.id),
              t = this._takeNextOrPrevElement(e, r.parentId)
            return (0, M.ensureDefined)(n.find((e) => e.id === t)).children[0]
          }
          const s = (0, M.ensureDefined)(
            n.find((e) => e.id === r.parentId),
          ).children
          return 1 === s.length
            ? this.getNextNodeIdAfterRemove(r.parentId)
            : this._takeNextOrPrevElement(s, e)
        }
        isContextMenuOpened() {
          return this._isContextMenuOpened.readonly()
        }
        getChartLayout() {
          return this._chart.value().chartWidgetCollection().layout
        }
        _takeNextOrPrevElement(e, t) {
          const n = e.indexOf(t)
          return e[n === e.length - 1 ? n - 1 : n + 1]
        }
        _getGroupAction() {
          return new Go.Action({
            actionId: 'ObjectsTree.CreateGroup',
            options: {
              label: jn,
              icon: P,
              onExecute: () => {
                this.createGroupFromSelection()
              },
            },
          })
        }
        _getRenameAction(e) {
          return new Go.Action({
            actionId: 'ObjectsTree.RenameItem',
            options: {
              label: On,
              icon: Zo,
              onExecute: () => {
                e(), fn('Context menu rename', gn(this._objects))
              },
            },
          })
        }
        _getActionsForGroupItem(e, t, n) {
          const o = []
          this._objects.forEach((e) => e.addSourcesToArray(o))
          const r = []
          1 === this._objects.length &&
            r.unshift(this._getRenameAction(t), new Go.Separator()),
            n && r.unshift(this._getGroupAction(), new Go.Separator())
          const i = (0, bo.createSyncDrawingActions)(
            this._chart.value(),
            o.filter(po.isLineTool),
          )
          i.length && (i.shift(), i.push(new Go.Separator()), r.push(...i))
          const s = this._chart.value().actions().format.getState()
          return (
            r.push(
              new Go.Action({
                actionId: 'ObjectsTree.ToggleItemLocked',
                options: {
                  label: e.isLocked() ? Bn : Pn,
                  icon: e.isLocked() ? Ho : Vo,
                  onExecute: () => this.setIsLocked(e.id(), !e.isLocked()),
                },
              }),
              new Go.Action({
                actionId: 'ObjectsTree.ToggleItemVisibility',
                options: {
                  label: e.isVisible() ? zn : Fn,
                  icon: e.isVisible() ? Uo : Ko,
                  onExecute: () => this.setIsVisible(e.id(), !e.isVisible()),
                },
              }),
              new Go.Action({
                actionId: 'ObjectsTree.RemoveItem',
                options: {
                  label: Wn,
                  icon: Yo,
                  onExecute: () => this.remove(e.id()),
                  hotkeyHash: E.isMacKeyboard ? 8 : 46,
                },
              }),
              new Go.Separator(),
              new Go.Action({
                actionId: s.actionId,
                options: {
                  label: s.label,
                  icon: s.icon,
                  onExecute: () => this.openProperties(e),
                },
              }),
            ),
            r
          )
        }
        _unmergeSelection(e) {
          const t = this._getSelectedEntities()
          if (1 !== t.length) throw new Error('Only one object can be unmerged')
          const n = t[0],
            o = (0, M.ensureNotNull)(
              this._model.dataSourceForId(so(n.id()).persistentId),
            )
          if (!(0, Fo.isPriceDataSource)(o))
            throw new Error('Entity is not IPriceDataSource')
          ;(0 === e
            ? this._controller.unmergeSourceUp
            : this._controller.unmergeSourceDown
          ).call(this._controller, o)
          fn(0 === e ? 'New pane above' : 'New pane below', gn([n]))
        }
        _recalculateTree() {
          const e = new ao(this._controller, this._facade)
          this._nodes = e.buildTree()
        }
        _normalizeTargetAndDropType(e, t) {
          let n = this._ensuredEntity(e)
          return (
            'inside' === t &&
              ((t = 'before'),
              (n = (0, M.ensureNotNull)(
                this.entity([...n.childrenIds()].shift() || ''),
              ))),
            [n, t]
          )
        }
        _getSelectedEntities() {
          const { selected: e, removed: t } = this._selection.selected().reduce(
            (e, t) => {
              const n = this._getEntityById(t)
              return n ? (e.selected.push(n), e) : (e.removed.push(t), e)
            },
            { selected: [], removed: [] },
          )
          return (
            t.length &&
              qo.logWarn(
                `Detected dangling sources in selection. They will be ignored: ${JSON.stringify(t)}`,
              ),
            e
          )
        }
        _getEntityById(e) {
          return this._facade.getObjectById(e)
        }
      }
      var rr = n(85067)
      class ir extends rr.DialogRenderer {
        constructor() {
          super(),
            (this._handleClose = () => {
              r.unmountComponentAtNode(this._container),
                this._setVisibility(!1),
                null !== this._viewModel &&
                  (this._viewModel.destroy(), (this._viewModel = null))
            })
          const e = (0, to.service)(no.CHART_WIDGET_COLLECTION_SERVICE)
          ;(this._activeChartWidget = e.activeChartWidget.value()),
            (this._viewModel = new or(e.activeChartWidget))
        }
        hide() {
          this._handleClose()
        }
        isVisible() {
          return this.visible().value()
        }
        show() {
          h().then(() => {
            null !== this._viewModel &&
              (r.render(
                o.createElement(Jn, {
                  onClose: this._handleClose,
                  viewModel: this._viewModel,
                  activeChartWidget: this._activeChartWidget,
                }),
                this._container,
              ),
              this._setVisibility(!0))
          })
        }
      }
    },
    36947: (e, t, n) => {
      n.d(t, { useForceUpdate: () => o.useForceUpdate })
      var o = n(125)
    },
    77975: (e, t, n) => {
      n.d(t, { useWatchedValueReadonly: () => r })
      var o = n(50959)
      const r = (e, t = !1) => {
        const n = 'watchedValue' in e ? e.watchedValue : void 0,
          r = 'defaultValue' in e ? e.defaultValue : e.watchedValue.value(),
          [i, s] = (0, o.useState)(n ? n.value() : r)
        return (
          (t ? o.useLayoutEffect : o.useEffect)(() => {
            if (n) {
              s(n.value())
              const e = (e) => s(e)
              return n.subscribe(e), () => n.unsubscribe(e)
            }
            return () => {}
          }, [n]),
          i
        )
      }
    },
    63932: (e, t, n) => {
      n.d(t, { Spinner: () => s })
      var o = n(50959),
        r = n(97754),
        i = n(58096)
      n(83135)
      function s(e) {
        const t = r(
          e.className,
          'tv-spinner',
          'tv-spinner--shown',
          `tv-spinner--size_${i.spinnerSizeMap[e.size || i.DEFAULT_SIZE]}`,
        )
        return o.createElement('div', {
          className: t,
          style: e.style,
          role: 'progressbar',
        })
      }
    },
    36898: (e, t, n) => {
      n.d(t, { useMouseClickAutoBlur: () => s })
      var o = n(50959),
        r = n(76460),
        i = n(16838)
      function s(e, t = !0) {
        ;(0, o.useEffect)(() => {
          if (!i.PLATFORM_ACCESSIBILITY_ENABLED || !t) return
          const n = (t) => {
            const n = e.current
            null !== n &&
              document.activeElement instanceof HTMLElement &&
              ((0, r.isKeyboardClick)(t) ||
                (n.contains(document.activeElement) &&
                  'INPUT' !== document.activeElement.tagName &&
                  document.activeElement.blur()))
          }
          return (
            window.addEventListener('click', n, !0),
            () => window.removeEventListener('click', n, !0)
          )
        }, [t])
      }
    },
    48889: (e, t, n) => {
      n.d(t, { ToolbarIconButton: () => l })
      var o = n(50959),
        r = n(50238),
        i = n(16838),
        s = n(50813)
      const l = (0, o.forwardRef)((e, t) => {
        const { tooltip: n, ...l } = e,
          [a, c] = (0, r.useRovingTabindexElement)(t)
        return o.createElement(s.ToolWidgetIconButton, {
          'aria-label': i.PLATFORM_ACCESSIBILITY_ENABLED ? n : void 0,
          ...l,
          tag: i.PLATFORM_ACCESSIBILITY_ENABLED ? 'button' : 'div',
          ref: a,
          tabIndex: c,
          'data-tooltip': n,
        })
      })
    },
    50298: (e, t, n) => {
      n.d(t, { ToolbarMenuButton: () => u })
      var o = n(50959),
        r = n(39416),
        i = n(8087),
        s = n(50238),
        l = n(16838),
        a = n(36898),
        c = n(81261)
      const u = (0, o.forwardRef)((e, t) => {
        const { tooltip: n, menuReference: u = null, ...d } = e,
          [h, p] = (0, s.useRovingTabindexElement)(null),
          f = (0, r.useFunctionalRefObject)(u)
        return (
          (0, a.useMouseClickAutoBlur)(f),
          o.createElement(i.ToolWidgetMenu, {
            'aria-label': l.PLATFORM_ACCESSIBILITY_ENABLED ? n : void 0,
            ...d,
            ref: t,
            tag: l.PLATFORM_ACCESSIBILITY_ENABLED ? 'button' : 'div',
            reference: h,
            tabIndex: p,
            'data-tooltip': n,
            menuReference: f,
            onMenuKeyDown: c.handleAccessibleMenuKeyDown,
            onMenuFocus: (e) => (0, c.handleAccessibleMenuFocus)(e, h),
          })
        )
      })
    },
    54079: (e, t, n) => {
      n.d(t, { Toolbar: () => d })
      var o = n(50959),
        r = n(50151),
        i = n(47201),
        s = n(3343),
        l = n(16838),
        a = n(71468),
        c = n(39416),
        u = n(36898)
      const d = (0, o.forwardRef)((e, t) => {
        const {
            onKeyDown: n,
            orientation: d,
            blurOnEscKeydown: h = !0,
            blurOnClick: p = !0,
            ...f
          } = e,
          g = l.PLATFORM_ACCESSIBILITY_ENABLED
            ? { role: 'toolbar', 'aria-orientation': d }
            : {},
          v = (0, c.useFunctionalRefObject)(t)
        return (
          (0, o.useLayoutEffect)(() => {
            if (!l.PLATFORM_ACCESSIBILITY_ENABLED) return
            const e = (0, r.ensureNotNull)(v.current),
              t = () => {
                const t = (0, l.queryTabbableElements)(e).sort(
                  l.navigationOrderComparator,
                )
                if (0 === t.length) {
                  const [t] = (0, l.queryFocusableElements)(e).sort(
                    l.navigationOrderComparator,
                  )
                  if (void 0 === t) return
                  ;(0, a.becomeMainElement)(t)
                }
                if (t.length > 1) {
                  const [, ...e] = t
                  for (const t of e) (0, a.becomeSecondaryElement)(t)
                }
              }
            return (
              window.addEventListener('keyboard-navigation-activation', t),
              () =>
                window.removeEventListener('keyboard-navigation-activation', t)
            )
          }, []),
          (0, u.useMouseClickAutoBlur)(v, p),
          o.createElement('div', {
            ...f,
            ...g,
            ref: v,
            onKeyDown: (0, i.createSafeMulticastEventHandler)((e) => {
              if (!l.PLATFORM_ACCESSIBILITY_ENABLED) return
              if (e.defaultPrevented) return
              if (!(document.activeElement instanceof HTMLElement)) return
              const t = (0, s.hashFromEvent)(e)
              if (h && 27 === t)
                return e.preventDefault(), void document.activeElement.blur()
              if ('vertical' !== d && 37 !== t && 39 !== t) return
              if ('vertical' === d && 38 !== t && 40 !== t) return
              const n = e.currentTarget,
                o = (0, l.queryFocusableElements)(n).sort(
                  l.navigationOrderComparator,
                )
              if (0 === o.length) return
              const r = o.indexOf(document.activeElement)
              if (-1 === r) return
              e.preventDefault()
              const i = () => {
                  const e = (r + o.length - 1) % o.length
                  ;(0, a.becomeSecondaryElement)(o[r]),
                    (0, a.becomeMainElement)(o[e]),
                    o[e].focus()
                },
                c = () => {
                  const e = (r + o.length + 1) % o.length
                  ;(0, a.becomeSecondaryElement)(o[r]),
                    (0, a.becomeMainElement)(o[e]),
                    o[e].focus()
                }
              switch ((0, l.mapKeyCodeToDirection)(t)) {
                case 'inlinePrev':
                  'vertical' !== d && i()
                  break
                case 'inlineNext':
                  'vertical' !== d && c()
                  break
                case 'blockPrev':
                  'vertical' === d && i()
                  break
                case 'blockNext':
                  'vertical' === d && c()
              }
            }, n),
          })
        )
      })
    },
    36296: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M8 9.5H6.5a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1V20m-8-1.5h11a1 1 0 0 0 1-1v-11a1 1 0 0 0-1-1h-11a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1z"/></svg>'
    },
    33055: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M17.086 6.207a2 2 0 0 1 2.828 0l1.879 1.879a2 2 0 0 1 0 2.828l-.94.94-9 9-1 1-.146.146H6v-4.707l.146-.146 1-1 9-9 .94-.94zm2.121.707a1 1 0 0 0-1.414 0l-.586.586 1.647 1.646 1.646 1.647.586-.586a1 1 0 0 0 0-1.414l-1.879-1.879zm.586 4.586L18.5 10.207 10.207 18.5l1.293 1.293 8.293-8.293zm-9 9l-1.647-1.646L7.5 17.207l-.5.5V21h3.293l.5-.5zm-2.586-4L9.5 17.793 17.793 9.5 16.5 8.207 8.207 16.5z"/></svg>'
    },
    69533: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path stroke="currentColor" d="M8 5l3.5 3.5L8 12"/></svg>'
    },
    57674: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M5.5 11.5v8a1 1 0 0 0 1 1h15a1 1 0 0 0 1-1v-8m-17 0v-4a1 1 0 0 1 1-1h4l2 2h9a1 1 0 0 1 1 1v2m-17 0h17"/></svg>'
    },
    80465: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M5.5 6C4.67 6 4 6.67 4 7.5V20.5c0 .83.67 1.5 1.5 1.5H16v-1H5.5a.5.5 0 0 1-.5-.5V12h16v1h1V9.5c0-.83-.67-1.5-1.5-1.5h-8.8L9.86 6.15 9.71 6H5.5zM21 11H5V7.5c0-.28.22-.5.5-.5h3.8l1.85 1.85.14.15h9.21c.28 0 .5.22.5.5V11zm1 11v-3h3v-1h-3v-3h-1v3h-3v1h3v3h1z"/></svg>'
    },
    94007: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M2.448 10.124a10.82 10.82 0 0 1-.336-.609L2.105 9.5l.007-.015a12.159 12.159 0 0 1 1.686-2.466C5.002 5.665 6.752 4.373 9.05 4.373c2.297 0 4.047 1.292 5.25 2.646a12.166 12.166 0 0 1 1.687 2.466l.007.015-.007.015a12.163 12.163 0 0 1-1.686 2.466c-1.204 1.354-2.954 2.646-5.251 2.646-2.298 0-4.048-1.292-5.252-2.646a12.16 12.16 0 0 1-1.35-1.857zm14.558-.827l-.456.203.456.203v.002l-.003.005-.006.015-.025.052a11.813 11.813 0 0 1-.461.857 13.163 13.163 0 0 1-1.463 2.011c-1.296 1.46-3.296 2.982-5.998 2.982-2.703 0-4.703-1.522-6-2.982a13.162 13.162 0 0 1-1.83-2.677 7.883 7.883 0 0 1-.118-.243l-.007-.015-.002-.005v-.001l.456-.204-.456-.203v-.002l.002-.005.007-.015a4.66 4.66 0 0 1 .119-.243 13.158 13.158 0 0 1 1.83-2.677c1.296-1.46 3.296-2.982 5.999-2.982 2.702 0 4.702 1.522 5.998 2.981a13.158 13.158 0 0 1 1.83 2.678 8.097 8.097 0 0 1 .119.243l.006.015.003.005v.001zm-.456.203l.456-.203.09.203-.09.203-.456-.203zM1.092 9.297l.457.203-.457.203-.09-.203.09-.203zm9.958.203c0 1.164-.917 2.07-2 2.07-1.084 0-2-.906-2-2.07 0-1.164.916-2.07 2-2.07 1.083 0 2 .906 2 2.07zm1 0c0 1.695-1.344 3.07-3 3.07-1.657 0-3-1.375-3-3.07 0-1.695 1.343-3.07 3-3.07 1.656 0 3 1.375 3 3.07z"/></svg>'
    },
    52870: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M7 5.5a2.5 2.5 0 0 1 5 0V7H7V5.5zM6 7V5.5a3.5 3.5 0 1 1 7 0V7a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2zm8 2a1 1 0 0 0-1-1H6a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1V9zm-3 2.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></svg>'
    },
    74059: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M21.106 12.5H6.894a.5.5 0 0 1-.318-.886L14 5.5l7.424 6.114a.5.5 0 0 1-.318.886zM21.106 16.5H6.894a.5.5 0 0 0-.318.886L14 23.5l7.424-6.114a.5.5 0 0 0-.318-.886z"/></svg>'
    },
    91730: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M4.605 14.089A10.052 10.052 0 0 1 4.56 14l.046-.089a17.18 17.18 0 0 1 2.329-3.327C8.58 8.758 10.954 7 14 7c3.046 0 5.421 1.757 7.066 3.585A17.18 17.18 0 0 1 23.44 14l-.046.089a17.18 17.18 0 0 1-2.329 3.327C19.42 19.242 17.046 21 14 21c-3.046 0-5.421-1.757-7.066-3.584a17.18 17.18 0 0 1-2.329-3.327zm19.848-.3L24 14l.453.212-.001.002-.003.005-.009.02a16.32 16.32 0 0 1-.662 1.195c-.44.72-1.1 1.684-1.969 2.65C20.08 20.008 17.454 22 14 22c-3.454 0-6.079-1.993-7.81-3.916a18.185 18.185 0 0 1-2.469-3.528 10.636 10.636 0 0 1-.161-.318l-.01-.019-.002-.005v-.002L4 14a55.06 55.06 0 0 1-.453-.212l.001-.002.003-.005.009-.02.033-.067a16.293 16.293 0 0 1 .629-1.126c.44-.723 1.1-1.686 1.969-2.652C7.92 7.993 10.546 6 14 6c3.454 0 6.079 1.993 7.81 3.916a18.183 18.183 0 0 1 2.469 3.528 10.588 10.588 0 0 1 .161.318l.01.019.002.005v.002zM24 14l.453-.211.099.211-.099.211L24 14zm-20.453-.211L4 14l-.453.211L3.448 14l.099-.211zM11 14a3 3 0 1 1 6 0 3 3 0 0 1-6 0zm3-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8zm0 5a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/></svg>'
    },
    7295: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="none"><path stroke="currentColor" d="M4.5 12.5l4.59-4.59a2 2 0 0 1 2.83 0l3.17 3.17a2 2 0 0 0 2.83 0L22.5 6.5m-8 9.5v5.5M12 19l2.5 2.5L17 19m4.5 3v-5.5M19 19l2.5-2.5L24 19"/></svg>'
    },
    28824: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path stroke="currentColor" d="M5.5 16.5l4.586-4.586a2 2 0 0 1 2.828 0l3.172 3.172a2 2 0 0 0 2.828 0L23.5 10.5"/></svg>'
    },
    49756: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M11.5 4A2.5 2.5 0 0 0 7 5.5V7h6a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2V5.5a3.5 3.5 0 0 1 6.231-2.19c-.231.19-.73.69-.73.69zM13 8H6a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h7a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1zm-2 3.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></svg>'
    },
    62766: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M14.692 3.012l-12 12.277.715.699 12-12.277-.715-.699zM9.05 15.627a7.042 7.042 0 0 1-3.144-.741l.742-.76c.72.311 1.52.5 2.402.5 2.297 0 4.047-1.29 5.25-2.645a12.168 12.168 0 0 0 1.687-2.466l.007-.015-.007-.015A12.166 12.166 0 0 0 14.3 7.019c-.11-.124-.225-.247-.344-.37l.699-.715c.137.14.268.28.392.42a13.16 13.16 0 0 1 1.83 2.678 8.117 8.117 0 0 1 .119.243l.006.015.003.005v.001l-.456.204.456.203v.002l-.003.005-.006.015-.025.052a11.762 11.762 0 0 1-.461.857 13.158 13.158 0 0 1-1.463 2.011c-1.296 1.46-3.296 2.982-5.998 2.982zm7.5-6.127l.456-.203.09.203-.09.203-.456-.203zm-7.5 3.07c-.27 0-.53-.037-.778-.105l.879-.899c.999-.052 1.833-.872 1.895-1.938l.902-.923c.066.253.102.52.102.795 0 1.695-1.344 3.07-3 3.07zM6.15 10.294l.902-.923c.063-1.066.896-1.886 1.895-1.938l.879-.9a2.94 2.94 0 0 0-.777-.103c-1.657 0-3 1.374-3 3.069 0 .275.035.541.101.795zM9.05 4.373c.88 0 1.68.19 2.4.5l.743-.759a7.043 7.043 0 0 0-3.143-.74c-2.703 0-4.703 1.521-6 2.98a13.159 13.159 0 0 0-1.83 2.678 7.886 7.886 0 0 0-.118.243l-.007.015-.002.005v.001l.456.204-.457-.203-.09.203.09.203.457-.203-.456.203v.002l.002.005.007.015a4.5 4.5 0 0 0 .119.243 13.152 13.152 0 0 0 1.83 2.677c.124.14.255.28.392.42l.7-.715c-.12-.122-.235-.245-.345-.369a12.156 12.156 0 0 1-1.686-2.466L2.105 9.5l.007-.015a12.158 12.158 0 0 1 1.686-2.466C5.002 5.665 6.752 4.373 9.05 4.373z"/></svg>'
    },
    98129: (e) => {
      e.exports = {
        ar: ['  '],
        ca_ES: ['Clona, Copia'],
        cs: 'Clone, Copy',
        de: ['Klonen, Kopieren'],
        el: 'Clone, Copy',
        en: 'Clone, Copy',
        es: ['Clonar, Copiar'],
        fa: 'Clone, Copy',
        fr: ['Cloner, Copier'],
        he_IL: [', '],
        hu_HU: 'Clone, Copy',
        id_ID: ['Duplikat, Salin'],
        it: ['Clona, copia'],
        ja: [''],
        ko: [', '],
        ms_MY: ['Klon, Salin'],
        nl_NL: 'Clone, Copy',
        pl: ['Klonuj, Kopiuj'],
        pt: ['Clonar, Copiar'],
        ro: 'Clone, Copy',
        ru: [', '],
        sv: ['Klon, kopiera'],
        th: [', '],
        tr: ['Klonla, Kopyala'],
        vi: ['Nhn bn, Sao chp'],
        zh: [''],
        zh_TW: [''],
      }
    },
    91073: (e) => {
      e.exports = {
        ar: ['   '],
        ca_ES: ['Creeu un grup de grfics'],
        cs: 'Create a group of drawings',
        de: ['Erstellen Sie eine Gruppe von Zeichnungen'],
        el: 'Create a group of drawings',
        en: 'Create a group of drawings',
        es: ['Cree un grupo de graficos'],
        fa: 'Create a group of drawings',
        fr: ['Crer un groupe de dessins'],
        he_IL: ['  '],
        hu_HU: 'Create a group of drawings',
        id_ID: ['Buat kelompok untuk gambar'],
        it: ['Crea un gruppo di disegni'],
        ja: [''],
        ko: ['  '],
        ms_MY: ['Cipta kumpulan untuk lukisan'],
        nl_NL: 'Create a group of drawings',
        pl: ['Utwrz grup obiektw rysowania'],
        pt: ['Criar um grupo de desenhos'],
        ro: 'Create a group of drawings',
        ru: ['   '],
        sv: ['Skapa en grup ritningar'],
        th: [''],
        tr: ['Bir grup izim oluturun'],
        vi: ['To nhm cc hnh v'],
        zh: [''],
        zh_TW: [''],
      }
    },
    38207: (e) => {
      e.exports = {
        ar: ['     '],
        ca_ES: ["El grup est ocult a l'interval actual"],
        cs: 'Group is hidden on current interval',
        de: ['Gruppe ist im aktuellen Intervall verborgen'],
        el: 'Group is hidden on current interval',
        en: 'Group is hidden on current interval',
        es: ['El grupo est oculto en el intervalo actual'],
        fa: 'Group is hidden on current interval',
        fr: ["Le groupe est cach sur l'intervalle actuel"],
        he_IL: ['   '],
        hu_HU: 'Group is hidden on current interval',
        id_ID: ['Grup disembunyikan pada interval saat ini'],
        it: ['Il gruppo  nascosto nel timeframe corrente'],
        ja: [''],
        ko: ['     '],
        ms_MY: ['Kumpulan disembunyikan pada selang masa sekarang'],
        nl_NL: 'Group is hidden on current interval',
        pl: ['Grupa jest ukryta na biecym interwale'],
        pt: ['O grupo est oculto no intervalo atual'],
        ro: 'Group is hidden on current interval',
        ru: ['    '],
        sv: ['Gruppen r dold i det aktuella intervallet'],
        th: [''],
        tr: ['Grup u anki aralkta gizli'],
        vi: ['Nhm c n trong ch  hin ti'],
        zh: [''],
        zh_TW: [''],
      }
    },
    39781: (e) => {
      e.exports = {
        ar: ['     '],
        ca_ES: ["El dibuix est ocult a l'interval actual"],
        cs: 'Drawing is hidden on current interval',
        de: ['Zeichnung ist fr das aktuelle Intervall ausgeblendet'],
        el: 'Drawing is hidden on current interval',
        en: 'Drawing is hidden on current interval',
        es: ['El dibujo est oculto en el intervalo actual'],
        fa: 'Drawing is hidden on current interval',
        fr: ["Le dessin est cach sur l'intervalle actuel"],
        he_IL: ['   '],
        hu_HU: 'Drawing is hidden on current interval',
        id_ID: ['Gambar disembunyikan pada interval saat ini'],
        it: ['Il disegno  nascosto sul timeframe corrente'],
        ja: [''],
        ko: ['    '],
        ms_MY: ['Lukisan disembunyikan pada selang masa terkini'],
        nl_NL: 'Drawing is hidden on current interval',
        pl: ['Rysunek jest ukryty na biecym interwale'],
        pt: ['O desenho est oculto no intervalo atual'],
        ro: 'Drawing is hidden on current interval',
        ru: ['     '],
        sv: ['Ritning r dold p aktuellt intervall'],
        th: [''],
        tr: ['izim, geerli aralkta gizlendi'],
        vi: ['Bn v b n trong khong thi gian hin ti'],
        zh: [''],
        zh_TW: [''],
      }
    },
    31095: (e) => {
      e.exports = {
        ar: [' '],
        ca_ES: ["Arbre d'objectes"],
        cs: 'Object tree',
        de: ['Objektbaum'],
        el: 'Object tree',
        en: 'Object tree',
        es: ['rbol de objetos'],
        fa: 'Object tree',
        fr: ['Arborescence des objets'],
        he_IL: [' '],
        hu_HU: 'Object tree',
        id_ID: ['Pohon objek'],
        it: ['Albero oggetti'],
        ja: [''],
        ko: [' '],
        ms_MY: ['Salasilah Objek'],
        nl_NL: 'Object tree',
        pl: ['Drzewo obiektw'],
        pt: ['rvore de objetos'],
        ro: 'Object tree',
        ru: [' '],
        sv: ['Objekttrd'],
        th: [''],
        tr: ['Nesne aac'],
        vi: ['Danh sch i tng'],
        zh: [''],
        zh_TW: [''],
      }
    },
    72357: (e) => {
      e.exports = {
        ar: ['  '],
        ca_ES: ['Gestiona els dibuixos dels dissenys'],
        cs: 'Manage layout drawings',
        de: ['Zeichnungen des Layouts verwalten'],
        el: 'Manage layout drawings',
        en: 'Manage layout drawings',
        es: ['Gestionar los dibujos de los diseos'],
        fa: 'Manage layout drawings',
        fr: ['Grer les dessins de mise en page'],
        he_IL: ['  '],
        hu_HU: 'Manage layout drawings',
        id_ID: ['Kelola layout gambar'],
        it: ['Gestisci disegni del layout'],
        ja: [''],
        ko: ['  '],
        ms_MY: ['Urus susun atur lukisan'],
        nl_NL: 'Manage layout drawings',
        pl: ['Zarzdzaj rysunkami ukadu'],
        pt: ['Administre seu layout de desenhos'],
        ro: 'Manage layout drawings',
        ru: ['   '],
        sv: ['Hantera layoutritningar'],
        th: [''],
        tr: ['Yerleim izimlerini ynet'],
        vi: ['Qun l b cc hnh v'],
        zh: [''],
        zh_TW: [''],
      }
    },
    35038: (e) => {
      e.exports = {
        ar: [' '],
        ca_ES: ['Reanomenar'],
        cs: 'Rename',
        de: ['Umbenennen'],
        el: 'Rename',
        en: 'Rename',
        es: ['Renombrar.'],
        fa: 'Rename',
        fr: ['Renommer'],
        he_IL: [' '],
        hu_HU: ['tnevezs'],
        id_ID: ['Mengganti Nama'],
        it: ['Rinomina'],
        ja: [''],
        ko: [' '],
        ms_MY: ['Namakan semula'],
        nl_NL: 'Rename',
        pl: ['Zmie nazw'],
        pt: ['Renomear'],
        ro: 'Rename',
        ru: [''],
        sv: ['Dp om'],
        th: [''],
        tr: ['Yeni Ad Ver'],
        vi: ['i tn'],
        zh: [''],
        zh_TW: [''],
      }
    },
    40001: (e) => {
      e.exports = {
        ar: ['  {sourceTitle}  {newSourceTitle}'],
        ca_ES: ['canvia el ttol {sourceTitle} per {newSourceTitle}'],
        cs: 'change {sourceTitle} title to {newSourceTitle}',
        de: ['{sourceTitle} zu {newSourceTitle} ndern'],
        el: 'change {sourceTitle} title to {newSourceTitle}',
        en: 'change {sourceTitle} title to {newSourceTitle}',
        es: ['cambiar el ttulo {sourceTitle} por {newSourceTitle}'],
        fa: 'change {sourceTitle} title to {newSourceTitle}',
        fr: ['Remplacer le titre {sourceTitle} par {newSourceTitle}'],
        he_IL: ['  {sourceTitle}  - {newSourceTitle}'],
        hu_HU: 'change {sourceTitle} title to {newSourceTitle}',
        id_ID: ['Ubah judul {sourceTitle} menjadi {newSourceTitle}'],
        it: ['Cambia titolo da {sourceTitle} a {newSourceTitle}'],
        ja: ['{sourceTitle}{newSourceTitle}'],
        ko: ['{sourceTitle}  {newSourceTitle}  '],
        ms_MY: ['Tukar tajuk {sourceTitle} kepada {newSourceTitle}'],
        nl_NL: 'change {sourceTitle} title to {newSourceTitle}',
        pl: ['Zmie tytu {sourceTitle} na {newSourceTitle}.'],
        pt: ['Mudar {sourceTitle} ttulo para {newSourceTitle}'],
        ro: ['Change {sourceTitle} title to {newSourceTitle}'],
        ru: ['  {sourceTitle}  {newSourceTitle}'],
        sv: ['ndra {sourceTitle} titel till {newSourceTitle}'],
        th: [' {sourceTitle}  {newSourceTitle}'],
        tr: ['{sourceTitle} baln {newSourceTitle} olarak deitirin'],
        vi: ['Thay i {sourceTitle} tiu  sang {newSourceTitle}'],
        zh: ['{sourceTitle}{newSourceTitle}'],
        zh_TW: ['{sourceTitle}{newSourceTitle}'],
      }
    },
    28506: (e) => {
      e.exports = {
        ar: [' '],
        ca_ES: ['amaga objectes'],
        cs: 'hide objects',
        de: ['Objekte ausblenden'],
        el: 'hide objects',
        en: 'hide objects',
        es: ['ocultar objetos'],
        fa: 'hide objects',
        fr: ['masquer les objets'],
        he_IL: [' '],
        hu_HU: 'hide objects',
        id_ID: ['sembunyikan objek'],
        it: ['nascondi oggetti'],
        ja: [''],
        ko: [' '],
        ms_MY: ['sembunyi objek'],
        nl_NL: 'hide objects',
        pl: ['ukryj obiekty'],
        pt: ['ocultar objetos'],
        ro: 'hide objects',
        ru: [' '],
        sv: ['dlj objekt'],
        th: [''],
        tr: ['nesneleri gizle'],
        vi: ['n i tng'],
        zh: [''],
        zh_TW: [''],
      }
    },
    8343: (e) => {
      e.exports = {
        ar: ['  ()  '],
        ca_ES: ['introdueix font(s) desprs'],
        cs: 'insert source(s) after',
        de: ['Quelle(n) einfgen nach'],
        el: 'insert source(s) after',
        en: 'insert source(s) after',
        es: ['introducir fuente(s) despus'],
        fa: 'insert source(s) after',
        fr: ['insrer la/les source(s) aprs'],
        he_IL: [' ()  '],
        hu_HU: 'insert source(s) after',
        id_ID: ['masukkan sumber setelah'],
        it: ['inserimento fonti'],
        ja: [''],
        ko: ['~  '],
        ms_MY: ['masukkan sumber(s) selepas'],
        nl_NL: 'insert source(s) after',
        pl: ['wstaw rda po'],
        pt: ['inserir fonte(s) depois'],
        ro: 'insert source(s) after',
        ru: [' () '],
        sv: ['infoga klla(kllor) efter'],
        th: [''],
        tr: ['kayna() ardna ekle'],
        vi: ['chn (cc) ngun sau '],
        zh: [''],
        zh_TW: [''],
      }
    },
    40566: (e) => {
      e.exports = {
        ar: [' '],
        ca_ES: ['mou objectes'],
        cs: 'move objects',
        de: ['Objekte Bewegen'],
        el: 'move objects',
        en: 'move objects',
        es: ['mover objetos'],
        fa: 'move objects',
        fr: ['Dplacer les objets'],
        he_IL: [' '],
        hu_HU: 'move objects',
        id_ID: ['Pindahkan objek'],
        it: ['Sposta oggetti'],
        ja: [''],
        ko: [' '],
        ms_MY: ['Pindahkan objek'],
        nl_NL: 'move objects',
        pl: ['Przenie obiekty'],
        pt: ['Mover objetos'],
        ro: ['Move objects'],
        ru: [' '],
        sv: ['Flytta objekt'],
        th: [''],
        tr: ['nesneleri ta'],
        vi: ['Chuyn i tng'],
        zh: [''],
        zh_TW: [''],
      }
    },
    87358: (e) => {
      e.exports = {
        ar: [' {title}'],
        ca_ES: ['mostra {title}'],
        cs: 'show {title}',
        de: ['{title} anzeigen'],
        el: 'show {title}',
        en: 'show {title}',
        es: ['mostrar {title}'],
        fa: 'show {title}',
        fr: ['afficher {title}'],
        he_IL: [' {title}'],
        hu_HU: 'show {title}',
        id_ID: ['tampilkan {title}'],
        it: ['mostra {title}'],
        ja: ['{title}'],
        ko: ['{title} '],
        ms_MY: ['tunjuk {title}'],
        nl_NL: 'show {title}',
        pl: ['poka {title}'],
        pt: ['exibir {title}'],
        ro: 'show {title}',
        ru: [': {title}'],
        sv: ['visa {title}'],
        th: [' {title}'],
        tr: ['{title} gster'],
        vi: ['hin {title}'],
        zh: ['{title}'],
        zh_TW: ['{title}'],
      }
    },
    63549: (e) => {
      e.exports = {
        ar: [' '],
        ca_ES: ['mostra objectes'],
        cs: 'show objects',
        de: ['Objekte einblenden'],
        el: 'show objects',
        en: 'show objects',
        es: ['mostrar objetos'],
        fa: 'show objects',
        fr: ['afficher les objets'],
        he_IL: [' '],
        hu_HU: 'show objects',
        id_ID: ['tampilkan objek'],
        it: ['mostra oggetti'],
        ja: [''],
        ko: [' '],
        ms_MY: ['tunjuk objek'],
        nl_NL: 'show objects',
        pl: ['poka obiekty'],
        pt: ['exibir objetos'],
        ro: 'show objects',
        ru: [' '],
        sv: ['visa objekt'],
        th: [''],
        tr: ['nesneleri gster'],
        vi: ['hin th i tng'],
        zh: [''],
        zh_TW: [''],
      }
    },
    57428: (e) => {
      e.exports = {
        ar: [' '],
        ca_ES: ['elimina objectes'],
        cs: 'remove objects',
        de: ['Objekte entfernen'],
        el: 'remove objects',
        en: 'remove objects',
        es: ['eliminar objetos'],
        fa: 'remove objects',
        fr: ['supprimer les objets'],
        he_IL: [' '],
        hu_HU: 'remove objects',
        id_ID: ['Hilangkan objek'],
        it: ['rimuovi oggetti'],
        ja: [''],
        ko: [' '],
        ms_MY: ['buang objek'],
        nl_NL: 'remove objects',
        pl: ['usu obiekty'],
        pt: ['remover objetos'],
        ro: 'remove objects',
        ru: [' '],
        sv: ['Ta bort objekt'],
        th: [''],
        tr: ['nesneleri kaldr'],
        vi: ['di chuyn i tng'],
        zh: [''],
        zh_TW: [''],
      }
    },
  },
])
