;(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
  [5142, 766, 2874],
  {
    345350: (e) => {
      e.exports = {
        'nav-button': 'nav-button-znwuaSC1',
        link: 'link-znwuaSC1',
        background: 'background-znwuaSC1',
        icon: 'icon-znwuaSC1',
        'flip-icon': 'flip-icon-znwuaSC1',
        'size-large': 'size-large-znwuaSC1',
        'preserve-paddings': 'preserve-paddings-znwuaSC1',
        'size-medium': 'size-medium-znwuaSC1',
        'size-small': 'size-small-znwuaSC1',
        'size-xsmall': 'size-xsmall-znwuaSC1',
        'size-xxsmall': 'size-xxsmall-znwuaSC1',
        'visually-hidden': 'visually-hidden-znwuaSC1',
      }
    },
    101414: (e) => {
      e.exports = {
        button: 'button-D4RPB3ZC',
        content: 'content-D4RPB3ZC',
        'icon-only': 'icon-only-D4RPB3ZC',
        link: 'link-D4RPB3ZC',
        'color-brand': 'color-brand-D4RPB3ZC',
        'variant-primary': 'variant-primary-D4RPB3ZC',
        'variant-secondary': 'variant-secondary-D4RPB3ZC',
        'color-gray': 'color-gray-D4RPB3ZC',
        'color-green': 'color-green-D4RPB3ZC',
        'color-red': 'color-red-D4RPB3ZC',
        'color-black': 'color-black-D4RPB3ZC',
        'color-black-friday': 'color-black-friday-D4RPB3ZC',
        'color-cyber-monday': 'color-cyber-monday-D4RPB3ZC',
        'size-xsmall': 'size-xsmall-D4RPB3ZC',
        'start-icon-wrap': 'start-icon-wrap-D4RPB3ZC',
        'end-icon-wrap': 'end-icon-wrap-D4RPB3ZC',
        'with-start-icon': 'with-start-icon-D4RPB3ZC',
        'with-end-icon': 'with-end-icon-D4RPB3ZC',
        'size-small': 'size-small-D4RPB3ZC',
        'size-medium': 'size-medium-D4RPB3ZC',
        'size-large': 'size-large-D4RPB3ZC',
        'size-xlarge': 'size-xlarge-D4RPB3ZC',
        animated: 'animated-D4RPB3ZC',
        stretch: 'stretch-D4RPB3ZC',
        grouped: 'grouped-D4RPB3ZC',
        'adjust-position': 'adjust-position-D4RPB3ZC',
        'first-row': 'first-row-D4RPB3ZC',
        'first-col': 'first-col-D4RPB3ZC',
        'no-corner-top-left': 'no-corner-top-left-D4RPB3ZC',
        'no-corner-top-right': 'no-corner-top-right-D4RPB3ZC',
        'no-corner-bottom-right': 'no-corner-bottom-right-D4RPB3ZC',
        'no-corner-bottom-left': 'no-corner-bottom-left-D4RPB3ZC',
        'text-wrap': 'text-wrap-D4RPB3ZC',
        'multiline-content': 'multiline-content-D4RPB3ZC',
        'secondary-text': 'secondary-text-D4RPB3ZC',
        'primary-text': 'primary-text-D4RPB3ZC',
      }
    },
    192517: (e) => {
      e.exports = {
        divider: 'divider-pzdcWv_c',
        'orientation-horizontal': 'orientation-horizontal-pzdcWv_c',
        'orientation-vertical': 'orientation-vertical-pzdcWv_c',
        'size-xsmall': 'size-xsmall-pzdcWv_c',
        'size-small': 'size-small-pzdcWv_c',
        'size-medium': 'size-medium-pzdcWv_c',
        'size-large': 'size-large-pzdcWv_c',
        'size-xlarge': 'size-xlarge-pzdcWv_c',
        'size-xxlarge': 'size-xxlarge-pzdcWv_c',
        'type-primary': 'type-primary-pzdcWv_c',
      }
    },
    705734: (e) => {
      e.exports = {
        dialog: 'dialog-aRAWUDhF',
        rounded: 'rounded-aRAWUDhF',
        shadowed: 'shadowed-aRAWUDhF',
        fullscreen: 'fullscreen-aRAWUDhF',
        darker: 'darker-aRAWUDhF',
        backdrop: 'backdrop-aRAWUDhF',
      }
    },
    713450: (e) => {
      e.exports = {
        'light-tab-button': 'light-tab-button-_v4jz9BC',
        selected: 'selected-_v4jz9BC',
        content: 'content-_v4jz9BC',
        'start-icon-wrap': 'start-icon-wrap-_v4jz9BC',
      }
    },
    867941: (e) => {
      e.exports = { 'light-tabs': 'light-tabs-LqEaU5HP' }
    },
    744633: (e) => {
      e.exports = { separator: 'separator-gVkHdN_4' }
    },
    2537: (e) => {
      e.exports = {
        icon: 'icon-VykdSzLO',
        button: 'button-VykdSzLO',
        wrapper: 'wrapper-VykdSzLO',
        infoContainer: 'infoContainer-VykdSzLO',
        title: 'title-VykdSzLO',
        link: 'link-VykdSzLO',
        text: 'text-VykdSzLO',
      }
    },
    867838: (e) => {
      e.exports = {
        delayedDataTitleColor: '#F57C00',
        batsQuotesTitleColor: '#D81B60',
        header: 'header-W5uTS8cc',
        wrapper: 'wrapper-W5uTS8cc',
        statusLine: 'statusLine-W5uTS8cc',
        informer: 'informer-W5uTS8cc',
        text: 'text-W5uTS8cc',
        button: 'button-W5uTS8cc',
        settingsButton: 'settingsButton-W5uTS8cc button-W5uTS8cc',
        settingsPopupMenu: 'settingsPopupMenu-W5uTS8cc',
        delayedDataIcon: 'delayedDataIcon-W5uTS8cc',
        batsQuotesIcon: 'batsQuotesIcon-W5uTS8cc',
      }
    },
    483830: (e) => {
      e.exports = {
        'trading-panel-content': 'trading-panel-content-LlInYWMC',
        'trading-panel-spinner': 'trading-panel-spinner-LlInYWMC',
        'trading-panel-header': 'trading-panel-header-LlInYWMC',
        'trading-panel-tabs': 'trading-panel-tabs-LlInYWMC',
        'trading-panel-handle': 'trading-panel-handle-LlInYWMC',
      }
    },
    488803: (e) => {
      e.exports = {
        'tablet-normal-breakpoint': 'screen and (max-width: 768px)',
        'small-height-breakpoint': 'screen and (max-height: 360px)',
        'tablet-small-breakpoint': 'screen and (max-width: 430px)',
      }
    },
    755596: (e) => {
      e.exports = {
        dialog: 'dialog-b8SxMnzX',
        wrapper: 'wrapper-b8SxMnzX',
        separator: 'separator-b8SxMnzX',
        bounded: 'bounded-b8SxMnzX',
      }
    },
    869827: (e) => {
      e.exports = {
        'small-height-breakpoint': 'screen and (max-height: 360px)',
        container: 'container-BZKENkhT',
        unsetAlign: 'unsetAlign-BZKENkhT',
        title: 'title-BZKENkhT',
        subtitle: 'subtitle-BZKENkhT',
        textWrap: 'textWrap-BZKENkhT',
        ellipsis: 'ellipsis-BZKENkhT',
        close: 'close-BZKENkhT',
        icon: 'icon-BZKENkhT',
      }
    },
    308326: (e) => {
      e.exports = {
        'tablet-normal-breakpoint': 'screen and (max-width: 768px)',
        'tooltip-offset': '20px',
        dialog: 'dialog-qyCw0PaN',
        dragging: 'dragging-qyCw0PaN',
        dialogAnimatedAppearance: 'dialogAnimatedAppearance-qyCw0PaN',
        dialogAnimation: 'dialogAnimation-qyCw0PaN',
        dialogTooltip: 'dialogTooltip-qyCw0PaN',
      }
    },
    345719: (e) => {
      e.exports = { separator: 'separator-Pf4rIzEt' }
    },
    354583: (e) => {
      e.exports = { checkbox: 'checkbox-aOSYFxuH' }
    },
    309210: (e) => {
      e.exports = {
        icon: 'icon-vDz9Zwc6',
        toolboxLabel: 'toolboxLabel-vDz9Zwc6',
      }
    },
    389986: (e, t, i) => {
      i.d(t, { CloseButton: () => u })
      var r = i(50959),
        s = i(270762),
        o = i(117105),
        n = i(315130),
        a = i(238822),
        l = i(663346),
        c = i(534983)
      function d(e = 'large') {
        switch (e) {
          case 'large':
            return o
          case 'medium':
          default:
            return n
          case 'small':
            return a
          case 'xsmall':
            return l
          case 'xxsmall':
            return c
        }
      }
      const u = r.forwardRef((e, t) =>
        r.createElement(s.NavButton, { ...e, ref: t, icon: d(e.size) }),
      )
    },
    270762: (e, t, i) => {
      i.d(t, { NavButton: () => c })
      var r = i(50959),
        s = i(497754),
        o = i(72571),
        n = i(345350)
      function a(e) {
        const {
          size: t = 'large',
          preservePaddings: i,
          isLink: r,
          flipIconOnRtl: o,
          className: a,
        } = e
        return s(
          n['nav-button'],
          n[`size-${t}`],
          i && n['preserve-paddings'],
          o && n['flip-icon'],
          r && n.link,
          a,
        )
      }
      function l(e) {
        const { children: t, icon: i } = e
        return r.createElement(
          r.Fragment,
          null,
          r.createElement('span', { className: n.background }),
          r.createElement(o.Icon, {
            icon: i,
            className: n.icon,
            'aria-hidden': !0,
          }),
          t && r.createElement('span', { className: n['visually-hidden'] }, t),
        )
      }
      const c = (0, r.forwardRef)((e, t) => {
        const {
          icon: i,
          type: s = 'button',
          preservePaddings: o,
          flipIconOnRtl: n,
          size: c,
          'aria-label': d,
          ...u
        } = e
        return r.createElement(
          'button',
          { ...u, className: a({ ...e, children: d }), ref: t, type: s },
          r.createElement(l, { icon: i }, d),
        )
      })
      c.displayName = 'NavButton'
      var d = i(591365),
        u = i(273388)
      ;(0, r.forwardRef)((e, t) => {
        const { icon: i, renderComponent: s, 'aria-label': o, ...n } = e,
          c = null != s ? s : d.CustomComponentDefaultLink
        return r.createElement(
          c,
          {
            ...n,
            className: a({ ...e, children: o, isLink: !0 }),
            reference: (0, u.isomorphicRef)(t),
          },
          r.createElement(l, { icon: i }, o),
        )
      }).displayName = 'NavAnchorButton'
    },
    171529: (e, t, i) => {
      i.d(t, { SquareButton: () => _ })
      var r = i(50959),
        s = i(497754),
        o = i(331774),
        n = i(72571),
        a = i(101414),
        l = i.n(a)
      const c =
        'apply-overflow-tooltip apply-overflow-tooltip--check-children-recursively apply-overflow-tooltip--allow-text'
      function d(e) {
        const {
            color: t = 'brand',
            size: i = 'medium',
            variant: r = 'primary',
            stretch: n = !1,
            icon: a,
            startIcon: d,
            endIcon: u,
            iconOnly: h = !1,
            className: p,
            isGrouped: g,
            cellState: m,
            disablePositionAdjustment: _ = !1,
            primaryText: b,
            secondaryText: v,
            isAnchor: y = !1,
          } = e,
          f = ((e) => {
            let t = ''
            return (
              0 !== e &&
                (1 & e && (t = s(t, l()['no-corner-top-left'])),
                2 & e && (t = s(t, l()['no-corner-top-right'])),
                4 & e && (t = s(t, l()['no-corner-bottom-right'])),
                8 & e && (t = s(t, l()['no-corner-bottom-left']))),
              t
            )
          })((0, o.getGroupCellRemoveRoundBorders)(m))
        return s(
          p,
          l().button,
          l()[`size-${i}`],
          l()[`color-${t}`],
          l()[`variant-${r}`],
          n && l().stretch,
          (a || d) && l()['with-start-icon'],
          u && l()['with-end-icon'],
          h && l()['icon-only'],
          f,
          g && l().grouped,
          g && !_ && l()['adjust-position'],
          g && m.isTop && l()['first-row'],
          g && m.isLeft && l()['first-col'],
          b && v && l()['multiline-content'],
          y && l().link,
          c,
        )
      }
      function u(e) {
        const {
            startIcon: t,
            icon: i,
            iconOnly: o,
            children: a,
            endIcon: d,
            primaryText: u,
            secondaryText: h,
          } = e,
          p = null != t ? t : i,
          g = !(t || i || d || o) && !a && u && h
        return r.createElement(
          r.Fragment,
          null,
          p &&
            r.createElement(n.Icon, {
              icon: p,
              className: l()['start-icon-wrap'],
            }),
          a && r.createElement('span', { className: l().content }, a),
          d &&
            !o &&
            r.createElement(n.Icon, {
              icon: d,
              className: l()['end-icon-wrap'],
            }),
          g &&
            ((e) =>
              e.primaryText &&
              e.secondaryText &&
              r.createElement(
                'div',
                { className: s(l()['text-wrap'], c) },
                r.createElement(
                  'span',
                  { className: l()['primary-text'] },
                  ' ',
                  e.primaryText,
                  ' ',
                ),
                'string' == typeof e.secondaryText
                  ? r.createElement(
                      'span',
                      { className: l()['secondary-text'] },
                      ' ',
                      e.secondaryText,
                      ' ',
                    )
                  : r.createElement(
                      'span',
                      { className: l()['secondary-text'] },
                      r.createElement('span', null, e.secondaryText.firstLine),
                      r.createElement('span', null, e.secondaryText.secondLine),
                    ),
              ))(e),
        )
      }
      var h = i(601198),
        p = i(380327),
        g = i(800417)
      function m(e) {
        const {
          className: t,
          color: i,
          variant: r,
          size: s,
          stretch: o,
          animated: n,
          icon: a,
          iconOnly: l,
          startIcon: c,
          endIcon: d,
          primaryText: u,
          secondaryText: h,
          ...p
        } = e
        return {
          ...p,
          ...(0, g.filterDataProps)(e),
          ...(0, g.filterAriaProps)(e),
        }
      }
      function _(e) {
        const { reference: t, tooltipText: i, ...s } = e,
          {
            isGrouped: o,
            cellState: n,
            disablePositionAdjustment: a,
          } = (0, r.useContext)(p.ControlGroupContext),
          l = d({
            ...s,
            isGrouped: o,
            cellState: n,
            disablePositionAdjustment: a,
          })
        return r.createElement(
          'button',
          {
            ...m(s),
            className: l,
            ref: t,
            'data-overflow-tooltip-text':
              null != i
                ? i
                : e.primaryText
                  ? [e.primaryText, e.secondaryText].join(' ')
                  : (0, h.getTextForTooltip)(e.children),
          },
          r.createElement(u, { ...s }),
        )
      }
    },
    380327: (e, t, i) => {
      i.d(t, { ControlGroupContext: () => r })
      const r = i(50959).createContext({
        isGrouped: !1,
        cellState: { isTop: !0, isRight: !0, isBottom: !0, isLeft: !0 },
      })
    },
    331774: (e, t, i) => {
      function r(e) {
        let t = 0
        return (
          (e.isTop && e.isLeft) || (t += 1),
          (e.isTop && e.isRight) || (t += 2),
          (e.isBottom && e.isLeft) || (t += 8),
          (e.isBottom && e.isRight) || (t += 4),
          t
        )
      }
      i.d(t, { getGroupCellRemoveRoundBorders: () => r })
    },
    409245: (e, t, i) => {
      function r(e) {
        const { reference: t, ...i } = e
        return { ...i, ref: t }
      }
      i.d(t, { renameRef: () => r })
    },
    591365: (e, t, i) => {
      i.d(t, { CustomComponentDefaultLink: () => o })
      var r = i(50959),
        s = i(409245)
      function o(e) {
        return r.createElement('a', { ...(0, s.renameRef)(e) })
      }
      r.PureComponent
    },
    80137: (e, t, i) => {
      i.d(t, { Dialog: () => c })
      var r = i(50959),
        s = i(497754),
        o = i(682925),
        n = i(801808),
        a = i(800417),
        l = i(705734)
      class c extends r.PureComponent {
        constructor() {
          super(...arguments),
            (this._manager = new n.OverlapManager()),
            (this._handleSlot = (e) => {
              this._manager.setContainer(e)
            })
        }
        render() {
          const {
              rounded: e = !0,
              shadowed: t = !0,
              fullscreen: i = !1,
              darker: n = !1,
              className: c,
              backdrop: d,
              containerTabIndex: u = -1,
            } = this.props,
            h = s(
              c,
              l.dialog,
              e && l.rounded,
              t && l.shadowed,
              i && l.fullscreen,
              n && l.darker,
            ),
            p = (0, a.filterDataProps)(this.props),
            g = this.props.style
              ? { ...this._createStyles(), ...this.props.style }
              : this._createStyles()
          return r.createElement(
            r.Fragment,
            null,
            r.createElement(
              o.SlotContext.Provider,
              { value: this._manager },
              d &&
                r.createElement('div', {
                  onClick: this.props.onClickBackdrop,
                  className: l.backdrop,
                }),
              r.createElement(
                'div',
                {
                  ...p,
                  className: h,
                  style: g,
                  ref: this.props.reference,
                  onFocus: this.props.onFocus,
                  onMouseDown: this.props.onMouseDown,
                  onMouseUp: this.props.onMouseUp,
                  onClick: this.props.onClick,
                  onKeyDown: this.props.onKeyDown,
                  tabIndex: u,
                  'aria-label': this.props.containerAriaLabel,
                },
                this.props.children,
              ),
            ),
            r.createElement(o.Slot, { reference: this._handleSlot }),
          )
        }
        _createStyles() {
          const {
            bottom: e,
            left: t,
            width: i,
            right: r,
            top: s,
            zIndex: o,
            height: n,
          } = this.props
          return {
            bottom: e,
            left: t,
            right: r,
            top: s,
            zIndex: o,
            maxWidth: i,
            height: n,
          }
        }
      }
    },
    429510: (e, t, i) => {
      var r
      i.d(t, { useCollapsible: () => n }),
        ((e) => {
          ;(e.StartFirst = 'start-first'), (e.EndFirst = 'end-first')
        })(r || (r = {}))
      var s = i(50959),
        o = i(708886)
      function n(e, t, i, n = r.EndFirst) {
        const a = (0, s.useCallback)(
          (i, s) => {
            const o = e.map((e) => {
              var r
              return null !== (r = i.widthsMap.get(t(e))) && void 0 !== r
                ? r
                : 0
            })
            return (({
              items: e,
              containerWidth: t,
              elementsWidths: i,
              menuItemWidth: s,
              keepVisible: o,
              direction: n,
            }) => {
              const a = [...e],
                l = [],
                c = []
              let d = 0
              for (const e of i) d += e
              if (d <= t) return { visible: a, hidden: c }
              const u = [...i]
              if (
                ((d = o.map((e) => u[e]).reduce((e, t) => e + t, 0) + s),
                n === r.EndFirst)
              )
                for (let e = 0; e < a.length; e++)
                  o.includes(e)
                    ? l.push(a[e])
                    : ((d += u[e]), d <= t ? l.push(a[e]) : c.push(a[e]))
              else
                for (let e = a.length - 1; e >= 0; e--)
                  o.includes(e)
                    ? l.unshift(a[e])
                    : ((d += u[e]), d <= t ? l.unshift(a[e]) : c.unshift(a[e]))
              return { visible: l, hidden: c }
            })({
              items: e,
              containerWidth: i.containerWidth,
              elementsWidths: o,
              menuItemWidth: i.moreButtonWidth,
              keepVisible: s,
              direction: n,
            })
          },
          [e],
        )
        return (0, o.useCollapsibleCommon)({
          itemsList: e,
          getItemId: t,
          calcVisibleAndHiddenItems: a,
          shouldKeepItemVisible: i,
        })
      }
    },
    708886: (e, t, i) => {
      i.d(t, { useCollapsibleCommon: () => c })
      var r = i(50959),
        s = i(664332),
        o = i(65160),
        n = i(457927),
        a = i(855393),
        l = i(273388)
      function c(e) {
        const {
            itemsList: t,
            getItemId: i,
            calcVisibleAndHiddenItems: c,
            shouldKeepItemVisible: u,
            onMeasureCallback: h,
            forceUpdate: p = !1,
          } = e,
          [g, m] = (0, n.useRefsMap)(),
          _ = (0, r.useRef)(null),
          b = (0, r.useRef)({
            widthsMap: new Map(),
            containerWidth: 0,
            moreButtonWidth: 0,
          }),
          [v, y] = (0, r.useState)({ visible: t, hidden: [] }),
          f = (0, r.useMemo)(
            () => t.reduce((e, t, i) => (u(t) && e.push(i), e), []),
            [t, u],
          ),
          k = (0, r.useCallback)(() => {
            if (b.current.containerWidth) {
              const e = c(b.current, f)
              ;((e, t) => !d(e.visible, t.visible) || !d(e.hidden, t.hidden))(
                v,
                e,
              ) && y(e)
            }
          }, [b, y, v, f, c]),
          S = (0, r.useCallback)(() => {
            b.current.moreButtonWidth = _.current
              ? (0, o.outerWidth)(_.current, !0)
              : 0
            const e = new Map(b.current.widthsMap)
            for (const r of t) {
              const t = i(r),
                s = g.current.get(t)
              if (s) {
                const i = (0, o.outerWidth)(s, !0)
                e.set(t, i)
              }
            }
            ;(b.current.widthsMap = e), h && h()
          }, [b, t, i, g, h]),
          P = (0, r.useRef)(null),
          C = (0, r.useCallback)(
            ([e]) => {
              e.contentRect.width !== b.current.containerWidth &&
                (P.current && cancelAnimationFrame(P.current),
                (b.current.containerWidth = e.contentRect.width),
                (P.current = requestAnimationFrame(() => {
                  k()
                })))
            },
            [b, k],
          ),
          w = (0, r.useRef)(null),
          B = (0, r.useCallback)(
            ([e]) => {
              w.current && cancelAnimationFrame(w.current),
                S(),
                (w.current = requestAnimationFrame(() => {
                  k()
                }))
            },
            [S, k],
          ),
          T = (0, s.useResizeObserver)(B),
          E = (0, s.useResizeObserver)(C),
          O = (0, r.useRef)(null),
          D = (0, l.mergeRefs)([E, O]),
          I = (0, r.useRef)(t),
          x = (0, r.useRef)(!0),
          M = (0, r.useRef)([])
        return (
          (0, a.useIsomorphicLayoutEffect)(() => {
            ;(!p && !x.current && d(I.current, t) && d(f, M.current)) ||
              (k(), (x.current = !1), (I.current = t), (M.current = f))
          }, [t, k, f, p]),
          {
            containerRefCallback: D,
            moreButtonRef: _,
            innerContainerRefCallback: T,
            itemsRefs: g,
            setItemRef: m,
            hiddenItems: v.hidden,
            visibleItems: v.visible,
            itemsMeasurements: b,
          }
        )
      }
      function d(e, t) {
        return (
          e.length === t.length && e.reduce((e, i, r) => e && i === t[r], !0)
        )
      }
    },
    865968: (e, t, i) => {
      i.d(t, {
        useComposedKeyboardActionHandlers: () => a,
        useKeyboardActionHandler: () => n,
        useKeyboardClose: () => d,
        useKeyboardEventHandler: () => l,
        useKeyboardOpen: () => u,
        useKeyboardToggle: () => c,
      })
      var r = i(50959),
        s = i(930202)
      const o = () => !0
      function n(e, t, i = o, s) {
        return (0, r.useCallback)(
          (r) => {
            if (s) {
              if ('horizontal' === s && (40 === r || 38 === r)) return
              if ('vertical' === s && (37 === r || 39 === r)) return
            }
            const o = e.map((e) => ('function' == typeof e ? e() : e))
            return !(!i(r) || !o.includes(r)) && (t(r), !0)
          },
          [...e, t, i],
        )
      }
      function a(...e) {
        return (0, r.useCallback)(
          (t) => {
            for (const i of e) if (i(t)) return !0
            return !1
          },
          [...e],
        )
      }
      function l(e, t = !0) {
        const i = a(...e)
        return (0, r.useCallback)(
          (e) => {
            i((0, s.hashFromEvent)(e)) && t && e.preventDefault()
          },
          [i],
        )
      }
      function c(e, t = !0) {
        return n([13, 32], e, (e) => {
          if (13 === e) return t
          return !0
        })
      }
      function d(e, t) {
        return n(
          [9, (0, r.useCallback)(() => s.Modifiers.Shift + 9, []), 27],
          t,
          (0, r.useCallback)(() => e, [e]),
        )
      }
      function u(e, t) {
        return n(
          [40, 38],
          t,
          (0, r.useCallback)(() => !e, [e]),
        )
      }
    },
    772069: (e, t, i) => {
      i.d(t, { useDisclosure: () => c })
      var r = i(50959),
        s = i(650151),
        o = i(954343),
        n = i(383836),
        a = i(269842),
        l = i(414823)
      function c(e) {
        const {
            id: t,
            listboxId: i,
            disabled: c,
            buttonTabIndex: d = 0,
            onFocus: u,
            onBlur: h,
            onClick: p,
          } = e,
          [g, m] = (0, r.useState)(!1),
          [_, b] = (0, n.useFocus)(),
          v = _ || g,
          y = (null != i ? i : void 0 !== t)
            ? (0, l.createDomId)(t, 'listbox')
            : void 0,
          f = (0, r.useRef)(null),
          k = (0, r.useCallback)(
            (e) => {
              var t
              return null === (t = f.current) || void 0 === t
                ? void 0
                : t.focus(e)
            },
            [f],
          ),
          S = (0, r.useRef)(null),
          P = (0, r.useCallback)(
            () => (0, s.ensureNotNull)(S.current).focus(),
            [S],
          ),
          C = (0, r.useCallback)(() => m(!0), [m]),
          w = (0, r.useCallback)(
            (e = !1, t = !1) => {
              m(!1)
              const { activeElement: i } = document
              ;(i && (0, o.isTextEditingField)(i)) ||
                t ||
                k({ preventScroll: e })
            },
            [m, k],
          ),
          B = (0, r.useCallback)(() => {
            g ? w() : C()
          }, [g, w, C]),
          T = c ? [] : [u, b.onFocus],
          E = c ? [] : [h, b.onBlur],
          O = c ? [] : [p, B],
          D = (0, a.createSafeMulticastEventHandler)(...T),
          I = (0, a.createSafeMulticastEventHandler)(...E),
          x = (0, a.createSafeMulticastEventHandler)(...O)
        return {
          listboxId: y,
          isOpened: g,
          isFocused: v,
          buttonTabIndex: c ? -1 : d,
          listboxTabIndex: -1,
          open: C,
          close: w,
          toggle: B,
          onOpen: P,
          buttonFocusBindings: { onFocus: D, onBlur: I },
          onButtonClick: x,
          buttonRef: f,
          listboxRef: S,
          buttonAria: {
            'aria-controls': g ? y : void 0,
            'aria-expanded': g,
            'aria-disabled': c,
          },
        }
      }
    },
    383836: (e, t, i) => {
      i.d(t, { useFocus: () => s })
      var r = i(50959)
      function s(e, t) {
        const [i, s] = (0, r.useState)(!1)
        ;(0, r.useEffect)(() => {
          t && i && s(!1)
        }, [t, i])
        const o = {
          onFocus: (0, r.useCallback)(
            (t) => {
              ;(void 0 !== e && e.current !== t.target) || s(!0)
            },
            [e],
          ),
          onBlur: (0, r.useCallback)(
            (t) => {
              ;(void 0 !== e && e.current !== t.target) || s(!1)
            },
            [e],
          ),
        }
        return [i, o]
      }
    },
    648621: (e, t, i) => {
      i.d(t, { useItemsKeyboardNavigation: () => n })
      var r = i(50959),
        s = i(865968)
      function o(e, t) {
        return e >= 0 ? e % t : (t - (Math.abs(e) % t)) % t
      }
      function n(e, t, i, n, a, l, c = {}, d) {
        const u = (0, r.useCallback)(
            (e) => {
              const t = i.findIndex(n)
              if (t === i.length - 1 && !l)
                return void (
                  (null == d ? void 0 : d.onFailNext) && d.onFailNext(e)
                )
              const r = o(t + 1, i.length)
              a && a(i[r], 'next')
            },
            [i, n, a, l],
          ),
          h = (0, r.useCallback)(
            (e) => {
              const t = i.findIndex(n)
              if (0 === t && !l)
                return void (
                  (null == d ? void 0 : d.onFailPrev) && d.onFailPrev(e)
                )
              const r = o(t - 1, i.length)
              a && a(i[r], 'previous')
            },
            [i, n, a, l],
          ),
          p = (0, r.useCallback)(() => {
            a && a(i[0], 'first')
          }, [a, i]),
          g = (0, r.useCallback)(() => {
            a && a(i[i.length - 1], 'last')
          }, [a, i]),
          m = (0, r.useMemo)(
            () =>
              ((e) => ({
                next: [40, () => (e() ? 37 : 39)],
                previous: [38, () => (e() ? 39 : 37)],
                first: [33, () => (e() ? 35 : 36)],
                last: [34, () => (e() ? 36 : 35)],
              }))(t),
            [t],
          ),
          {
            next: _ = m.next,
            previous: b = m.previous,
            first: v = m.first,
            last: y = m.last,
          } = c
        return (0, s.useComposedKeyboardActionHandlers)(
          (0, s.useKeyboardActionHandler)(_, u, () => !0, e),
          (0, s.useKeyboardActionHandler)(b, h, () => !0, e),
          (0, s.useKeyboardActionHandler)(v, p, () => !0, e),
          (0, s.useKeyboardActionHandler)(y, g, () => !0, e),
        )
      }
    },
    930617: (e, t, i) => {
      i.d(t, { useKeepActiveItemIntoView: () => u })
      var r = i(50959),
        s = i(650151),
        o = i(549423)
      const n = { duration: 200, additionalScroll: 0 },
        a = {
          vertical: {
            scrollSize: 'scrollHeight',
            clientSize: 'clientHeight',
            start: 'top',
            end: 'bottom',
            size: 'height',
          },
          horizontal: {
            scrollSize: 'scrollWidth',
            clientSize: 'clientWidth',
            start: 'left',
            end: 'right',
            size: 'width',
          },
        }
      function l(e, t) {
        const i = a[e]
        return t[i.scrollSize] > t[i.clientSize]
      }
      function c(e, t, i, r, s, n) {
        const l = ((e, t, i, r = 0) => {
          const s = a[e]
          return {
            start: -1 * r,
            middle:
              -1 * (Math.floor(i[s.size] / 2) - Math.floor(t[s.size] / 2)),
            end: -1 * (i[s.size] - t[s.size]) + r,
          }
        })(e, r, s, n.additionalScroll)
        let c = 0
        if (
          ((e, t, i) => {
            const r = a[e]
            return (
              t[r.start] < i[r.start] - i[r.size] / 2 ||
              t[r.end] > i[r.end] + i[r.size] / 2
            )
          })(e, r, s)
        )
          c = l.middle
        else {
          const t = ((e, t, i, r = 0) => {
              const s = a[e],
                o = t[s.start] + Math.floor(t[s.size] / 2),
                n = i[s.start] + Math.floor(i[s.size] / 2)
              return {
                start: t[s.start] - i[s.start] - r,
                middle: o - n,
                end: t[s.end] - i[s.end] + r,
              }
            })(e, r, s, n.additionalScroll),
            i = ((e) => {
              const { start: t, middle: i, end: r } = e,
                s = new Map([
                  [Math.abs(t), { key: 'start', value: Math.sign(t) }],
                  [Math.abs(i), { key: 'middle', value: Math.sign(i) }],
                  [Math.abs(r), { key: 'end', value: Math.sign(r) }],
                ]),
                o = Math.min(...s.keys())
              return s.get(o)
            })(t)
          c = void 0 !== i ? l[i.key] : 0
        }
        return ((e) => {
          const {
            additionalScroll: t = 0,
            duration: i = o.dur,
            func: r = o.easingFunc.easeInOutCubic,
            onScrollEnd: s,
            target: n,
            wrap: a,
            direction: l = 'vertical',
          } = e
          let { targetRect: c, wrapRect: d } = e
          ;(c = null != c ? c : n.getBoundingClientRect()),
            (d = null != d ? d : a.getBoundingClientRect())
          const u = ('vertical' === l ? c.top - d.top : c.left - d.left) + t,
            h = 'vertical' === l ? 'scrollTop' : 'scrollLeft',
            p = a ? a[h] : 0
          let g,
            m = 0
          return (
            (m = window.requestAnimationFrame(function e(t) {
              let o
              if ((g ? (o = t - g) : ((o = 0), (g = t)), o >= i))
                return (a[h] = p + u), void (s && s())
              const n = p + u * r(o / i)
              ;(a[h] = Math.floor(n)), (m = window.requestAnimationFrame(e))
            })),
            () => {
              window.cancelAnimationFrame(m), s && s()
            }
          )
        })({
          ...n,
          target: t,
          targetRect: r,
          wrap: i,
          wrapRect: s,
          additionalScroll: c,
          direction: e,
        })
      }
      class d {
        constructor(e = null) {
          ;(this._container = null),
            (this._lastScrolledElement = null),
            (this._stopVerticalScroll = null),
            (this._stopHorizontalScroll = null),
            (this._container = e)
        }
        scrollTo(e, t = n) {
          if (
            null !== this._container &&
            null !== e &&
            !((e, t) => {
              const i = e.getBoundingClientRect(),
                r = t.getBoundingClientRect()
              return (
                i.top >= r.top &&
                i.bottom <= r.bottom &&
                i.left >= r.left &&
                i.right <= r.right
              )
            })(e, this._container)
          ) {
            const i = e.getBoundingClientRect(),
              r = this._container.getBoundingClientRect()
            this.stopScroll(),
              l('vertical', this._container) &&
                (this._stopVerticalScroll = c(
                  'vertical',
                  e,
                  this._container,
                  i,
                  r,
                  this._modifyOptions('vertical', t),
                )),
              l('horizontal', this._container) &&
                (this._stopHorizontalScroll = c(
                  'horizontal',
                  e,
                  this._container,
                  i,
                  r,
                  this._modifyOptions('horizontal', t),
                ))
          }
          this._lastScrolledElement = e
        }
        scrollToLastElement(e) {
          this.scrollTo(this._lastScrolledElement, e)
        }
        stopScroll() {
          null !== this._stopVerticalScroll && this._stopVerticalScroll(),
            null !== this._stopHorizontalScroll && this._stopHorizontalScroll()
        }
        getContainer() {
          return this._container
        }
        setContainer(e) {
          var t
          ;(this._container = e),
            (null === (t = this._container) || void 0 === t
              ? void 0
              : t.contains(this._lastScrolledElement)) ||
              (this._lastScrolledElement = null)
        }
        destroy() {
          this.stopScroll(),
            (this._container = null),
            (this._lastScrolledElement = null)
        }
        _handleScrollEnd(e) {
          'vertical' === e
            ? (this._stopVerticalScroll = null)
            : (this._stopHorizontalScroll = null)
        }
        _modifyOptions(e, t) {
          return Object.assign({}, t, {
            onScrollEnd: () => {
              this._handleScrollEnd(e),
                void 0 !== t.onScrollEnd && t.onScrollEnd()
            },
          })
        }
      }
      function u(e = {}) {
        const { activeItem: t, getKey: i, ...o } = e,
          n = (0, r.useRef)(null),
          a = (0, r.useRef)(new Map()),
          l = ((e) => {
            const t = (0, r.useRef)(null)
            return (
              (0, r.useEffect)(
                () => (
                  (t.current = new d(e)),
                  () => (0, s.ensureNotNull)(t.current).destroy()
                ),
                [],
              ),
              t
            )
          })(n.current),
          c = (0, r.useCallback)(() => {
            null !== l.current &&
              null !== n.current &&
              l.current.getContainer() !== n.current &&
              l.current.setContainer(n.current)
          }, [l, n]),
          u = (0, r.useCallback)(
            (e) => {
              n.current = e
            },
            [n],
          ),
          h = (0, r.useCallback)(
            (e, t) => {
              const r = i ? i(e) : e
              t ? a.current.set(r, t) : a.current.delete(r)
            },
            [a, i],
          ),
          p = (0, r.useCallback)(
            (e, t) => {
              if (!e) return
              const r = i ? i(e) : e,
                o = a.current.get(r)
              o && (c(), (0, s.ensureNotNull)(l.current).scrollTo(o, t))
            },
            [a, l, i],
          )
        return (0, r.useEffect)(() => p(t, o), [p, t]), [u, h, p]
      }
    },
    671129: (e, t, i) => {
      i.d(t, { useMatchMedia: () => o, useSafeMatchMedia: () => s })
      var r = i(50959)
      function s(e, t = !1) {
        const [i, s] = (0, r.useState)(t)
        return (
          (0, r.useEffect)(() => {
            const t = window.matchMedia(e)
            function i() {
              s(t.matches)
            }
            return (
              i(),
              t.addListener(i),
              () => {
                t.removeListener(i)
              }
            )
          }, [e]),
          i
        )
      }
      function o(e) {
        const t = (0, r.useMemo)(() => window.matchMedia(e).matches, [])
        return s(e, t)
      }
    },
    525388: (e, t, i) => {
      i.d(t, { useMergedRefs: () => o })
      var r = i(50959),
        s = i(273388)
      function o(e) {
        return (0, r.useCallback)((0, s.mergeRefs)(e), e)
      }
    },
    118965: (e, t, i) => {
      i.d(t, { useMobileTouchState: () => o })
      var r = i(50959),
        s = i(804395)
      function o() {
        const [e, t] = (0, r.useState)(!1)
        return (
          (0, r.useEffect)(() => {
            t(s.mobiletouch)
          }, []),
          e
        )
      }
    },
    457927: (e, t, i) => {
      i.d(t, { useRefsMap: () => s })
      var r = i(50959)
      function s() {
        const e = (0, r.useRef)(new Map()),
          t = (0, r.useCallback)(
            (t) => (i) => {
              null !== i ? e.current.set(t, i) : e.current.delete(t)
            },
            [e],
          )
        return [e, t]
      }
    },
    984164: (e, t, i) => {
      i.d(t, { useTabs: () => g })
      var r = i(50959),
        s = i(897107),
        o = i(269842),
        n = i(383836),
        a = i(930617),
        l = i(650151),
        c = i(865968),
        d = i(648621)
      function u() {
        return !1
      }
      function h(e) {
        const { activationType: t = 'manual' } = e,
          i = (0, r.useMemo)(() => t, [])
        return (
          (0, l.assert)(t === i, 'Activation type must be invariant.'),
          'automatic' === t
            ? ((e) => {
                const {
                    isRtl: t,
                    items: i,
                    preventDefaultIfHandled: s = !0,
                    isHighlighted: o,
                    onHighlight: n,
                    onActivate: a,
                    isCollapsed: l = u,
                    orientation: h,
                  } = e,
                  p = (0, r.useCallback)(
                    (e) => {
                      n(e), l(e) || a(e)
                    },
                    [n, a, l],
                  )
                return (0, c.useKeyboardEventHandler)(
                  [(0, d.useItemsKeyboardNavigation)(h, t, i, o, p, !0)],
                  s,
                )
              })(e)
            : ((e) => {
                const {
                    isRtl: t,
                    items: i,
                    preventDefaultIfHandled: s = !0,
                    isHighlighted: o,
                    onHighlight: n,
                    onActivate: a,
                    orientation: l,
                  } = e,
                  u = i.find(o),
                  h = (0, r.useCallback)(() => {
                    void 0 !== u && a(u)
                  }, [u, a]),
                  p = (0, r.useCallback)((e) => n(e), [n]),
                  g = (0, d.useItemsKeyboardNavigation)(l, t, i, o, p, !0),
                  m = (0, c.useKeyboardActionHandler)([13, 32], h)
                return (0, c.useKeyboardEventHandler)([g, m], s)
              })(e)
        )
      }
      var p = i(118965)
      function g(e) {
        var t, i
        const {
            id: l,
            items: c,
            orientation: d,
            activationType: u = 'manual',
            disabled: g,
            tablistLabelId: m,
            tablistLabel: _,
            focusOnHighlight: b = !0,
            preventDefaultIfKeyboardActionHandled: v = !0,
            scrollIntoViewOptions: y,
            isActive: f,
            onActivate: k,
            isCollapsed: S,
            isRtl: P,
            isDisclosureOpened: C,
          } = e,
          w = (0, p.useMobileTouchState)(),
          B = C ? null : d || 'horizontal',
          T = (0, r.useRef)(
            null !==
              (i =
                null === (t = e.itemsRefs) || void 0 === t
                  ? void 0
                  : t.current) && void 0 !== i
              ? i
              : new Map(),
          ),
          [E, O] = (0, r.useState)(),
          [D, I] = (0, n.useFocus)(),
          x = c.find(f),
          M = (0, r.useCallback)((e) => !g && !e.disabled && e === E, [g, E]),
          A = (0, r.useCallback)(
            (e) => {
              const t = T.current.get(e)
              b && void 0 !== t && t !== document.activeElement && t.focus()
            },
            [b],
          ),
          N = (0, r.useRef)(),
          L = (0, r.useCallback)(
            (e, t) => {
              g ||
                e.disabled ||
                (O(e),
                'number' == typeof t
                  ? (clearTimeout(N.current),
                    (N.current = setTimeout(() => A(e), t)))
                  : A(e))
            },
            [g, O, A],
          ),
          V = (0, r.useCallback)(
            (e) => {
              g || e.disabled || (k(e), M(e) || L(e))
            },
            [g, k, M, L],
          ),
          R = h({
            isRtl: P,
            items: (0, r.useMemo)(
              () => c.filter((e) => !g && !e.disabled),
              [c, g],
            ),
            activationType: u,
            preventDefaultIfHandled: v,
            onActivate: V,
            isHighlighted: M,
            onHighlight: L,
            isCollapsed: S,
            orientation: B,
          }),
          F = (0, r.useCallback)(
            (e) => {
              let t = null
              for (const [i, r] of T.current.entries())
                if (e.target === r) {
                  t = i
                  break
                }
              t && !M(t) && ('automatic' === u && S && !S(t) ? V(t) : L(t))
            },
            [u, M, L, V, S],
          )
        ;(0, r.useEffect)(() => {
          w || (void 0 !== x && O(x))
        }, [x, w]),
          (0, r.useEffect)(() => {
            D || O(void 0)
          }, [D]),
          (0, r.useEffect)(() => () => clearTimeout(N.current), [])
        const [W, q] = (0, a.useKeepActiveItemIntoView)({
            ...y,
            activeItem: null != E ? E : x,
            getKey: (0, r.useCallback)((e) => e.id, []),
          }),
          U = (0, r.useCallback)(
            (e, t) => {
              q(e, t), null !== t ? T.current.set(e, t) : T.current.delete(e)
            },
            [q],
          ),
          z = c.map((e) => {
            var t, i
            const r = M(e),
              o = f(e),
              n =
                null !==
                  (i = null !== (t = e.disabled) && void 0 !== t ? t : g) &&
                void 0 !== i &&
                i,
              a = !n && (D ? r : o)
            return {
              ...(0, s.getTabAttributes)(e.id, a, o, e.tabpanelId, n),
              highlighted: r,
              active: o,
              handleItemRef: U,
            }
          })
        return {
          tabsBindings: z,
          tablistBinding: {
            ...(0, s.getTabListAttributes)((0, s.getTablistId)(l), d, g, m, _),
            onBlur: I.onBlur,
            onFocus: (0, o.createSafeMulticastEventHandler)(I.onFocus, F),
            onKeyDown: R,
          },
          scrollWrapBinding: { ref: W },
          onActivate: V,
          onHighlight: L,
          isHighlighted: M,
        }
      }
    },
    298563: (e, t, i) => {
      i.d(t, { useTabsMainHandlers: () => p })
      var r = i(50959),
        s = i(269842),
        o = i(118965),
        n = i(586240),
        a = i(671129)
      var l = i(429510),
        c = i(984164),
        d = i(772069),
        u = i(525388),
        h = i(865968)
      function p(e, t, i) {
        const {
            id: p,
            items: g,
            activationType: m,
            orientation: _,
            disabled: b,
            onActivate: v,
            isActive: y,
            overflowBehaviour: f,
            enableActiveStateStyles: k,
            tablistLabelId: S,
            tablistLabel: P,
          } = t,
          C = (0, o.useMobileTouchState)(),
          w = ((e) => {
            const t = (0, a.useSafeMatchMedia)(
                n['media-mf-phone-landscape'],
                !0,
              ),
              i = (0, o.useMobileTouchState)()
            return null != e ? e : i || !t ? 'scroll' : 'collapse'
          })(f),
          B = (0, r.useRef)(!1),
          T = (0, r.useCallback)((e) => e.id, []),
          E = null != k ? k : !C,
          {
            visibleItems: O,
            hiddenItems: D,
            containerRefCallback: I,
            innerContainerRefCallback: x,
            moreButtonRef: M,
            setItemRef: A,
          } = (0, l.useCollapsible)(g, T, y),
          N = 'collapse' === w ? O : g,
          L = (0, r.useMemo)(() => ('collapse' === w ? D : []), [w, D]),
          V = (0, r.useCallback)((e) => L.includes(e), [L]),
          {
            isOpened: R,
            open: F,
            close: W,
            onButtonClick: q,
          } = (0, d.useDisclosure)({ id: p, disabled: b }),
          {
            tabsBindings: U,
            tablistBinding: z,
            scrollWrapBinding: $,
            onActivate: H,
            onHighlight: Q,
            isHighlighted: j,
          } = (0, c.useTabs)({
            id: p,
            items: [...N, ...L],
            activationType: m,
            orientation: _,
            disabled: b,
            tablistLabelId: S,
            tablistLabel: P,
            scrollIntoViewOptions: i.scrollIntoViewOptions,
            onActivate: v,
            isActive: y,
            isCollapsed: V,
            isRtl: i.isRtl,
            isDisclosureOpened: R,
          }),
          K = L.find(j),
          G = (0, r.useCallback)(() => {
            const e = g.find(y)
            e && Q(e)
          }, [Q, y, g]),
          Z = (0, r.useCallback)((e) => U.find((t) => t.id === e.id), [U]),
          J = (0, r.useCallback)(() => {
            W(), G(), (B.current = !0)
          }, [W, G]),
          X = (0, r.useCallback)(() => {
            K && (H(K), Q(K, 250))
          }, [H, Q, K])
        ;($.ref = (0, u.useMergedRefs)([$.ref, I])),
          (z.ref = (0, u.useMergedRefs)([z.ref, x])),
          (z.onKeyDown = (0, s.createSafeMulticastEventHandler)(
            (0, h.useKeyboardEventHandler)([
              (0, h.useKeyboardClose)(R, J),
              (0, h.useKeyboardActionHandler)(
                [13, 32],
                X,
                (0, r.useCallback)(() => Boolean(K), [K]),
              ),
            ]),
            z.onKeyDown,
          ))
        const Y = (0, r.useCallback)(
            (e) => {
              ;(B.current = !0), q(e)
            },
            [B, q],
          ),
          ee = (0, r.useCallback)(
            (e) => {
              e && H(e)
            },
            [H],
          )
        return (
          (0, r.useEffect)(() => {
            B.current ? (B.current = !1) : (K && !R && F(), !K && R && W())
          }, [K, R, F, W]),
          {
            enableActiveStateStyles: E,
            moreButtonRef: M,
            setItemRef: A,
            getBindings: Z,
            handleMoreButtonClick: Y,
            handleCollapsedItemClick: ee,
            scrollWrapBinding: $,
            overflowBehaviour: w,
            tablistBinding: z,
            visibleTabs: N,
            hiddenTabs: L,
            handleActivate: H,
            isMobileTouch: C,
            getItemId: T,
            isDisclosureOpened: R,
            isHighlighted: j,
            closeDisclosure: W,
          }
        )
      }
    },
    897107: (e, t, i) => {
      i.d(t, {
        TabNames: () => r,
        getTabAttributes: () => a,
        getTabListAttributes: () => n,
        getTablistId: () => o,
      })
      var r,
        s = i(414823)
      function o(e) {
        return (0, s.createDomId)(e, 'tablist')
      }
      function n(e, t = 'horizontal', i, r, s) {
        return {
          id: e,
          role: 'tablist',
          'aria-orientation': t,
          'aria-label': s,
          'aria-labelledby': r,
          'aria-disabled': i,
        }
      }
      function a(e, t, i, r, s) {
        return {
          id: e,
          role: 'tab',
          tabIndex: t ? 0 : -1,
          disabled: s,
          'aria-selected': i,
          'aria-controls': r,
          'aria-disabled': s,
        }
      }
      !((e) => {
        ;(e.SquareButtonTabs = 'square-button-tabs'),
          (e.UnderlineButtonTabs = 'underline-button-tabs'),
          (e.UnderlineAnchorTabs = 'underline-anchor-tabs'),
          (e.RoundAnchorTabs = 'round-anchor-tabs'),
          (e.RoundButtonTabs = 'round-button-tabs'),
          (e.LightButtonTabs = 'light-button-tabs')
      })(r || (r = {}))
    },
    414823: (e, t, i) => {
      i.d(t, { createDomId: () => l, joinDomIds: () => c })
      const r = /\s/g
      function s(e) {
        return 'string' == typeof e
      }
      function o(e) {
        switch (typeof e) {
          case 'string':
            return e
          case 'number':
          case 'bigint':
            return e.toString(10)
          case 'boolean':
          case 'symbol':
            return e.toString()
          default:
            return null
        }
      }
      function n(e) {
        return e.trim().length > 0
      }
      function a(e) {
        return e.replace(r, '-')
      }
      function l(...e) {
        const t = e.map(o).filter(s).filter(n).map(a)
        return (t.length > 0 && t[0].startsWith('id_') ? t : ['id', ...t]).join(
          '_',
        )
      }
      function c(...e) {
        return e.map(o).filter(s).filter(n).join(' ')
      }
    },
    601198: (e, t, i) => {
      i.d(t, { getTextForTooltip: () => n })
      var r = i(50959)
      const s = (e) => (0, r.isValidElement)(e) && Boolean(e.props.children),
        o = (e) =>
          null == e || 'boolean' == typeof e || '{}' === JSON.stringify(e)
            ? ''
            : e.toString() + ' ',
        n = (e) =>
          Array.isArray(e) || (0, r.isValidElement)(e)
            ? r.Children.toArray(e)
                .reduce((e, t) => {
                  let i = ''
                  return (
                    (i =
                      (0, r.isValidElement)(t) && s(t)
                        ? n(t.props.children)
                        : (0, r.isValidElement)(t) && !s(t)
                          ? ''
                          : o(t)),
                    e.concat(i)
                  )
                }, '')
                .trim()
            : o(e)
    },
    738036: (e, t, i) => {
      i.d(t, { OutsideEvent: () => s })
      var r = i(908783)
      function s(e) {
        const { children: t, ...i } = e
        return t((0, r.useOutsideEvent)(i))
      }
    },
    363111: (e, t, i) => {
      i.d(t, {
        BracketDefaultPips: () => n,
        BracketSubControlType: () => a,
        CalculatorDecKeyCodes: () => d,
        CalculatorIncKeyCodes: () => u,
        Context: () => g,
        OrderEditorDisplayMode: () => o,
        OrderPanelStatus: () => r,
        OrderPlacingStatus: () => s,
        PriceSubControlType: () => c,
        QuantitySubControlType: () => l,
        orderTypes: () => m,
      })
      var r,
        s,
        o,
        n,
        a,
        l,
        c,
        d,
        u,
        h = i(50959),
        p = i(609838)
      !((e) => {
        ;(e[(e.Wait = 0)] = 'Wait'),
          (e[(e.Active = 1)] = 'Active'),
          (e[(e.Editing = 2)] = 'Editing'),
          (e[(e.Preview = 3)] = 'Preview')
      })(r || (r = {})),
        ((e) => {
          ;(e[(e.Creating = 0)] = 'Creating'), (e[(e.Placed = 1)] = 'Placed')
        })(s || (s = {})),
        ((e) => {
          ;(e.Popup = 'popup'), (e.Panel = 'panel')
        })(o || (o = {})),
        ((e) => {
          ;(e[(e.TakeProfit = 75)] = 'TakeProfit'),
            (e[(e.StopLoss = 25)] = 'StopLoss')
        })(n || (n = {})),
        ((e) => {
          ;(e.Price = 'Price'),
            (e.Pips = 'Pips'),
            (e.Money = 'Money'),
            (e.Percent = 'Percent')
        })(a || (a = {})),
        ((e) => {
          ;(e.Units = 'Units'),
            (e.RiskInCurrency = 'RiskInCurrency'),
            (e.RiskInPercent = 'RiskInPercent'),
            (e.BaseCurrency = 'BaseCurrency'),
            (e.QuoteCurrency = 'QuoteCurrency')
        })(l || (l = {})),
        ((e) => {
          ;(e.Absolute = 'Absolute'), (e.Relative = 'Relative')
        })(c || (c = {})),
        ((e) => {
          ;(e[(e.Minus = 189)] = 'Minus'),
            (e[(e.NumMinus = 109)] = 'NumMinus'),
            (e[(e.FirefoxMinus = 173)] = 'FirefoxMinus')
        })(d || (d = {})),
        ((e) => {
          ;(e[(e.Plus = 187)] = 'Plus'),
            (e[(e.NumPlus = 107)] = 'NumPlus'),
            (e[(e.FirefoxPlus = 61)] = 'FirefoxPlus')
        })(u || (u = {}))
      const g = h.createContext({
          resizerWidth: null,
          mode: o.Panel,
          supportTrailingStop: !1,
        }),
        m = {
          1: p.t(null, void 0, i(398157)),
          2: p.t(null, void 0, i(359758)),
          3: p.t(null, void 0, i(905023)),
          4: p.t(null, void 0, i(802654)),
        }
    },
    600297: (e, t, i) => {
      i.d(t, { Button: () => n, ButtonType: () => r })
      var r,
        s = i(50959),
        o = i(171529)
      function n(e) {
        const { value: t, buttonType: i, className: n, icon: a, onClick: l } = e
        let c
        switch (i) {
          case r.PlusValue:
          case r.IncDec:
            c = t
            break
          case r.Clear:
            c = 'clear'
            break
          case r.Default:
            c = 'default'
        }
        return s.createElement(
          o.SquareButton,
          {
            className: n,
            'data-value': c,
            'data-name': `qtyButtonCalculator-${c}`,
            onClick: () => {
              l(t, i)
            },
            size: 'xsmall',
            variant: 'secondary',
            color: 'gray',
            onMouseDown: (e) => e.preventDefault(),
          },
          a || t,
        )
      }
      !((e) => {
        ;(e[(e.PlusValue = 0)] = 'PlusValue'),
          (e[(e.IncDec = 1)] = 'IncDec'),
          (e[(e.Clear = 2)] = 'Clear'),
          (e[(e.Default = 3)] = 'Default')
      })(r || (r = {}))
    },
    958057: (e, t, i) => {
      i.d(t, {
        batsToRealtimeCrucialHtml: () => S,
        batsToRealtimeHtml1: () => y,
        batsToRealtimeHtml2WithExchange: () => k,
        batsToRealtimeHtml2WithoutExchange: () => f,
        delayHtml: () => d,
        delayNoRealtimeHtml: () => p,
        delayToRealtimeHtml: () => h,
        delayTooltip: () => o,
        delayWithoutMarketAgreement: () => v,
        eodHtml: () => g,
        eodTooltip: () => n,
        exchangeByOriginalExchangeTooltip: () => c,
        notAccurate1PerSecondTooltip: () => a,
        notAccurateCboeTooltip: () => l,
        tFEXorMOEXorLSEorChixauHtml: () => u,
        tickByTickHtml1: () => _,
        tickByTickHtml1FullInfo: () => m,
        tickByTickHtml2: () => b,
      })
      var r = i(609838),
        s = i(311757)
      const o = r.t(null, void 0, i(257310)),
        n = r.t(null, void 0, i(659315)),
        a = r.t(null, void 0, i(215815)),
        l = r.t(null, void 0, i(345e3)),
        c = r.t(null, void 0, i(107435)),
        d =
          (r.t(null, void 0, i(624680)),
          r.t(null, void 0, i(999214)),
          r.t(null, void 0, i(6044)),
          r.t(null, void 0, i(831461)),
          r.t(null, void 0, i(332960)),
          r.t(null, void 0, i(152449)),
          (0, s.htmlEscape)(r.t(null, void 0, i(538611)))),
        u = (0, s.htmlEscape)(r.t(null, void 0, i(301084))),
        h = (0, s.htmlEscape)(r.t(null, void 0, i(652984))),
        p = (0, s.htmlEscape)(r.t(null, void 0, i(689022))),
        g = (0, s.htmlEscape)(r.t(null, void 0, i(52916))),
        m = (0, s.htmlEscape)(r.t(null, void 0, i(449321))),
        _ = (0, s.htmlEscape)(r.t(null, void 0, i(425978))),
        b = (0, s.htmlEscape)(r.t(null, void 0, i(28412))),
        v = (0, s.htmlEscape)(r.t(null, void 0, i(791459))),
        y = r.t(null, void 0, i(806667)),
        f =
          (r.t(
            null,
            {
              context:
                'Part of: "Real-time data for {symbolName} is provided by {exchange} exchange."',
            },
            i(712978),
          ),
          r.t(
            null,
            {
              context:
                'Part of: "Real-time data for {symbolName} is provided by {exchange} exchange."',
            },
            i(864565),
          ),
          r.t(null, void 0, i(102310))),
        k = r.t(null, void 0, i(729512)),
        S = r.t(null, void 0, i(886753))
      r.t(null, void 0, i(353205)), r.t(null, void 0, i(115993))
    },
    190787: (e, t, i) => {
      function r(e, t) {
        null === e.firstChild
          ? (e.textContent = t)
          : (e.firstChild.nodeValue = t)
      }
      i.d(t, { updateTextNode: () => r })
    },
    996038: (e, t, i) => {
      i.d(t, { DialogBreakpoints: () => s })
      var r = i(488803)
      const s = {
        SmallHeight: r['small-height-breakpoint'],
        TabletSmall: r['tablet-small-breakpoint'],
        TabletNormal: r['tablet-normal-breakpoint'],
      }
    },
    533408: (e, t, i) => {
      i.d(t, { AdaptivePopupDialog: () => E })
      var r = i(50959),
        s = i(650151),
        o = i(660538),
        n = i(497754),
        a = i.n(n),
        l = i(180185),
        c = i(710263),
        d = i(698043),
        u = i(40766),
        h = i(494707),
        p = i(996038),
        g = i(930052),
        m = i(910549)
      var _ = i(206594),
        b = i(559410),
        v = i(609838),
        y = i(389986),
        f = i(190410),
        k = i(869827)
      function S(e) {
        const {
            title: t,
            titleTextWrap: s = !1,
            subtitle: o,
            showCloseIcon: n = !0,
            onClose: l,
            onCloseButtonKeyDown: c,
            renderBefore: d,
            renderAfter: u,
            draggable: h,
            className: p,
            unsetAlign: g,
            closeAriaLabel: m = v.t(null, void 0, i(680395)),
            closeButtonReference: _,
          } = e,
          [b, S] = (0, r.useState)(!1)
        return r.createElement(
          f.DialogHeaderContext.Provider,
          { value: { setHideClose: S } },
          r.createElement(
            'div',
            { className: a()(k.container, p, (o || g) && k.unsetAlign) },
            d,
            r.createElement(
              'div',
              { 'data-dragg-area': h, className: k.title },
              r.createElement(
                'div',
                { className: a()(s ? k.textWrap : k.ellipsis) },
                t,
              ),
              o &&
                r.createElement(
                  'div',
                  { className: a()(k.ellipsis, k.subtitle) },
                  o,
                ),
            ),
            u,
            n &&
              !b &&
              r.createElement(y.CloseButton, {
                className: k.close,
                'data-name': 'close',
                'aria-label': m,
                onClick: l,
                onKeyDown: c,
                ref: _,
                size: 'medium',
                preservePaddings: !0,
              }),
          ),
        )
      }
      var P = i(273388),
        C = i(800417),
        w = i(755596)
      const B = { vertical: 20 },
        T = { vertical: 0 }
      class E extends r.PureComponent {
        constructor() {
          super(...arguments),
            (this._controller = null),
            (this._reference = null),
            (this._orientationMediaQuery = null),
            (this._renderChildren = (e, t) => (
              (this._controller = e),
              this.props.render({
                requestResize: this._requestResize,
                centerAndFit: this._centerAndFit,
                isSmallWidth: t,
              })
            )),
            (this._handleReference = (e) => (this._reference = e)),
            (this._handleCloseBtnClick = () => {
              this.props.onKeyboardClose && this.props.onKeyboardClose(),
                this._handleClose()
            }),
            (this._handleClose = () => {
              this.props.onClose()
            }),
            (this._handleOpen = () => {
              void 0 !== this.props.onOpen &&
                this.props.isOpened &&
                this.props.onOpen(
                  this.props.fullScreen ||
                    window.matchMedia(p.DialogBreakpoints.TabletSmall).matches,
                )
            }),
            (this._handleKeyDown = (e) => {
              if (!e.defaultPrevented) {
                if (
                  (this.props.onKeyDown && this.props.onKeyDown(e),
                  27 === (0, l.hashFromEvent)(e))
                ) {
                  if (e.defaultPrevented) return
                  if (
                    this.props.forceCloseOnEsc &&
                    this.props.forceCloseOnEsc()
                  )
                    return (
                      this.props.onKeyboardClose &&
                        this.props.onKeyboardClose(),
                      void this._handleClose()
                    )
                  const { activeElement: i } = document,
                    r = (0, s.ensureNotNull)(this._reference)
                  if (null !== i) {
                    if (
                      (e.preventDefault(),
                      'true' === (t = i).getAttribute('data-haspopup') &&
                        'true' !== t.getAttribute('data-expanded'))
                    )
                      return void this._handleClose()
                    if ((0, d.isTextEditingField)(i)) return void r.focus()
                    if (r.contains(i))
                      return (
                        this.props.onKeyboardClose &&
                          this.props.onKeyboardClose(),
                        void this._handleClose()
                      )
                  }
                }
                var t, i
                ;((e) => {
                  if ('function' == typeof e) return e()
                  return Boolean(e)
                })(this.props.disableTabNavigationContainment) ||
                  ((i = e),
                  [9, l.Modifiers.Shift + 9].includes(
                    (0, l.hashFromEvent)(i),
                  ) && i.stopPropagation())
              }
            }),
            (this._requestResize = () => {
              null !== this._controller && this._controller.recalculateBounds()
            }),
            (this._centerAndFit = () => {
              null !== this._controller && this._controller.centerAndFit()
            }),
            (this._calculatePositionWithOffsets = (e, t) => {
              const i = (0, s.ensureDefined)(
                this.props.fullScreenViewOffsets,
              ).value()
              return {
                top: i.top,
                left: (0, c.isRtl)() ? -i.right : i.left,
                width: t.clientWidth - i.left - i.right,
                height: t.clientHeight - i.top - i.bottom,
              }
            })
        }
        componentDidMount() {
          this.props.ignoreClosePopupsAndDialog ||
            b.subscribe(
              _.CLOSE_POPUPS_AND_DIALOGS_COMMAND,
              this._handleClose,
              null,
            ),
            this._handleOpen(),
            void 0 !== this.props.onOpen &&
              ((this._orientationMediaQuery = window.matchMedia(
                '(orientation: portrait)',
              )),
              (0, o.mediaQueryAddEventListener)(
                this._orientationMediaQuery,
                this._handleOpen,
              )),
            this.props.fullScreenViewOffsets &&
              this.props.fullScreen &&
              this.props.fullScreenViewOffsets.subscribe(this._requestResize)
        }
        componentWillUnmount() {
          this.props.ignoreClosePopupsAndDialog ||
            b.unsubscribe(
              _.CLOSE_POPUPS_AND_DIALOGS_COMMAND,
              this._handleClose,
              null,
            ),
            null !== this._orientationMediaQuery &&
              (0, o.mediaQueryRemoveEventListener)(
                this._orientationMediaQuery,
                this._handleOpen,
              ),
            this.props.fullScreenViewOffsets &&
              this.props.fullScreen &&
              this.props.fullScreenViewOffsets.unsubscribe(this._requestResize)
        }
        focus() {
          ;(0, s.ensureNotNull)(this._reference).focus()
        }
        getElement() {
          return this._reference
        }
        contains(e) {
          var t, i
          return (
            null !==
              (i =
                null === (t = this._reference) || void 0 === t
                  ? void 0
                  : t.contains(e)) &&
            void 0 !== i &&
            i
          )
        }
        render() {
          const {
              className: e,
              wrapperClassName: t,
              headerClassName: i,
              isOpened: s,
              title: o,
              titleTextWrap: n,
              dataName: l,
              onClickOutside: c,
              additionalElementPos: d,
              additionalHeaderElement: _,
              backdrop: b,
              shouldForceFocus: v = !0,
              shouldReturnFocus: y,
              onForceFocus: f,
              showSeparator: k,
              subtitle: E,
              draggable: O = !0,
              fullScreen: D = !1,
              showCloseIcon: I = !0,
              rounded: x = !0,
              isAnimationEnabled: M,
              growPoint: A,
              dialogTooltip: N,
              unsetHeaderAlign: L,
              onDragStart: V,
              dataDialogName: R,
              closeAriaLabel: F,
              containerAriaLabel: W,
              reference: q,
              containerTabIndex: U,
              closeButtonReference: z,
              onCloseButtonKeyDown: $,
              shadowed: H,
              fullScreenViewOffsets: Q,
              fixedBody: j,
            } = this.props,
            K = 'after' !== d ? _ : void 0,
            G = 'after' === d ? _ : void 0,
            Z = 'string' == typeof o ? o : R || '',
            J = (0, C.filterDataProps)(this.props),
            X = (0, P.mergeRefs)([this._handleReference, q])
          return r.createElement(
            g.MatchMedia,
            { rule: p.DialogBreakpoints.SmallHeight },
            (d) =>
              r.createElement(
                g.MatchMedia,
                { rule: p.DialogBreakpoints.TabletSmall },
                (p) =>
                  r.createElement(
                    u.PopupDialog,
                    {
                      rounded: !(p || D) && x,
                      className: a()(w.dialog, D && Q && w.bounded, e),
                      isOpened: s,
                      reference: X,
                      onKeyDown: this._handleKeyDown,
                      onClickOutside: c,
                      onClickBackdrop: c,
                      fullscreen: p || D,
                      guard: d ? T : B,
                      boundByScreen: p || D,
                      shouldForceFocus: v,
                      onForceFocus: f,
                      shouldReturnFocus: y,
                      backdrop: b,
                      draggable: O,
                      isAnimationEnabled: M,
                      growPoint: A,
                      name: this.props.dataName,
                      dialogTooltip: N,
                      onDragStart: V,
                      containerAriaLabel: W,
                      containerTabIndex: U,
                      calculateDialogPosition:
                        D && Q ? this._calculatePositionWithOffsets : void 0,
                      shadowed: H,
                      fixedBody: j,
                      ...J,
                    },
                    r.createElement(
                      'div',
                      {
                        className: a()(w.wrapper, t),
                        'data-name': l,
                        'data-dialog-name': Z,
                      },
                      void 0 !== o &&
                        r.createElement(S, {
                          draggable: O && !(p || D),
                          onClose: this._handleCloseBtnClick,
                          renderAfter: G,
                          renderBefore: K,
                          subtitle: E,
                          title: o,
                          titleTextWrap: n,
                          showCloseIcon: I,
                          className: i,
                          unsetAlign: L,
                          closeAriaLabel: F,
                          closeButtonReference: z,
                          onCloseButtonKeyDown: $,
                        }),
                      k &&
                        r.createElement(h.Separator, {
                          className: w.separator,
                        }),
                      r.createElement(m.PopupContext.Consumer, null, (e) =>
                        this._renderChildren(e, p || D),
                      ),
                    ),
                  ),
              ),
          )
        }
      }
    },
    910549: (e, t, i) => {
      i.d(t, { PopupContext: () => r })
      const r = i(50959).createContext(null)
    },
    40766: (e, t, i) => {
      i.d(t, { PopupDialog: () => S })
      var r = i(50959),
        s = i(497754),
        o = i(650151),
        n = i(80137),
        a = i(874485),
        l = i(738036),
        c = i(44681)
      function d(e, t, i, r) {
        return e + t > r && (e = r - t), e < i && (e = i), e
      }
      function u(e) {
        return {
          x: (0, c.clamp)(e.x, 20, document.documentElement.clientWidth - 20),
          y: (0, c.clamp)(e.y, 20, window.innerHeight - 20),
        }
      }
      function h(e) {
        return { x: e.clientX, y: e.clientY }
      }
      function p(e) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY }
      }
      class g {
        constructor(e, t, i = { boundByScreen: !0 }) {
          ;(this._drag = null),
            (this._canBeTouchClick = !1),
            (this._frame = null),
            (this._onMouseDragStart = (e) => {
              if (0 !== e.button || this._isTargetNoDraggable(e)) return
              e.preventDefault(),
                document.addEventListener('mousemove', this._onMouseDragMove),
                document.addEventListener('mouseup', this._onMouseDragEnd)
              const t = u(h(e))
              this._dragStart(t)
            }),
            (this._onTouchDragStart = (e) => {
              if (this._isTargetNoDraggable(e)) return
              ;(this._canBeTouchClick = !0),
                e.preventDefault(),
                this._header.addEventListener(
                  'touchmove',
                  this._onTouchDragMove,
                  { passive: !1 },
                )
              const t = u(p(e))
              this._dragStart(t)
            }),
            (this._onMouseDragEnd = (e) => {
              e.target instanceof Node &&
                this._header.contains(e.target) &&
                e.preventDefault(),
                document.removeEventListener(
                  'mousemove',
                  this._onMouseDragMove,
                ),
                document.removeEventListener('mouseup', this._onMouseDragEnd),
                this._onDragStop()
            }),
            (this._onTouchDragEnd = (e) => {
              this._header.removeEventListener(
                'touchmove',
                this._onTouchDragMove,
              ),
                this._onDragStop(),
                this._canBeTouchClick &&
                  ((this._canBeTouchClick = !1),
                  ((e) => {
                    if (e instanceof SVGElement) {
                      const t = document.createEvent('SVGEvents')
                      t.initEvent('click', !0, !0), e.dispatchEvent(t)
                    }
                    e instanceof HTMLElement && e.click()
                  })(e.target))
            }),
            (this._onMouseDragMove = (e) => {
              const t = u(h(e))
              this._dragMove(t)
            }),
            (this._onTouchDragMove = (e) => {
              ;(this._canBeTouchClick = !1), e.preventDefault()
              const t = u(p(e))
              this._dragMove(t)
            }),
            (this._onDragStop = () => {
              ;(this._drag = null),
                this._header.classList.remove('dragging'),
                this._options.onDragEnd && this._options.onDragEnd()
            }),
            (this._dialog = e),
            (this._header = t),
            (this._options = i),
            this._header.addEventListener('mousedown', this._onMouseDragStart),
            this._header.addEventListener('touchstart', this._onTouchDragStart),
            this._header.addEventListener('touchend', this._onTouchDragEnd)
        }
        destroy() {
          null !== this._frame && cancelAnimationFrame(this._frame),
            this._header.removeEventListener(
              'mousedown',
              this._onMouseDragStart,
            ),
            document.removeEventListener('mouseup', this._onMouseDragEnd),
            this._header.removeEventListener(
              'touchstart',
              this._onTouchDragStart,
            ),
            this._header.removeEventListener('touchend', this._onTouchDragEnd),
            document.removeEventListener('mouseleave', this._onMouseDragEnd)
        }
        updateOptions(e) {
          this._options = e
        }
        _dragStart(e) {
          const t = this._dialog.getBoundingClientRect()
          this._drag = {
            startX: e.x,
            startY: e.y,
            finishX: e.x,
            finishY: e.y,
            dialogX: t.left,
            dialogY: t.top,
          }
          const i = Math.round(t.left),
            r = Math.round(t.top)
          ;(this._dialog.style.transform = `translate(${i}px, ${r}px)`),
            this._header.classList.add('dragging'),
            this._options.onDragStart && this._options.onDragStart()
        }
        _dragMove(e) {
          if (this._drag) {
            if (
              ((this._drag.finishX = e.x),
              (this._drag.finishY = e.y),
              null !== this._frame)
            )
              return
            this._frame = requestAnimationFrame(() => {
              if (this._drag) {
                const t = e.x - this._drag.startX,
                  i = e.y - this._drag.startY
                this._moveDialog(this._drag.dialogX + t, this._drag.dialogY + i)
              }
              this._frame = null
            })
          }
        }
        _moveDialog(e, t) {
          const i = this._dialog.getBoundingClientRect(),
            { boundByScreen: r } = this._options,
            s = d(e, i.width, r ? 0 : -1 / 0, r ? window.innerWidth : 1 / 0),
            o = d(t, i.height, r ? 0 : -1 / 0, r ? window.innerHeight : 1 / 0)
          this._dialog.style.transform = `translate(${Math.round(s)}px, ${Math.round(o)}px)`
        }
        _isTargetNoDraggable(e) {
          return (
            e.target instanceof Element &&
            null !== e.target.closest('[data-disable-drag]')
          )
        }
      }
      const m = { vertical: 0 }
      class _ {
        constructor(e, t) {
          ;(this._frame = null),
            (this._isFullscreen = !1),
            (this._handleResize = () => {
              null === this._frame &&
                (this._frame = requestAnimationFrame(() => {
                  this.recalculateBounds(), (this._frame = null)
                }))
            }),
            (this._dialog = e),
            (this._guard = t.guard || m),
            (this._calculateDialogPosition = t.calculateDialogPosition),
            (this._initialHeight = e.style.height),
            window.addEventListener('resize', this._handleResize)
        }
        updateOptions(e) {
          ;(this._guard = e.guard || m),
            (this._calculateDialogPosition = e.calculateDialogPosition)
        }
        setFullscreen(e) {
          this._isFullscreen !== e &&
            ((this._isFullscreen = e), this.recalculateBounds())
        }
        centerAndFit() {
          const { x: e, y: t } = this.getDialogsTopLeftCoordinates(),
            i = this._calcAvailableHeight(),
            r = this._calcDialogHeight()
          if (i === r)
            if (this._calculateDialogPosition) {
              const { left: e, top: t } = this._calculateDialogPosition(
                this._dialog,
                document.documentElement,
                this._guard,
              )
              this._dialog.style.transform = `translate(${Math.round(e)}px, ${Math.round(t)}px)`
            } else this._dialog.style.height = r + 'px'
          ;(this._dialog.style.top = '0px'),
            (this._dialog.style.left = '0px'),
            (this._dialog.style.transform = `translate(${e}px, ${t}px)`)
        }
        getDialogsTopLeftCoordinates() {
          const { clientHeight: e, clientWidth: t } = document.documentElement,
            i = this._calcDialogHeight(),
            r = t / 2 - this._dialog.clientWidth / 2,
            s = e / 2 - i / 2
          return { x: Math.round(r), y: Math.round(s) }
        }
        recalculateBounds() {
          var e
          const { clientHeight: t, clientWidth: i } = document.documentElement,
            { vertical: r } = this._guard,
            s =
              null === (e = this._calculateDialogPosition) || void 0 === e
                ? void 0
                : e.call(
                    this,
                    this._dialog,
                    { clientWidth: i, clientHeight: t },
                    { vertical: r },
                  )
          if (this._isFullscreen) {
            if (
              ((this._dialog.style.top = '0px'),
              (this._dialog.style.left = '0px'),
              (this._dialog.style.width = '100%'),
              (this._dialog.style.height = '100%'),
              (this._dialog.style.transform = 'none'),
              s)
            ) {
              const { left: e, top: t, width: i, height: r } = s
              ;(this._dialog.style.transform = `translate(${Math.round(e)}px, ${Math.round(t)}px)`),
                i &&
                  ((this._dialog.style.width = `${i}px`),
                  (this._dialog.style.minWidth = 'unset')),
                r &&
                  ((this._dialog.style.height = `${r}px`),
                  (this._dialog.style.minHeight = 'unset'))
            }
          } else if (s) {
            const { left: e, top: t } = s
            this._dialog.style.transform = `translate(${Math.round(e)}px, ${Math.round(t)}px)`
          } else {
            ;(this._dialog.style.width = ''), (this._dialog.style.height = '')
            const e = this._dialog.getBoundingClientRect(),
              s = t - 2 * r,
              o = d(e.left, e.width, 0, i),
              n = d(e.top, e.height, r, t)
            ;(this._dialog.style.top = '0px'),
              (this._dialog.style.left = '0px'),
              (this._dialog.style.transform = `translate(${Math.round(o)}px, ${Math.round(n)}px)`),
              (this._dialog.style.height =
                s < e.height ? s + 'px' : this._initialHeight)
          }
        }
        destroy() {
          window.removeEventListener('resize', this._handleResize),
            null !== this._frame &&
              (cancelAnimationFrame(this._frame), (this._frame = null))
        }
        _calcDialogHeight() {
          const e = this._calcAvailableHeight()
          return e < this._dialog.clientHeight ? e : this._dialog.clientHeight
        }
        _calcAvailableHeight() {
          return (
            document.documentElement.clientHeight - 2 * this._guard.vertical
          )
        }
      }
      var b = i(813113),
        v = i(910549),
        y = i(285089),
        f = i(308326)
      f['tooltip-offset']
      class k extends r.PureComponent {
        constructor(e) {
          super(e),
            (this._dialog = null),
            (this._cleanUpFunctions = []),
            (this._prevActiveElement = null),
            (this._handleDialogRef = (e) => {
              const { reference: t } = this.props
              ;(this._dialog = e), 'function' == typeof t && t(e)
            }),
            (this._handleFocus = (e) => {
              this._moveToTop()
            }),
            (this._handleMouseDown = (e) => {
              this._moveToTop()
            }),
            (this._handleTouchStart = (e) => {
              this._moveToTop()
            }),
            (this.state = { canFitTooltip: !1 })
        }
        render() {
          return r.createElement(
            v.PopupContext.Provider,
            { value: this },
            r.createElement(
              l.OutsideEvent,
              {
                mouseDown: !0,
                touchStart: !0,
                handler: this.props.onClickOutside,
              },
              (e) =>
                r.createElement(
                  'div',
                  {
                    ref: e,
                    'data-outside-boundary-for': this.props.name,
                    onFocus: this._handleFocus,
                    onMouseDown: this._handleMouseDown,
                    onTouchStart: this._handleTouchStart,
                    'data-dialog-name': this.props['data-dialog-name'],
                  },
                  r.createElement(
                    n.Dialog,
                    {
                      style: this._applyAnimationCSSVariables(),
                      ...this.props,
                      reference: this._handleDialogRef,
                      className: s(f.dialog, this.props.className),
                    },
                    !1,
                    this.props.children,
                  ),
                ),
            ),
          )
        }
        componentDidMount() {
          const { draggable: e, boundByScreen: t, onDragStart: i } = this.props,
            r = (0, o.ensureNotNull)(this._dialog)
          if (e) {
            const e = r.querySelector('[data-dragg-area]')
            if (e && e instanceof HTMLElement) {
              const s = new g(r, e, {
                boundByScreen: Boolean(t),
                onDragStart: i,
              })
              this._cleanUpFunctions.push(() => s.destroy()), (this._drag = s)
            }
          }
          ;(this._prevActiveElement = document.activeElement),
            this.props.autofocus &&
              !r.contains(document.activeElement) &&
              r.focus(),
            (this._isFullScreen() || this.props.fixedBody) &&
              (0, y.setFixedBodyState)(!0)
          const { guard: s, calculateDialogPosition: n } = this.props
          if (this.props.resizeHandler) this._resize = this.props.resizeHandler
          else {
            const e = new _(r, { guard: s, calculateDialogPosition: n })
            this._cleanUpFunctions.push(() => e.destroy()), (this._resize = e)
          }
          if (
            (this.props.isAnimationEnabled &&
              this.props.growPoint &&
              this._applyAppearanceAnimation(this.props.growPoint),
            this.props.centeredOnMount && this._resize.centerAndFit(),
            this._resize.setFullscreen(this._isFullScreen()),
            this.props.shouldForceFocus)
          ) {
            if (this.props.onForceFocus) return void this.props.onForceFocus(r)
            r.focus()
          }
        }
        componentDidUpdate() {
          if (this._resize) {
            const { guard: e, calculateDialogPosition: t } = this.props
            this._resize.updateOptions({
              guard: e,
              calculateDialogPosition: t,
            }),
              this._resize.setFullscreen(this._isFullScreen())
          }
          this._drag &&
            this._drag.updateOptions({
              boundByScreen: Boolean(this.props.boundByScreen),
              onDragStart: this.props.onDragStart,
            })
        }
        componentWillUnmount() {
          var e
          if (
            this.props.shouldReturnFocus &&
            this._prevActiveElement &&
            document.body.contains(this._prevActiveElement) &&
            (null === document.activeElement ||
              document.activeElement === document.body ||
              (null === (e = this._dialog) || void 0 === e
                ? void 0
                : e.contains(document.activeElement)))
          )
            try {
              this._prevActiveElement.focus({ preventScroll: !0 })
            } catch (e) {}
          for (const e of this._cleanUpFunctions) e()
          ;(this._isFullScreen() || this.props.fixedBody) &&
            (0, y.setFixedBodyState)(!1)
        }
        focus() {
          this._dialog && this._dialog.focus()
        }
        centerAndFit() {
          this._resize && this._resize.centerAndFit()
        }
        recalculateBounds() {
          this._resize && this._resize.recalculateBounds()
        }
        _moveToTop() {
          null !== this.context && this.context.moveToTop()
        }
        _applyAnimationCSSVariables() {
          return {
            '--animationTranslateStartX': null,
            '--animationTranslateStartY': null,
            '--animationTranslateEndX': null,
            '--animationTranslateEndY': null,
          }
        }
        _applyAppearanceAnimation(e) {
          if (this._resize && this._dialog) {
            const { x: t, y: i } = e,
              { x: r, y: s } = this._resize.getDialogsTopLeftCoordinates()
            this._dialog.style.setProperty(
              '--animationTranslateStartX',
              `${t}px`,
            ),
              this._dialog.style.setProperty(
                '--animationTranslateStartY',
                `${i}px`,
              ),
              this._dialog.style.setProperty(
                '--animationTranslateEndX',
                `${r}px`,
              ),
              this._dialog.style.setProperty(
                '--animationTranslateEndY',
                `${s}px`,
              ),
              this._dialog.classList.add(f.dialogAnimatedAppearance)
          }
        }
        _handleTooltipFit() {
          0
        }
        _isFullScreen() {
          return Boolean(this.props.fullscreen)
        }
      }
      ;(k.contextType = b.PortalContext),
        (k.defaultProps = {
          boundByScreen: !0,
          draggable: !0,
          centeredOnMount: !0,
          shouldReturnFocus: !0,
        })
      const S = (0, a.makeOverlapable)(k)
    },
    661851: (e, t, i) => {
      i.d(t, { useObservable: () => o, useObservableSubscription: () => s })
      var r = i(50959)
      function s(e, t) {
        ;(0, r.useEffect)(() => {
          const i = e.subscribe(t)
          return () => i.unsubscribe()
        }, [e, t])
      }
      function o(e, t) {
        const i = (0, r.useCallback)(
            void 0 !== t
              ? () => t
              : () => {
                  let t
                  return (
                    e
                      .subscribe((e) => {
                        t = e
                      })
                      .unsubscribe(),
                    t
                  )
                },
            [t, e],
          ),
          [o, n] = (0, r.useState)(i),
          a = (0, r.useCallback)((e) => n(() => e), [n])
        return s(e, a), o
      }
    },
    494707: (e, t, i) => {
      i.d(t, { Separator: () => n })
      var r = i(50959),
        s = i(497754),
        o = i(345719)
      function n(e) {
        return r.createElement('div', {
          className: s(o.separator, e.className),
        })
      }
    },
    874485: (e, t, i) => {
      i.d(t, { makeOverlapable: () => o })
      var r = i(50959),
        s = i(813113)
      function o(e) {
        return class extends r.PureComponent {
          render() {
            const { isOpened: t, root: i } = this.props
            if (!t) return null
            const o = r.createElement(e, { ...this.props, zIndex: 150 })
            return 'parent' === i ? o : r.createElement(s.Portal, null, o)
          }
        }
      }
    },
    379266: (e, t, i) => {
      i.d(t, { PopupMenuItemToggle: () => l })
      var r = i(50959),
        s = i(497754),
        o = i(192063),
        n = i(302946),
        a = i(354583)
      function l(e) {
        const {
          isDisabled: t,
          hint: i,
          label: l,
          isChecked: c,
          checkboxClassName: d,
          labelClassName: u,
          indeterminate: h,
          isActive: p,
          checkboxTabIndex: g,
          checkboxReference: m,
          checkboxDataRole: _,
          ...b
        } = e
        return r.createElement(o.PopupMenuItem, {
          ...b,
          isDisabled: t,
          shortcut: i,
          dontClosePopup: !0,
          labelRowClassName: u,
          label: r.createElement(n.Checkbox, {
            reference: m,
            disabled: t,
            label: l,
            checked: c,
            indeterminate: h,
            className: s(a.checkbox, d),
            tabIndex: g,
            'data-role': _,
          }),
        })
      }
    },
    730743: (e, t, i) => {
      i.d(t, { calcSubMenuPos: () => s })
      var r = i(710263)
      function s(e, t, i = { x: 0, y: 10 }) {
        if (t) {
          const { left: i, right: s, top: o } = t.getBoundingClientRect(),
            n = document.documentElement.clientWidth,
            a = { x: i - e, y: o },
            l = { x: s, y: o }
          return (0, r.isRtl)() ? (i <= e ? l : a) : n - s >= e ? l : a
        }
        return i
      }
    },
    106056: (e, t, i) => {
      var r, s, o
      i.d(t, {
        CloseTrigger: () => r,
        ToastAnimationStage: () => s,
        ToastPriority: () => o,
      }),
        ((e) => {
          ;(e.Swipe = 'swipe'), (e.Click = 'click')
        })(r || (r = {})),
        ((e) => {
          ;(e[(e.Add = 0)] = 'Add'),
            (e[(e.Remove = 1)] = 'Remove'),
            (e[(e.None = 2)] = 'None')
        })(s || (s = {})),
        ((e) => {
          ;(e[(e.Low = 0)] = 'Low'),
            (e[(e.Medium = 1)] = 'Medium'),
            (e[(e.High = 2)] = 'High')
        })(o || (o = {}))
    },
    502869: (e) => {
      e.exports = { button: 'button-xNqEcuN2' }
    },
    486141: (e) => {
      e.exports = { wrapper: 'wrapper-k5swolgQ', text: 'text-k5swolgQ' }
    },
    707488: (e) => {
      e.exports = {
        blockHidden: 'blockHidden-e6PF69Df',
        'pane-button': 'pane-button-e6PF69Df',
      }
    },
    275583: (e) => {
      e.exports = { toggle: 'toggle-NYDT3E70', label: 'label-NYDT3E70' }
    },
    517327: (e) => {
      e.exports = {
        dropdownButton: 'dropdownButton-NgHNzdZC',
        bigIcon: 'bigIcon-NgHNzdZC',
      }
    },
    623549: (e) => {
      e.exports = {
        toggleContentWrapper: 'toggleContentWrapper-i9xADy_f',
        checkBoxWrapper: 'checkBoxWrapper-i9xADy_f',
      }
    },
    844012: (e) => {
      e.exports = { 'css-value-padding': '4px' }
    },
    199056: (e) => {
      e.exports = {
        'css-value-padding': '4px',
        container: 'container-hw_3o_pb',
        informerWrapper: 'informerWrapper-hw_3o_pb',
        notAvailableOnMobile: 'notAvailableOnMobile-hw_3o_pb',
        column: 'column-hw_3o_pb',
        touchMode: 'touchMode-hw_3o_pb',
        buttonsWrapper: 'buttonsWrapper-hw_3o_pb',
        button: 'button-hw_3o_pb',
        sellButton: 'sellButton-hw_3o_pb',
        buyButton: 'buyButton-hw_3o_pb',
        brokerButton: 'brokerButton-hw_3o_pb',
        highButtons: 'highButtons-hw_3o_pb',
        withoutBg: 'withoutBg-hw_3o_pb',
        lastCharSup: 'lastCharSup-hw_3o_pb',
        spreadQtyWrapper: 'spreadQtyWrapper-hw_3o_pb',
        spread: 'spread-hw_3o_pb',
        withoutQty: 'withoutQty-hw_3o_pb',
        qty: 'qty-hw_3o_pb',
        loader: 'loader-hw_3o_pb',
        circleLoader: 'circleLoader-hw_3o_pb',
        loading: 'loading-hw_3o_pb',
        buttonText: 'buttonText-hw_3o_pb',
        brokerButtonIconWrap: 'brokerButtonIconWrap-hw_3o_pb',
        brokerButtonDefault: 'brokerButtonDefault-hw_3o_pb',
        buttons: 'buttons-hw_3o_pb',
      }
    },
    312282: (e) => {
      e.exports = { mobile: 'screen and (max-width: 567px)' }
    },
    396789: (e) => {
      e.exports = { tabs: 'tabs-oqHzGqN1', divider: 'divider-oqHzGqN1' }
    },
    640712: (e) => {
      e.exports = { popupWrapper: 'popupWrapper-sxxSUmLh' }
    },
    517516: (e) => {
      e.exports = {
        'small-height-breakpoint': 'screen and (max-height: 360px)',
        moreButton: 'moreButton-LjodxXHh',
        header: 'header-LjodxXHh',
        brokerSelectScreenWrapper: 'brokerSelectScreenWrapper-LjodxXHh',
      }
    },
    886495: (e) => {
      e.exports = {
        content: 'content-iSoiahCU',
        contentInner: 'contentInner-iSoiahCU',
      }
    },
    793361: (e, t, i) => {
      i.d(t, { splitThousands: () => s })
      var r = i(150335)
      function s(e, t = '&nbsp;') {
        let i = e + ''
        ;-1 !== i.indexOf('e') &&
          (i = ((e) =>
            (0, r.fixComputationError)(e)
              .toFixed(10)
              .replace(/\.?0+$/, ''))(Number(e)))
        const s = i.split('.')
        return (
          s[0].replace(/\B(?=(\d{3})+(?!\d))/g, t) + (s[1] ? '.' + s[1] : '')
        )
      }
    },
    395907: (e, t, i) => {
      i.d(t, { ToolWidgetIconButton: () => a })
      var r = i(50959),
        s = i(497754),
        o = i(747633),
        n = i(502869)
      const a = r.forwardRef((e, t) => {
        const { className: i, id: a, ...l } = e
        return r.createElement(o.ToolWidgetButton, {
          id: a,
          'data-name': a,
          ...l,
          ref: t,
          className: s(i, n.button),
        })
      })
    },
    851237: (e, t, i) => {
      i.d(t, { reactLoaderRendererCreator: () => n })
      var r = i(265742),
        s = i(50959),
        o = i(707488)
      function n(e, t) {
        return (i, n) =>
          ((e, t, i, n) => {
            const a = document.createElement('span'),
              l = (0, r.createRoot)(a)
            function c(e) {
              a.classList.toggle(o.blockHidden, !e)
            }
            c(!1)
            const { className: d } = null != n ? n : {}
            return (
              d && a.classList.add(d),
              l.render((0, s.createElement)(t, i)),
              e.appendChild(a),
              {
                toggleVisibility: c,
                destroy: () => {
                  l.unmount()
                },
              }
            )
          })(i, e, t, n)
      }
    },
    462892: (e, t, i) => {
      i.d(t, { createPointsLoaderRenderer: () => s })
      var r = i(234404)
      const s = (0, i(851237).reactLoaderRendererCreator)(r.Loader, {
        staticPosition: !0,
        size: 'small',
      })
    },
    112235: (e, t, i) => {
      i.d(t, { OfflineScreen: () => a, renderOfflineScreen: () => l })
      var r = i(50959),
        s = i(500962),
        o = i(609838),
        n = i(486141)
      function a() {
        return r.createElement(
          'div',
          { className: n.wrapper },
          r.createElement(
            'p',
            { className: n.text },
            o.t(null, void 0, i(394021)),
          ),
        )
      }
      function l(e) {
        s.render(r.createElement(a, null), e)
      }
    },
    521744: (e, t, i) => {
      i.d(t, { trackingModeIsAvailable: () => r })
      const r = i(601227).CheckMobile.any()
    },
    783806: (e, t, i) => {
      i.d(t, { TerminalDropdown: () => N })
      var r = i(50959),
        s = i(609838),
        o = i(497754),
        n = i.n(o),
        a = i(601227),
        l = i(72571),
        c = i(518799),
        d = i(747633),
        u = i(192063),
        h = i(350299)
      const p = r.lazy(async () => ({
        default: (
          await Promise.all([
            i.e(2109),
            i.e(2253),
            i.e(580),
            i.e(2108),
            i.e(5145),
            i.e(855),
            i.e(2191),
            i.e(6639),
            i.e(7194),
            i.e(4215),
            i.e(7653),
            i.e(766),
            i.e(2985),
          ]).then(i.bind(i, 432177))
        ).ExportDataDialogImpl,
      }))
      function g(e) {
        return r.createElement(
          r.Suspense,
          { fallback: null },
          r.createElement(p, { ...e }),
        )
      }
      var m = i(661851),
        _ = i(379266),
        b = i(624216),
        v = i(759339),
        y = i(189904),
        f = i(972535),
        k = i(823030),
        S = i(522224),
        P = i(730743)
      var C = i(930052),
        w = i(309210),
        B = i(379978)
      function T(e) {
        return r.createElement(
          C.MatchMedia,
          { rule: 'screen and (max-width: 430px)' },
          (t) =>
            t || e.forceUseDrawer
              ? r.createElement(O, { ...e })
              : r.createElement(D, { ...e }),
        )
      }
      function E(e) {
        const { toolboxLabel: t, ...i } = e
        return r.createElement(u.PopupMenuItem, {
          toolbox: r.createElement(
            r.Fragment,
            null,
            t && r.createElement('span', { className: w.toolboxLabel }, t),
            r.createElement(l.Icon, { className: w.icon, icon: B }),
          ),
          suppressToolboxClick: !1,
          dontClosePopup: !0,
          ...i,
        })
      }
      function O(e) {
        const {
            children: t,
            className: i,
            drawerClassName: s,
            menuItemTheme: o,
            label: n,
            icon: a,
            labelClassName: l,
            toolboxLabel: c,
          } = e,
          [d, u] = (0, r.useState)(!1)
        return r.createElement(
          r.Fragment,
          null,
          r.createElement(E, {
            theme: o,
            label: n,
            toolboxLabel: c,
            icon: a,
            labelClassName: l,
            className: i,
            onClick: () => {
              u(!d)
            },
          }),
          d &&
            r.createElement(
              v.Drawer,
              {
                className: s,
                position: 'Bottom',
                onClose: () => {
                  u(!1)
                },
              },
              t,
            ),
        )
      }
      function D(e) {
        const {
            children: t,
            className: i,
            menuClassName: s,
            menuItemTheme: o,
            label: n,
            icon: a,
            labelClassName: l,
            toolboxLabel: c,
          } = e,
          d = (0, r.useRef)((0, y.randomHash)()),
          u = (0, r.useRef)(null),
          {
            isMenuOpened: h,
            onTriggerClick: p,
            onTriggerMouseOver: g,
            onMenuClose: m,
            getPosition: _,
            onMenuMouseOver: v,
          } = ((e, t, i = {}) => {
            const s = r.useContext(k.SubmenuContext)
            r.useEffect(
              () => (null == s ? void 0 : s.registerSubmenu(e, a)),
              [e],
            )
            const o = Boolean((null == s ? void 0 : s.current) === e)
            return {
              isMenuOpened: o,
              onTriggerClick: () => {
                ;(f.mobiletouch || i.forceOpenOnClick) &&
                  (null == s || s.setCurrent(o ? null : e))
              },
              onMenuClose: () => {
                null == s || s.setCurrent(null)
              },
              getPosition: (e) =>
                (0, P.calcSubMenuPos)(e.contentWidth, t.current),
              onMenuMouseOver: n,
              onTriggerMouseOver: n,
            }
            function n(t) {
              !f.mobiletouch &&
                (0, S.hoverMouseEventFilter)(t) &&
                (null == s || s.setCurrent(e))
            }
            function a(e) {
              var i
              return Boolean(
                null === (i = t.current) || void 0 === i
                  ? void 0
                  : i.contains(e),
              )
            }
          })(d.current, u)
        return r.createElement(
          r.Fragment,
          null,
          r.createElement(E, {
            theme: o,
            label: n,
            toolboxLabel: c,
            icon: a,
            labelClassName: l,
            className: i,
            onClick: p,
            onMouseOver: g,
            reference: u,
            isHovered: h,
          }),
          r.createElement(
            b.PopupMenu,
            {
              className: s,
              position: _,
              onClose: m,
              isOpened: h,
              doNotCloseOn: u.current,
              onMouseOver: v,
            },
            t,
          ),
        )
      }
      var I = i(275583)
      function x(e) {
        const {
            labelClassName: t,
            summaryFieldsVisibilityInfo$: o,
            summaryFieldToggler: n,
            initialSummaryFieldsVisibilityInfo: l,
          } = e,
          c = (0, m.useObservable)(o, l)
        return 0 === c.size
          ? r.createElement(r.Fragment, null)
          : r.createElement(
              T,
              {
                label: s.t(null, void 0, i(522382)),
                labelClassName: t,
                forceUseDrawer: a.CheckMobile.any(),
              },
              [...c.values()].map((e) =>
                r.createElement(_.PopupMenuItemToggle, {
                  key: e.id,
                  className: I.toggle,
                  label: r.createElement('span', { className: I.label }, e.id),
                  isChecked: e.visible,
                  onClick: () => n(e.id),
                }),
              ),
            )
      }
      var M = i(517327),
        A = i(48008)
      function N(e) {
        const {
            dataExportController: t,
            initialSummaryFieldsVisibilityInfo: o,
            summaryFieldToggler: p,
            summaryFieldsVisibilityInfo$: m,
            iconSize: _,
          } = e,
          [b, v] = ((e) => {
            const { dataExportController: t, trackEvent: i } = e,
              [s, o] = (0, r.useState)(!1)
            return void 0 === t
              ? [() => {}, null]
              : [
                  () => o(!0),
                  r.createElement(g, {
                    isOpened: s,
                    onClose: () => o(!1),
                    trackEvent: i,
                    dataExportController: t,
                  }),
                ]
          })({ dataExportController: t })
        return r.createElement(
          r.Fragment,
          null,
          r.createElement(
            c.ToolWidgetMenu,
            {
              arrow: !1,
              isDrawer: a.CheckMobile.any(),
              className: M.dropdownButton,
              content: r.createElement(d.ToolWidgetButton, {
                title: s.t(null, void 0, i(141610)),
                icon: r.createElement(l.Icon, {
                  className: n()('big' === _ && M.bigIcon),
                  icon: A,
                }),
              }),
              'data-name': 'terminal-dropdown',
            },
            r.createElement(x, {
              labelClassName: M.label,
              summaryFieldToggler: p,
              summaryFieldsVisibilityInfo$: m,
              initialSummaryFieldsVisibilityInfo: o,
            }),
            null !== v &&
              r.createElement(u.PopupMenuItem, {
                labelClassName: M.label,
                label: (0, h.appendEllipsis)(s.t(null, void 0, i(125769))),
                onClick: b,
              }),
          ),
          v,
        )
      }
    },
    407999: (e, t, i) => {
      i.d(t, { makeAccountManagerHeaderDropdownsProps: () => g })
      var r = i(275734),
        s = i(757604),
        o = i(650151),
        n = i(481330),
        a = i(480802),
        l = i(752275),
        c = i(6835),
        d = i(637401)
      const u = (0, c.getLogger)('Trading.DataExport')
      class h {
        constructor(e, t) {
          ;(this._prefix = t), (this._getDataExporters = e)
        }
        tabs() {
          return [...this._getDataExporters()].map(([e, t]) => ({
            value: e,
            content: t.title,
          }))
        }
        async exportData(e) {
          const { exporters: t, title: i } = (0, o.ensureDefined)(
            this._getDataExporters().get(e),
            'data exporter',
          )
          try {
            const e = await Promise.all(t.map(({ exportData: e }) => e()))
            e.forEach((r, s) => {
              const o = t[s].name,
                n =
                  void 0 === o || '' === o
                    ? `${(0, a.default)(i)}${e.length > 1 ? `-${s + 1}` : ''}`
                    : (0, a.default)(o)
              let c = ''
              if (0 !== r.length) {
                const e = [p(Object.keys(r[0]))]
                for (const t of r) e.push(p(Object.values(t)))
                c = e.join('\n')
              }
              ;(0, l.saveTextFile)(
                `${(0, a.default)(this._prefix)}-${n}-${(new Date()).toISOString()}.csv`,
                c,
                'text/csv',
              )
            })
          } catch (e) {
            u.logError((0, d.getLoggerMessage)(e))
          }
        }
      }
      function p(e) {
        return e
          .map((e) => ('number' == typeof e ? e : (0, l.escapeCSVValue)(e)))
          .join(',')
      }
      async function g(e, t, i, a) {
        const l = (await e.brokersMetainfo()).filter(
            (e) => !e.configFlags.isSuspended,
          ),
          c = Promise.resolve(void 0),
          d = (0, o.ensureNotNull)(e.activeBroker()),
          u = await c,
          p = await d.accountsMetainfo(),
          g = d.accountManagerInfo()
        if (0 === p.length) return
        const m = p.map((e) => {
            var t
            return {
              id: e.id,
              name: e.name,
              currency:
                '' === e.currency
                  ? void 0
                  : null !== (t = e.currency) && void 0 !== t
                    ? t
                    : void 0,
              isDefault: e.isDefault,
              selectAccount: async () => {
                e.id !== d.currentAccount() && d.setCurrentAccount(e.id)
              },
            }
          }),
          _ = (e) => (0, o.ensureDefined)(m.find((t) => t.id === e)),
          b = (0, r.fromEventPattern)(
            (e) => d.currentAccountUpdate.subscribe(null, e),
            (e) => d.currentAccountUpdate.unsubscribe(null, e),
            _,
          ).pipe((0, s.startWith)(_(d.currentAccount()))),
          v = d.metainfo(),
          y = void 0 !== u ? (0, n.brokersListFromPlans)(l, u) : void 0,
          f =
            void 0 !== y
              ? {
                  title: g.accountTitle,
                  brokerName: v.title,
                  brokerId: v.id,
                  logo: v.logoMiniUrl,
                  logoBlack: v.logoMiniBlackUrl,
                  actions: d.buttonDropdownActions(),
                  trading: e,
                  brokers: y,
                  mode: i,
                  isBeta: v.isBeta,
                  realtimeDataPermissionsConfig:
                    v.realtimeDataPermissionsToggleConfig,
                }
              : void 0,
          k = {
            dataExportController: void 0 !== a ? new h(a, v.title) : void 0,
            initialSummaryFieldsVisibilityInfo: t.fieldsVisibilityInfo(),
            summaryFieldsVisibilityInfo$: t.fieldsVisibilityInfo$,
            summaryFieldToggler: t.toggleField,
          }
        return {
          brokerDropdownProps: f,
          accountDropdownProps: {
            currentAccount$: b,
            accountsList: m,
            removeMargins: void 0 === f,
            trackEvent: e.trackEvent,
            showErrorNotification: e.showErrorNotification,
            mode: i,
            createAccount: d.config.supportCreateAccount
              ? d.createAccount
              : void 0,
            deleteAccount: d.config.supportDeleteAccount
              ? d.deleteAccount
              : void 0,
            resetAccount: d.config.supportResetAccount
              ? d.resetAccount
              : void 0,
            changeAccountSettings: d.config.supportChangeAccountSettings
              ? d.changeAccountSettings
              : void 0,
            accountSettingsInfo:
              d.config.supportCreateAccount ||
              d.config.supportResetAccount ||
              d.config.supportChangeAccountSettings
                ? d.accountSettingsInfo
                : void 0,
          },
          commonDropdownProps: k,
        }
      }
    },
    241347: (e, t, i) => {
      i.r(t), i.d(t, { SummaryFieldsVisibilityManager: () => s })
      var r = i(947488)
      class s {
        constructor(e, t) {
          var i
          ;(this.toggleField = (e) => {
            var t
            const i = this._fieldsVisibilityInfo$.getValue(),
              r = new Map(i),
              s = r.get(e)
            void 0 !== s &&
              ((s.visible = !s.visible),
              this._fieldsVisibilityInfo$.next(r),
              null === (t = this._settingsGetter()) ||
                void 0 === t ||
                t.setSummaryFieldsVisibilityInfo(r))
          }),
            (this._settingsGetter = t)
          const s =
            null === (i = this._settingsGetter()) || void 0 === i
              ? void 0
              : i.summaryFieldsVisibilityInfo()
          ;(this._fieldsVisibilityInfo$ = new r.BehaviorSubject(
            new Map(
              e.map(({ text: e, isDefault: t }) => {
                var i, r, o
                return [
                  e,
                  {
                    id: e,
                    visible:
                      null ===
                        (o =
                          null !==
                            (r =
                              null === (i = null == s ? void 0 : s.get(e)) ||
                              void 0 === i
                                ? void 0
                                : i.visible) && void 0 !== r
                            ? r
                            : t) ||
                      void 0 === o ||
                      o,
                  },
                ]
              }),
            ),
          )),
            (this.fieldsVisibilityInfo$ =
              this._fieldsVisibilityInfo$.asObservable())
        }
        fieldsVisibilityInfo() {
          return this._fieldsVisibilityInfo$.getValue()
        }
      }
    },
    943778: (e, t, i) => {
      i.d(t, {
        pipsToPrice: () => a,
        pipsToRiskInCurrency: () => l,
        pipsToRiskInPercent: () => c,
        priceToPips: () => s,
        riskInCurrencyToPips: () => o,
        riskInPercentToPips: () => n,
      })
      var r = i(960521)
      function s(e, t, i, s) {
        return (0, r.Big)(e).minus(t).div(s).div(i).toNumber()
      }
      function o(e, t, i, s, o) {
        const n = (0, r.Big)(i)
          .mul(t)
          .mul(o || 1)
        if (n.eq(0)) return 0
        const a = (0, r.Big)(e).div(n).mul(s).toNumber()
        return Math.floor(a)
      }
      function n(e, t, i, s, o, n) {
        const a = (0, r.Big)(s)
          .mul(t)
          .mul(n || 1)
          .mul(100)
        if (a.eq(0)) return 0
        const l = (0, r.Big)(e).mul(i).div(a).mul(o).toNumber()
        return Math.floor(l)
      }
      function a(e, t, i, s) {
        return (0, r.Big)(i).mul(e).mul(s).plus(t).toNumber()
      }
      function l(e, t, i, s, o) {
        return (0, r.Big)(e)
          .mul(i)
          .mul(t)
          .mul(o || 1)
          .div(s)
          .toNumber()
      }
      function c(e, t, i, s, o, n) {
        return i
          ? (0, r.Big)(e)
              .mul(s)
              .mul(t)
              .mul(n || 1)
              .mul(100)
              .div(i)
              .div(o)
              .toNumber()
          : 0
      }
    },
    164530: (e, t, i) => {
      i.d(t, {
        BracketType: () => r.BracketType,
        OrderOrPositionMessageType: () => r.OrderOrPositionMessageType,
      })
      i(282729)
      var r = i(656846)
      i(311757)
    },
    656846: (e, t, i) => {
      var r, s, o, n, a, l, c, d, u, h, p, g, m, _, b
      i.d(t, {
        AccountType: () => g,
        BracketType: () => d,
        DisconnectType: () => m,
        OrderOrPositionMessageType: () => p,
        PipValueType: () => _,
        RestrictionType: () => b,
        TradingEntityType: () => l,
      }),
        ((e) => {
          ;(e[(e.CONNECTED = 1)] = 'CONNECTED'),
            (e[(e.CONNECTING = 2)] = 'CONNECTING'),
            (e[(e.DISCONNECTED = 3)] = 'DISCONNECTED'),
            (e[(e.ERROR = 4)] = 'ERROR')
        })(r || (r = {})),
        ((e) => {
          ;(e[(e.LIMIT = 1)] = 'LIMIT'),
            (e[(e.MARKET = 2)] = 'MARKET'),
            (e[(e.STOP = 3)] = 'STOP'),
            (e[(e.STOPLIMIT = 4)] = 'STOPLIMIT')
        })(s || (s = {})),
        ((e) => {
          ;(e[(e.BUY = 1)] = 'BUY'), (e[(e.SELL = -1)] = 'SELL')
        })(o || (o = {})),
        ((e) => {
          ;(e[(e.CANCELED = 1)] = 'CANCELED'),
            (e[(e.FILLED = 2)] = 'FILLED'),
            (e[(e.INACTIVE = 3)] = 'INACTIVE'),
            (e[(e.PLACING = 4)] = 'PLACING'),
            (e[(e.REJECTED = 5)] = 'REJECTED'),
            (e[(e.WORKING = 6)] = 'WORKING')
        })(n || (n = {})),
        ((e) => {
          ;(e[(e.ALL = 0)] = 'ALL'),
            (e[(e.CANCELED = 1)] = 'CANCELED'),
            (e[(e.FILLED = 2)] = 'FILLED'),
            (e[(e.INACTIVE = 3)] = 'INACTIVE'),
            (e[(e.REJECTED = 5)] = 'REJECTED'),
            (e[(e.WORKING = 6)] = 'WORKING')
        })(a || (a = {})),
        ((e) => {
          ;(e[(e.Order = 1)] = 'Order'), (e[(e.Position = 2)] = 'Position')
        })(l || (l = {})),
        ((e) => {
          ;(e[(e.ORDER = 1)] = 'ORDER'), (e[(e.POSITION = 2)] = 'POSITION')
        })(c || (c = {})),
        ((e) => {
          ;(e[(e.StopLoss = 0)] = 'StopLoss'),
            (e[(e.TakeProfit = 1)] = 'TakeProfit'),
            (e[(e.TrailingStop = 2)] = 'TrailingStop')
        })(d || (d = {})),
        ((e) => {
          ;(e[(e.LIMITPRICE = 1)] = 'LIMITPRICE'),
            (e[(e.STOPPRICE = 2)] = 'STOPPRICE'),
            (e[(e.TAKEPROFIT = 3)] = 'TAKEPROFIT'),
            (e[(e.STOPLOSS = 4)] = 'STOPLOSS')
        })(u || (u = {})),
        ((e) => {
          ;(e[(e.ERROR = 0)] = 'ERROR'), (e[(e.SUCCESS = 1)] = 'SUCCESS')
        })(h || (h = {})),
        ((e) => {
          ;(e.Information = 'information'),
            (e.Warning = 'warning'),
            (e.Error = 'error')
        })(p || (p = {})),
        ((e) => {
          ;(e.Demo = 'demo'), (e.Live = 'live')
        })(g || (g = {})),
        ((e) => {
          ;(e[(e.LogOut = 0)] = 'LogOut'),
            (e[(e.FailedRestoring = 1)] = 'FailedRestoring'),
            (e[(e.Offline = 2)] = 'Offline'),
            (e[(e.APIError = 3)] = 'APIError'),
            (e[(e.TwoFactorRequired = 4)] = 'TwoFactorRequired'),
            (e[(e.CancelAuthorization = 5)] = 'CancelAuthorization'),
            (e[(e.TimeOutForAuthorization = 6)] = 'TimeOutForAuthorization'),
            (e[(e.OauthError = 7)] = 'OauthError'),
            (e[(e.BrokenConnection = 8)] = 'BrokenConnection'),
            (e[(e.FailedSignIn = 9)] = 'FailedSignIn')
        })(m || (m = {})),
        ((e) => {
          ;(e[(e.None = 0)] = 'None'),
            (e[(e.Pips = 1)] = 'Pips'),
            (e[(e.Ticks = 2)] = 'Ticks')
        })(_ || (_ = {})),
        ((e) => {
          ;(e.Halted = 'HALTED'),
            (e.NotShortable = 'NOT-SHORTABLE'),
            (e.HardToBorrow = 'HARD-TO-BORROW')
        })(b || (b = {}))
    },
    282729: (e, t, i) => {
      var r
      i.d(t, { StopType: () => r }),
        ((e) => {
          ;(e[(e.StopLoss = 0)] = 'StopLoss'),
            (e[(e.TrailingStop = 1)] = 'TrailingStop')
        })(r || (r = {}))
    },
    484095: (e, t, i) => {
      function r(e) {
        return e instanceof s
      }
      i.d(t, { UserFriendlyError: () => s, isUserFriendlyError: () => r })
      class s extends Error {
        constructor({
          detailedErrorMessage: e,
          userFriendlyMessage: t,
          cause: i,
        }) {
          super(t),
            (this.name = 'UserFriendlyError'),
            (this.detailedErrorMessage = e),
            (this.cause = i)
        }
      }
    },
    637401: (e, t, i) => {
      i.d(t, {
        getErrorCauses: () => E,
        getErrorMessage: () => B,
        getLoggerMessage: () => T,
        isFinalOrderStatus: () => P,
        makeNonTradableSymbolText: () => w,
        orderStatusToText: () => b,
        orderTypeToText: () => f,
        positionSideToText: () => C,
        roundToStepByPriceTypeAndSide: () => k,
        roundUpToPowerOf10: () => S,
        sideToText: () => y,
      })
      var r = i(609838),
        s = i(960521),
        o = i(656846),
        n = i(282729),
        a = (i(793361), i(372605), i(6835)),
        l = i(311757),
        c = (i(802778), i(484095))
      const d = { 2: {}, 1: {} },
        u = { 2: {}, 1: {} },
        h = {},
        p = {},
        g = {}
      let m = !1
      ;(0, a.getLogger)('Trading.Utils')
      var _
      !((e) => {
        ;(e[(e.Unauthorized = 401)] = 'Unauthorized'),
          (e[(e.TooManyRequests = 429)] = 'TooManyRequests')
      })(_ || (_ = {}))
      r.t(null, void 0, i(378505))
      function b(e) {
        return v(), g[e]
      }
      function v() {
        m ||
          ((m = !0),
          (d[2][2] = r.t(null, { context: 'Market order' }, i(610952))),
          (d[2][1] = r.t(null, { context: 'Limit order' }, i(382377))),
          (d[2][3] = r.t(null, { context: 'order' }, i(608921))),
          (d[2][4] = r.t(null, { context: 'Stop limit order' }, i(779062))),
          (d[1][2] = r.t(null, void 0, i(359758))),
          (d[1][1] = r.t(null, void 0, i(398157))),
          (d[1][3] = r.t(null, { context: 'order' }, i(7122))),
          (d[1][4] = r.t(null, void 0, i(900853))),
          (u[2][o.BracketType.TakeProfit] = r.t(
            null,
            { context: 'Take profit order' },
            i(347947),
          )),
          (u[2][o.BracketType.StopLoss] = r.t(
            null,
            { context: 'Stop loss order' },
            i(15307),
          )),
          (u[2][o.BracketType.TrailingStop] = r.t(
            null,
            { context: 'Trailing stop order' },
            i(154462),
          )),
          (u[1][o.BracketType.TakeProfit] = r.t(null, void 0, i(129266))),
          (u[1][o.BracketType.StopLoss] = r.t(null, void 0, i(241648))),
          (u[1][o.BracketType.TrailingStop] = r.t(null, void 0, i(86430))),
          (h[1] = r.t(null, { context: 'trading' }, i(63470))),
          (h[-1] = r.t(null, { context: 'trading' }, i(742259))),
          (p[1] = r.t(null, { context: 'trading' }, i(274771))),
          (p[-1] = r.t(null, { context: 'trading' }, i(951219))),
          (g[2] = r.t(null, void 0, i(885323))),
          (g[1] = r.t(null, void 0, i(767207))),
          (g[6] = r.t(null, void 0, i(328231))),
          (g[3] = r.t(null, void 0, i(614841))),
          (g[4] = r.t(null, void 0, i(373425))),
          (g[5] = r.t(null, void 0, i(442060))))
      }
      function y(e, t) {
        v()
        const i = h[e]
        return t ? i.toUpperCase() : i
      }
      function f(e) {
        const {
          orderType: t,
          uppercase: i,
          shorten: r,
          parentId: s,
          stopType: a,
        } = e
        v()
        const l = r ? 2 : 1
        let c = d,
          h = t
        return (
          void 0 !== s &&
            ((c = u),
            3 === t &&
              (h =
                a === n.StopType.TrailingStop
                  ? o.BracketType.TrailingStop
                  : o.BracketType.StopLoss),
            1 === t && (h = o.BracketType.TakeProfit)),
          i ? c[l][h].toUpperCase() : c[l][h]
        )
      }
      function k(e, t, i, r) {
        const o = (0, s.Big)(e).div(t)
        return (1 === i && 1 === r) || (2 === i && -1 === r)
          ? o.round(0, 0).mul(t).toNumber()
          : (1 === i && -1 === r) || (2 === i && 1 === r)
            ? o.round(0, 3).mul(t).toNumber()
            : 0
      }
      r.t(null, void 0, i(609372))
      function S(e) {
        const t = Math.ceil(Math.log10(e))
        return (0, s.Big)(10).pow(t).toNumber()
      }
      function P(e) {
        return -1 !== [2, 1, 5].indexOf(e)
      }
      function C(e) {
        return v(), p[e]
      }
      function w(e, t) {
        return r
          .t(null, void 0, i(221456))
          .replace('{symbol}', e)
          .replace('{broker}', t)
      }
      function B(e) {
        if (void 0 === e) return r.t(null, void 0, i(328523))
        let t
        return (
          (t =
            e instanceof Error
              ? e.message
              : 'object' == typeof e
                ? JSON.stringify(e)
                : e.toString()),
          (0, l.removeTags)(t)
        )
      }
      function T(e) {
        return e instanceof c.UserFriendlyError
          ? (0, l.removeTags)(e.detailedErrorMessage)
          : B(e)
      }
      o.BracketType.StopLoss,
        r.t(null, void 0, i(241648)),
        o.BracketType.TakeProfit,
        r.t(null, void 0, i(129266)),
        o.BracketType.TrailingStop,
        r.t(null, void 0, i(86430)),
        o.BracketType.StopLoss,
        o.BracketType.TakeProfit,
        o.BracketType.TrailingStop
      new Set([
        'date',
        'dateOrDateTime',
        'default',
        'fixed',
        'variablePrecision',
        'formatQuantity',
        'formatPrice',
        'formatPriceForexSup',
        'integerSeparated',
        'localDate',
        'localDateOrDateTime',
        'percentage',
        'pips',
        'profit',
        'profitInInstrumentCurrency',
        'side',
        'positionSide',
        'status',
        'symbol',
        'text',
        'type',
        'marginPercent',
        'empty',
      ])
      function E(e) {
        return (0, c.isUserFriendlyError)(e) && void 0 !== e.cause
          ? [...E(e.cause), e.cause]
          : [e]
      }
    },
    326285: (e, t, i) => {
      i.r(t),
        i.d(t, {
          addBroker: () => Oe,
          brokersList: () => De,
          createBrokerConnection: () => xe,
          getBrokerMetainfo: () => Me,
        })
      var r = i(609838),
        s = i(116193),
        o = i(148442),
        n = i(586639),
        a = i(275734),
        l = i(156963),
        c = i(656846),
        d = i(372605),
        u = i(466052),
        h = i(650151)
      class p {
        constructor(e) {
          ;(this._objects = {}),
            (this._started = !1),
            (this._isObjectsRequestActual = !1),
            (this._ordersPromise = null),
            (this._getter = e),
            (this.updateDelegate = new u.Delegate()),
            (this.partialUpdateDelegate = new u.Delegate())
        }
        start() {
          this._started ||
            ((this._started = !0),
            (this._ordersPromise = this._requestObjects()))
        }
        stop() {
          ;(this._objects = {}),
            (this._started = !1),
            (this._ordersPromise = null),
            (this._isObjectsRequestActual = !1)
        }
        update(e, t) {
          this._started &&
            (this._isObjectsRequestActual
              ? (this._isObjectsRequestActual = !1)
              : ((this._objects[e.id] = e), this._onObjectUpdated(e, t)))
        }
        partialUpdate(e, t) {
          if (!this._started) return
          if (this._isObjectsRequestActual)
            return void (this._isObjectsRequestActual = !1)
          let i, r
          ;(0, d.isObject)(e)
            ? ((i = e.id), (r = e))
            : ((i = e), (r = (0, h.ensure)(t)))
          const s = this._objects[i]
          s && (Object.assign(s, r), this.partialUpdateDelegate.fire(s, r))
        }
        fullUpdate() {
          this._started &&
            (this._isObjectsRequestActual
              ? (this._isObjectsRequestActual = !1)
              : (this._ordersPromise = this._requestObjects()))
        }
        getObjects() {
          return (
            this._ordersPromise || Promise.resolve(Object.values(this._objects))
          )
        }
        _onObjectUpdated(e, t) {
          this.updateDelegate.fire(e, t)
        }
        _onAllObjectsUpdated() {
          this._objectsCache().forEach((e) => this.updateDelegate.fire(e, !0))
        }
        _objectsCache() {
          return Object.values(this._objects)
        }
        async _requestObjects() {
          let e = []
          do {
            ;(this._isObjectsRequestActual = !0), (e = await this._getter())
          } while (!this._isObjectsRequestActual)
          var t
          return (
            (this._objects =
              ((t = 'id'), e.reduce((e, i) => ((e[i[t]] = i), e), {}))),
            (this._ordersPromise = null),
            (this._isObjectsRequestActual = !1),
            this._onAllObjectsUpdated(),
            e
          )
        }
      }
      var g = i(6835),
        m = i(511990)
      class _ extends p {
        constructor(e, t) {
          super(e), (this._brokerConfigGetter = t)
        }
        _onObjectUpdated(e, t) {
          this._patchIndividualPositions(
            this._objectsCache().filter(
              (t) => t.symbol === e.symbol && 0 !== t.qty,
            ),
            e,
            t,
          ),
            super._onObjectUpdated(e, t)
        }
        _onAllObjectsUpdated() {
          this._patchIndividualPositions(
            this._objectsCache().filter((e) => 0 !== e.qty),
          ),
            super._onAllObjectsUpdated()
        }
        _patchIndividualPositions(e, t, i) {
          const r = this._brokerConfigGetter()
          let s
          s = r.requiresFIFOCloseIndividualPositions
            ? r.fifoOnlyForSameQty
              ? y
              : v
            : b
          const o = s(e)
          for (const e of o) t !== e && super._onObjectUpdated(e, i)
        }
      }
      function b(e) {
        const t = []
        for (const i of e) i.canBeClosed || ((i.canBeClosed = !0), t.push(i))
        return t
      }
      function v(e) {
        const t = {}
        for (const i of e) {
          let e = t[i.symbol]
          void 0 === e && ((e = { oldest: null, all: [] }), (t[i.symbol] = e)),
            (null === e.oldest || e.oldest.date > i.date) && (e.oldest = i),
            e.all.push(i)
        }
        const i = []
        for (const e of Object.keys(t)) {
          const r = (0, h.ensureDefined)(t[e])
          for (const e of r.all) {
            const t = r.oldest === e,
              s = t !== e.canBeClosed
            ;(e.canBeClosed = t), s && i.push(e)
          }
        }
        return i
      }
      function y(e) {
        const t = {}
        for (const i of e) {
          let e = t[i.symbol]
          void 0 === e && ((e = {}), (t[i.symbol] = e))
          let r = e[i.qty]
          void 0 === r && ((r = { oldest: null, all: [] }), (e[i.qty] = r)),
            (null === r.oldest || r.oldest.date > i.date) && (r.oldest = i),
            r.all.push(i)
        }
        const i = []
        for (const e of Object.keys(t)) {
          const r = (0, h.ensureDefined)(t[e])
          for (const e of Object.keys(r)) {
            const t = (0, h.ensureDefined)(r[e])
            for (const e of t.all) {
              const r = t.oldest === e,
                s = r !== e.canBeClosed
              ;(e.canBeClosed = r), s && i.push(e)
            }
          }
        }
        return i
      }
      const f = (0, g.getLogger)('Trading.Migrations')
      var k = i(637401),
        S = i(311757),
        P = i(508334),
        C = i(189904),
        w = i(481330)
      function B(e, t) {
        return {
          symbol: t.symbol,
          type: 2,
          side: 1 === t.side ? -1 : 1,
          qty: Math.abs(e),
          seenPrice: null,
          isClose: !0,
        }
      }
      var T = i(864348)
      class E {
        constructor() {
          this._validators = new Map()
        }
        add(e, t) {
          this._validators.set(t, e)
        }
        validate(e) {
          const t = {}
          let i = !0
          for (const [r, s] of this._validators.entries()) {
            const o = s.validate(e)
            o.isValid || ((i = !1), (t[r] = o.errorMessage))
          }
          return i ? { isValid: i } : { isValid: i, errorMessages: t }
        }
      }
      class O {
        constructor(e, t, i = []) {
          ;(this._status = T.PlaceOrEditContextStatus.Undefined),
            (this._onStatusChange = new u.Delegate()),
            (this._onDataChange = new u.Delegate()),
            (this._errors = {}),
            (this._isValidationEnabled = t),
            (this._source = e),
            (this._validator = new E())
          for (const { validator: e, validatorName: t } of i)
            this._validator.add(e, t)
        }
        onReady() {
          return this._onReady
        }
        source() {
          return this._source
        }
        data() {
          return this._orderData
        }
        async setData(e, t) {
          ;(this._orderData = await this._processOrderData(e)),
            this._assertOrderIsValid(),
            (this._source = t),
            this._onDataChange.fire()
        }
        status() {
          return this._status
        }
        errors() {
          return this._errors
        }
        onStatusChange() {
          return this._onStatusChange
        }
        onDataChange() {
          return this._onDataChange
        }
        async send(e) {
          if (this._status === T.PlaceOrEditContextStatus.Error)
            return (
              this._processError(new Error(Object.values(this._errors)[0])), !1
            )
          if (this._status !== T.PlaceOrEditContextStatus.Undefined) return !1
          this._setStatus(T.PlaceOrEditContextStatus.Loading),
            await this._onReady
          const t = await this._processSend(e),
            i = t
              ? T.PlaceOrEditContextStatus.Undefined
              : T.PlaceOrEditContextStatus.Error
          return this._setStatus(i), t
        }
        async preview() {
          return this._status === T.PlaceOrEditContextStatus.Error
            ? { sections: [] }
            : (await this._onReady, this._preview(this._orderData))
        }
        _assertOrderIsValid() {
          const { isValid: e, errorMessages: t } = this._validate()
          let i = !1
          if (e)
            (i = this._status !== T.PlaceOrEditContextStatus.Undefined),
              (this._errors = {}),
              (this._status = T.PlaceOrEditContextStatus.Undefined)
          else {
            const [e] = (0, d.deepEquals)(this._errors, t)
            ;(i = !e),
              (this._errors = t),
              (this._status = T.PlaceOrEditContextStatus.Error)
          }
          i && this._onStatusChange.fire()
        }
        _setStatus(e) {
          this._status !== e &&
            ((this._status = e), this._onStatusChange.fire())
        }
        _validate() {
          return this._isValidationEnabled
            ? this._validator.validate(this._orderData)
            : { isValid: !0 }
        }
      }
      var D = i(957877),
        I = i(807107)
      class x {
        constructor(e) {
          const {
            priceType: t,
            quotesGetter: i,
            formatter: r,
            instrumentInfo: s,
            supportStopOrdersInBothDirections: o,
            supportStopLimitOrdersInBothDirections: n,
            supportStrictCheckingLimitOrderPrice: a,
          } = e
          ;(this._priceType = t),
            (this._getQuotes = i),
            (this._formatter = r),
            (this._supportStopOrdersInBothDirections = Boolean(o)),
            (this._supportStopLimitOrdersInBothDirections = Boolean(n)),
            (this._supportStrictCheckingLimitOrderPrice = Boolean(a)),
            (this._symbolType = s.type || ''),
            (this._minTick = s.minTick),
            (this._limitPriceStep = s.limitPriceStep),
            (this._stopPriceStep = s.stopPriceStep),
            (this._variableMinTickData = s.variableMinTick
              ? (0, I.makeVariableMinTickData)(this._minTick, s.variableMinTick)
              : void 0)
        }
        validate(e) {
          const { type: t, side: s, stopPrice: o, limitPrice: n } = e,
            a = 2 === this._priceType
          if (2 === t || (a && 1 === t) || (!a && 3 === t))
            return { isValid: !0 }
          const l = a ? o : n
          if (void 0 === l)
            return { isValid: !1, errorMessage: r.t(null, void 0, i(347957)) }
          const c = (0, w.getPriceStep)({
              price: l,
              priceType: this._priceType,
              minTick: this._minTick,
              variableMinTickData: this._variableMinTickData,
              limitPriceStep: this._limitPriceStep,
              stopPriceStep: this._stopPriceStep,
            }),
            d = (0, w.roundToStepRequired)({
              priceType: this._priceType,
              minTick: this._minTick,
              limitPriceStep: this._limitPriceStep,
              stopPriceStep: this._stopPriceStep,
            }),
            u = (0, D.validatePrice)({
              price: l,
              askOrBid: (0, w.getQuotePrice)(this._getQuotes(), s),
              orderType: t,
              side: s,
              isStopPrice: a,
              isForex: 'forex' === this._symbolType,
              formatter: this._formatter,
              supportStopOrdersInBothDirections:
                this._supportStopOrdersInBothDirections,
              supportStopLimitOrdersInBothDirections:
                this._supportStopLimitOrdersInBothDirections,
              supportStrictCheckingLimitOrderPrice:
                this._supportStrictCheckingLimitOrderPrice,
              step: c,
              roundedToStep: d,
            })
          return u.res ? { isValid: !1, errorMessage: u.msg } : { isValid: !0 }
        }
      }
      var M = i(99708)
      class A {
        constructor(e) {
          this._quantityMetainfo = e
        }
        validate(e) {
          const t = (0, M.checkQtyError)(this._quantityMetainfo, e.qty, !0)
          return t.res ? { isValid: !1, errorMessage: t.msg } : { isValid: !0 }
        }
      }
      var N = i(960521),
        L = i(798165)
      class V {
        constructor(e) {
          const {
            instrumentInfo: t,
            quotesGetter: i,
            baseCurrencyCryptoBalanceGetter: r,
            quoteCurrencyCryptoBalanceGetter: s,
          } = e
          ;(this._quantityMetainfo = t.qty),
            (this._getQuotes = i),
            (this._getBaseCurrencyCryptoBalance = r),
            (this._getQuoteCurrencyCryptoBalance = s)
        }
        validate(e) {
          const t = (0, M.checkQtyError)(this._quantityMetainfo, e.qty, !0)
          if (t.res) return { isValid: !1, errorMessage: t.msg }
          const s = (0, w.getOrderPrice)(e, this._getQuotes()),
            o = Object.hasOwn(e, 'id')
          if (void 0 === s)
            return { isValid: !1, errorMessage: r.t(null, void 0, i(347957)) }
          const n = (0, w.getCryptoBalanceValue)({
              balance: this._getBaseCurrencyCryptoBalance(),
              side: e.side,
              isExistingOrder: o,
              qty: e.qty,
              orderPrice: s,
            }),
            a = (0, w.getCryptoBalanceValue)({
              balance: this._getQuoteCurrencyCryptoBalance(),
              side: e.side,
              isExistingOrder: o,
              qty: e.qty,
              orderPrice: s,
            }),
            l = (0, L.validateBalance)({
              side: e.side,
              baseValue: e.qty,
              baseBalanceValue: n,
              quoteValue: (0, N.Big)(e.qty).mul(s).toNumber(),
              quoteBalanceValue: a,
            })
          return l.res ? { isValid: !1, errorMessage: l.msg } : { isValid: !0 }
        }
      }
      var R = i(164530),
        F = i(346849),
        W = i(943778)
      class q {
        constructor(e) {
          this._bracketPercentPriceRuleCheckers = []
          const {
            bracketType: t,
            priceType: i,
            parentType: r,
            quotesGetter: s,
            formatter: o,
            instrumentInfo: n,
            validationRules: a,
          } = e
          if (
            ((this._bracketType = t),
            (this._priceType = i),
            (this._parentType = r),
            (this._getQuotes = s),
            (this._formatter = o),
            (this._pipSize = n.pipSize),
            (this._priceStep = (0, w.getPriceStep)({
              priceType: i,
              minTick: n.minTick || n.pipSize,
              limitPriceStep: n.limitPriceStep,
              stopPriceStep: n.stopPriceStep,
            })),
            (this._roundToStepRequired = (0, w.roundToStepRequired)({
              priceType: i,
              minTick: n.minTick || n.pipSize,
              limitPriceStep: n.limitPriceStep,
              stopPriceStep: n.stopPriceStep,
            })),
            void 0 !== a)
          )
            for (const e of a)
              this._bracketPercentPriceRuleCheckers.push(
                (0, F.makeBracketPercentPriceRuleChecker)(
                  e.options.min,
                  e.options.max,
                ),
              )
        }
        validate(e) {
          const { side: t, takeProfit: s, stopLoss: o, trailingStopPips: n } = e
          if (
            (this._bracketType === R.BracketType.TakeProfit && void 0 === s) ||
            (this._bracketType === R.BracketType.StopLoss && void 0 === o) ||
            (this._bracketType === R.BracketType.TrailingStop && void 0 === n)
          )
            return { isValid: !0 }
          const a = (0, w.getOrderPrice)(e, this._getQuotes())
          if (void 0 === a)
            return { isValid: !1, errorMessage: r.t(null, void 0, i(762686)) }
          const l =
              (this._bracketType !== R.BracketType.TakeProfit ? -1 : 1) * t,
            c = this._getPrice(e, a, l),
            d = this._getPips(e, a, l),
            u = (0, F.checkBracketError)({
              quotes: this._getQuotes(),
              side: t,
              price: c,
              pips: d,
              priceType: this._priceType,
              priceStep: this._priceStep,
              parentPrice: a,
              parentType: this._parentType,
              bracketType: this._bracketType,
              isStatusEditing: !1,
              isEnabled: !0,
              bracketPercentPriceRuleCheckers:
                this._bracketPercentPriceRuleCheckers,
              priceFormatter: this._formatter,
              isRoundToPriceStep: this._roundToStepRequired,
            })
          return u.res ? { isValid: !1, errorMessage: u.msg } : { isValid: !0 }
        }
        _getPrice(e, t, i) {
          var r, s
          switch (this._bracketType) {
            case R.BracketType.TakeProfit:
              return null !== (r = e.takeProfit) && void 0 !== r ? r : null
            case R.BracketType.StopLoss:
              return null !== (s = e.stopLoss) && void 0 !== s ? s : null
            case R.BracketType.TrailingStop:
              return void 0 === e.trailingStopPips
                ? null
                : (0, W.pipsToPrice)(e.trailingStopPips, t, i, this._pipSize)
            default:
              return null
          }
        }
        _getPips(e, t, i) {
          var r
          switch (this._bracketType) {
            case R.BracketType.TakeProfit:
              return void 0 === e.takeProfit
                ? null
                : (0, W.priceToPips)(e.takeProfit, t, i, this._pipSize)
            case R.BracketType.StopLoss:
              return void 0 === e.stopLoss
                ? null
                : (0, W.priceToPips)(e.stopLoss, t, i, this._pipSize)
            case R.BracketType.TrailingStop:
              return null !== (r = e.trailingStopPips) && void 0 !== r
                ? r
                : null
            default:
              return null
          }
        }
      }
      class U {
        constructor(e) {
          const { orderDialogOptions: t } = e
          this._orderDialogOptions = t
        }
        validate(e) {
          var t
          const { customFields: s } = e
          if (
            void 0 ===
              (null === (t = this._orderDialogOptions) || void 0 === t
                ? void 0
                : t.customFields) ||
            0 === this._orderDialogOptions.customFields.length
          )
            return { isValid: !0 }
          const o = []
          return (
            this._orderDialogOptions.customFields.forEach((e) => {
              void 0 === (null == s ? void 0 : s[e.id]) && o.push(e.title)
            }),
            0 === o.length
              ? { isValid: !0 }
              : {
                  isValid: !1,
                  errorMessage: r
                    .t(null, void 0, i(346881))
                    .format({ customFields: o.join(', ') }),
                }
          )
        }
      }
      var z = i(46130)
      const $ = 'promise rejected by time-out'
      function H(e, t) {
        let i
        const r = (0, z.createDeferredPromise)()
        return {
          subscription: e.subscribe((e) => {
            var s
            r.resolve(),
              (i = e),
              null === (s = null == t ? void 0 : t.onValueChange) ||
                void 0 === s ||
                s.call(t)
          }),
          getter: () => i,
          ready: (null == t ? void 0 : t.timeout)
            ? (0, m.makeTimeLimited)(r.promise, t.timeout, $).catch((e) => {
                if (e !== $) throw e
                void 0 !== (null == t ? void 0 : t.timeoutValue) &&
                  (i = t.timeoutValue)
              })
            : r.promise,
        }
      }
      class Q extends O {
        constructor(e) {
          const {
              orderData: t,
              source: i,
              instrumentInfo: r,
              quotes$: s,
              configFlags: o,
              formatter: n,
              tpValidationRules: a,
              slValidationRules: l,
              isValidationEnabled: d,
              orderDialogOptions: u,
              callbacks: h,
              baseCurrencyCryptoBalance$: p,
              quoteCurrencyCryptoBalance$: g,
            } = e,
            m = { onValueChange: () => {} },
            _ = { ...m, timeout: 2e3, timeoutValue: null },
            { subscription: b, getter: v, ready: y } = H(s, m),
            { subscription: f, getter: k, ready: S } = H(p, _),
            { subscription: P, getter: C, ready: w } = H(g, _),
            B =
              o.supportCryptoExchangeOrderTicket ||
              (o.supportSymbolSpecificCryptoOrderTicket && 'crypto' === r.type)
                ? new V({
                    instrumentInfo: r,
                    quotesGetter: v,
                    baseCurrencyCryptoBalanceGetter: k,
                    quoteCurrencyCryptoBalanceGetter: C,
                  })
                : new A(r.qty)
          super(i, d, [
            { validator: B, validatorName: 'qty' },
            {
              validator: new x({
                priceType: 2,
                quotesGetter: v,
                formatter: n,
                instrumentInfo: r,
                supportStopOrdersInBothDirections:
                  o.supportStopOrdersInBothDirections,
                supportStopLimitOrdersInBothDirections:
                  o.supportStopLimitOrdersInBothDirections,
              }),
              validatorName: 'stopPrice',
            },
            {
              validator: new x({
                priceType: 1,
                quotesGetter: v,
                formatter: n,
                instrumentInfo: r,
                supportStrictCheckingLimitOrderPrice:
                  o.supportStrictCheckingLimitOrderPrice,
              }),
              validatorName: 'limitPrice',
            },
            {
              validator: new U({ orderDialogOptions: u }),
              validatorName: 'customFields',
            },
            {
              validator: new q({
                bracketType: c.BracketType.TakeProfit,
                priceType: 1,
                parentType: 1,
                quotesGetter: v,
                formatter: n,
                instrumentInfo: r,
                validationRules: a,
              }),
              validatorName: 'takeProfit',
            },
            {
              validator: new q({
                bracketType: c.BracketType.StopLoss,
                priceType: 2,
                parentType: 1,
                quotesGetter: v,
                formatter: n,
                instrumentInfo: r,
                validationRules: l,
              }),
              validatorName: 'stopLoss',
            },
            {
              validator: new q({
                bracketType: c.BracketType.TrailingStop,
                priceType: 2,
                parentType: 1,
                quotesGetter: v,
                formatter: n,
                instrumentInfo: r,
                validationRules: l,
              }),
              validatorName: 'trailingStopPips',
            },
          ]),
            (this._quotesSubscription = b),
            (this._quoteCurrencyCryptoBalanceSubscription = P),
            (this._baseCurrencyCryptoBalanceSubscription = f),
            (this._createInitialPreOrder = h.createInitialPreOrder),
            (this._placeOrder = h.placeOrder),
            (this._previewOrder = h.previewOrder),
            (this._handleError = h.handleError),
            (this._onReady = Promise.all([y, S, w])
              .then(() => this.setData(t, i))
              .then(() => {
                m.onValueChange = () => this._assertOrderIsValid()
              }))
        }
        externalContext() {
          return {
            type: T.PlaceOrEditContextType.PlaceOrder,
            source: () => this.source(),
            data: () => this.data(),
            preview: () => this.preview(),
            send: () => this.send(),
            status: () => this.status(),
            errors: () => this.errors(),
          }
        }
        destroy() {
          this._quotesSubscription.unsubscribe(),
            this._quoteCurrencyCryptoBalanceSubscription.unsubscribe(),
            this._baseCurrencyCryptoBalanceSubscription.unsubscribe()
        }
        _processSend(e) {
          return this._placeOrder(this._orderData, e)
        }
        _processError(e) {
          this._handleError(e)
        }
        _processOrderData(e) {
          return this._createInitialPreOrder(e)
        }
        _preview(e) {
          return this._previewOrder(e)
        }
      }
      var j = i(822914),
        K = i(282729)
      class G extends O {
        constructor(e) {
          const { orderData: t, source: i, callbacks: r } = e
          super(i, !1),
            (this._modifyOrder = r.modifyOrder),
            (this._metainfo = r.metainfo),
            (this._symbolInfo = r.symbolInfo),
            (this._orderById = r.orderById),
            (this._previewOrder = r.previewOrder),
            (this._handleError = r.handleError),
            (this._onReady = this.setData(t, i))
        }
        externalContext() {
          return {
            type: T.PlaceOrEditContextType.EditOrder,
            source: () => this.source(),
            data: () => this.data(),
            send: () => this.send(),
            status: () => this.status(),
            errors: () => this.errors(),
            preview: () => this.preview(),
          }
        }
        destroy() {}
        async _processOrderData(e) {
          if (!this._metainfo().configFlags.supportModifyTrailingStop) {
            const t = await this._orderById(e.id)
            e.hasTrailingStopBracket =
              void 0 !== t && void 0 !== t.trailingStopPips
          }
          const { limitPriceStep: t, stopPriceStep: i } =
            await this._symbolInfo(e.symbol)
          if (
            ((e.limitPrice =
              void 0 !== t && void 0 !== e.limitPrice
                ? (0, k.roundToStepByPriceTypeAndSide)(
                    e.limitPrice,
                    t,
                    1,
                    e.side,
                  )
                : e.limitPrice),
            (e.stopPrice =
              void 0 !== i && void 0 !== e.stopPrice
                ? (0, k.roundToStepByPriceTypeAndSide)(
                    e.stopPrice,
                    i,
                    2,
                    e.side,
                  )
                : e.stopPrice),
            void 0 !== e.parentId &&
              !l.enabled('always_pass_called_order_to_modify'))
          ) {
            let t
            try {
              t = await this._orderById(e.parentId)
            } catch (e) {
              ;(0, k.getLoggerMessage)(e)
            }
            if (void 0 !== t && (0, w.isOrderActive)(t.status)) {
              const i = (0, j.default)(t)
              return (
                void 0 !== e.limitPrice && (i.takeProfit = e.limitPrice),
                void 0 !== e.stopPrice &&
                  (e.stopType === K.StopType.TrailingStop &&
                  void 0 !== e.trailingStopPips
                    ? ((i.trailingStopPips = e.trailingStopPips),
                      delete i.stopLoss)
                    : ((i.stopLoss = e.stopPrice), delete i.trailingStopPips)),
                i
              )
            }
          }
          return e
        }
        _processSend(e) {
          return this._modifyOrder(this._orderData, e)
        }
        _processError(e) {
          this._handleError(e)
        }
        _preview(e) {
          return this._previewOrder({ ...e, seenPrice: null })
        }
        _configureValidator() {}
      }
      var Z = i(232192)
      const J = (0, g.getLogger)('Trading.BrokerConnectionAdapter'),
        X = r.t(null, void 0, i(473142)),
        Y = r.t(null, void 0, i(945593))
      function ee(e) {
        ;(0, h.assert)('object' != typeof e, 'Expected not an object')
      }
      class te {
        constructor({
          brokerMetainfo: e,
          brokerConnection: t,
          host: s,
          brokerRealtimeAdapter: o,
          tradingStat: n,
          tradingSettingsStorageGetter: a,
          brokerPlan: l,
        }) {
          ;(this.connectionStatusUpdate = new u.Delegate()),
            (this.executionUpdate = new u.Delegate()),
            (this.tradingOperationFinished = new u.Delegate()),
            (this.currentAccountUpdate = new u.Delegate()),
            (this._brokerPlan = null),
            (this._subscriptions = {}),
            (this._lastFireResult = {}),
            (this._fakeDOMSubscriptions = {}),
            (this._formattersCache = {}),
            (this._spreadFormattersCache = {}),
            (this._quantityFormattersCache = {}),
            (this._individualPositionsCache = null),
            (this._fakePositionUpdateDelegate = null),
            (this._realtimeSubscriptionState = []),
            (this._loggedInManually = !1),
            (this._pendingSubscriptions = []),
            (this._sessionId = (0, C.guid)()),
            (this.createAccount = (e) => {
              if (
                this.config.supportCreateAccount &&
                this._brokerConnection.createAccount
              )
                return this._brokerConnection.createAccount(e)
              throw new Error('Method createAccount is not implemented')
            }),
            (this.accountSettingsInfo = (e) => {
              if (
                (this.config.supportCreateAccount ||
                  this.config.supportResetAccount ||
                  this.config.supportChangeAccountSettings) &&
                this._brokerConnection.accountSettingsInfo
              )
                return this._brokerConnection.accountSettingsInfo(e)
              throw new Error('Method accountSettingsInfo is not implemented')
            }),
            (this.resetAccount = (e) => {
              if (
                this.config.supportResetAccount &&
                this._brokerConnection.resetAccount
              )
                return this._brokerConnection.resetAccount(e)
              throw new Error('Method resetAccount is not implemented')
            }),
            (this.changeAccountSettings = (e) => {
              if (
                this.config.supportChangeAccountSettings &&
                this._brokerConnection.changeAccountSettings
              )
                return this._brokerConnection.changeAccountSettings(e)
              throw new Error('Method changeAccountSettings is not implemented')
            }),
            (this.deleteAccount = (e) => {
              if (
                this.config.supportDeleteAccount &&
                this._brokerConnection.deleteAccount
              )
                return this._brokerConnection.deleteAccount(e)
              throw new Error('Method deleteAccount is not implemented')
            }),
            (this.leverageInfo = (e) => {
              if (
                this.config.supportLeverage &&
                this._brokerConnection.leverageInfo
              )
                return this._brokerConnection.leverageInfo(e)
              throw new Error('Method leverage is not implemented')
            }),
            (this.setLeverage = (e) => {
              if (
                this.config.supportLeverage &&
                this._brokerConnection.setLeverage
              )
                return this._brokerConnection.setLeverage(e)
              throw new Error('Method setLeverage is not implemented')
            }),
            (this.previewLeverage = (e) => {
              if (
                this.config.supportLeverage &&
                this._brokerConnection.previewLeverage
              )
                return this._brokerConnection.previewLeverage(e)
              throw new Error('Method previewLeverage is not implemented')
            }),
            (this.maintenanceStatus = async () => {
              try {
                return void 0 !== this._brokerConnection.maintenanceStatus
                  ? await this._brokerConnection.maintenanceStatus()
                  : { isMaintenance: !1 }
              } catch (e) {
                return (
                  this._brokerLogger.logError(
                    `Failed to fetch maintenance status: ${(0, k.getLoggerMessage)(e)}`,
                  ),
                  {
                    isMaintenance: !0,
                    message: r.t(
                      null,
                      { replace: { brokerName: this._brokerMetainfo.title } },
                      i(8793),
                    ),
                  }
                )
              }
            }),
            (this._handleStatusChange = (e) => {
              var t
              1 !== e &&
                (null === (t = this._placeOrderContextWithMetaInfo) ||
                  void 0 === t ||
                  t.context.destroy())
            }),
            (this.config = Object.assign({}, e.configFlags)),
            (this._brokerMetainfo = this._patchMetainfo(e)),
            (this._brokerPlan = l || null),
            (this._brokerConnection = t),
            (this._host = s),
            (this._tradingStat = n),
            (this._getTradingSettingsStorage = a),
            (this._brokerLogger = (0, g.getLogger)(
              'Trading.' + this._brokerMetainfo.id + '.Connection',
            )),
            s.setBrokerConnectionAdapter(this),
            this._initializeConnectProtection(),
            (this._positionsCache = t.positions
              ? new p(() => (t.positions ? t.positions() : Promise.resolve([])))
              : null),
            (this._individualPositionsCache = t.individualPositions
              ? new _(
                  () =>
                    t.individualPositions
                      ? t.individualPositions()
                      : Promise.resolve([]),
                  () => this.config,
                )
              : null),
            (this._ordersCache = new p(() => t.orders()))
          const c = (e) => {
            1 === e
              ? (null !== this._positionsCache && this._positionsCache.start(),
                this._ordersCache.start(),
                this._individualPositionsCache &&
                  this._individualPositionsCache.start())
              : (null !== this._positionsCache && this._positionsCache.stop(),
                this._ordersCache.stop(),
                this._individualPositionsCache &&
                  this._individualPositionsCache.stop())
          }
          this.connectionStatusUpdate.subscribe(null, c),
            c(this.connectionStatus()),
            this.connectionStatusUpdate.subscribe(
              null,
              this._handleStatusChange,
            ),
            (this._originalDOMSubscriptionMethods = {
              subscribeDOM: t.subscribeDOM,
              unsubscribeDOM: t.unsubscribeDOM,
            }),
            this._patchBrokerSubscribeUnsubscribeDOMMethods(),
            this.connectionStatusUpdate.subscribe(null, (e) => {
              1 === e && this._patchBrokerSubscribeUnsubscribeDOMMethods()
            }),
            e.configFlags.supportPositions ||
              (this._fakePositionUpdateDelegate = new u.Delegate()),
            (this._brokerRealtimeAdapter = o)
        }
        tryRestoreSession() {
          if (this._brokerConnection.tryRestoreSession)
            return this._brokerConnection.tryRestoreSession()
        }
        get orderUpdate() {
          return this._ordersCache.updateDelegate
        }
        get positionUpdate() {
          return null === this._fakePositionUpdateDelegate
            ? (0, h.ensure)(this._positionsCache).updateDelegate
            : this._fakePositionUpdateDelegate
        }
        get individualPositionUpdate() {
          return (0, h.ensure)(this._individualPositionsCache).updateDelegate
        }
        get orderPartialUpdate() {
          return this._ordersCache.partialUpdateDelegate
        }
        get positionPartialUpdate() {
          return null === this._fakePositionUpdateDelegate
            ? (0, h.ensure)(this._positionsCache).partialUpdateDelegate
            : this._fakePositionUpdateDelegate
        }
        get individualPositionPartialUpdate() {
          return (0, h.ensure)(this._individualPositionsCache)
            .partialUpdateDelegate
        }
        onOrderUpdate(e) {
          this._ordersCache.update(e)
        }
        onOrderPartialUpdate(e, t) {
          this._ordersCache.partialUpdate(e, t)
        }
        onPositionUpdate(e, t) {
          if (
            ((0, h.assert)(
              !!this.config.supportPositions,
              'Broker doesn`t support positions',
            ),
            0 === e.qty)
          ) {
            const t = this._lastFireResult[e.id]
            t && delete t.PL
          }
          ;(0, h.ensure)(this._positionsCache).update(e, t)
        }
        onPositionPartialUpdate(e, t) {
          ;(0, h.assert)(
            !!this.config.supportPositions,
            'Broker doesn`t support positions',
          ),
            (0, h.ensure)(this._positionsCache).partialUpdate(e, t)
        }
        onIndividualPositionUpdate(e, t) {
          if (
            ((0, h.assert)(
              !!this.config.supportPositionNetting,
              'Broker doesn`t support individual positions',
            ),
            0 === e.qty)
          ) {
            const t = this._lastFireResult[e.symbol]
            t && delete t.IndividualPositionPL
          }
          ;(0, h.ensure)(this._individualPositionsCache).update(e, t)
        }
        onIndividualPositionPartialUpdate(e, t) {
          ;(0, h.ensure)(this._individualPositionsCache).partialUpdate(e, t)
        }
        onCurrentAccountChanged() {
          null !== this._positionsCache && this._positionsCache.fullUpdate(),
            this._ordersCache.fullUpdate(),
            this._individualPositionsCache &&
              this._individualPositionsCache.fullUpdate()
          const e = this.currentAccount()
          this.currentAccountUpdate.fire(e)
        }
        patchConfig(e) {
          var t
          !Object.hasOwn((t = e), 'supportBrackets') ||
            Object.hasOwn(t, 'supportOrderBrackets') ||
            Object.hasOwn(t, 'supportPositionBrackets') ||
            (f.logWarn(
              'supportBrackets is deprecated. Use supportOrderBrackets and supportPositionBrackets instead.',
            ),
            (t.supportOrderBrackets = t.supportBrackets),
            (t.supportPositionBrackets = t.supportBrackets)),
            Object.hasOwn(t, 'supportModifyOrder') &&
              (f.logWarn(
                'supportModifyOrder is deprecated. Use supportModifyOrderPrice, supportEditAmount and supportModifyBrackets instead.',
              ),
              (t.supportModifyOrderPrice = t.supportModifyOrder),
              (t.supportEditAmount = t.supportModifyOrder),
              (t.supportModifyBrackets = t.supportModifyOrder)),
            Object.assign(this.config, e),
            Object.assign(this._brokerMetainfo.configFlags, e),
            (this._brokerMetainfo = this._patchMetainfo(this._brokerMetainfo)),
            this._updateConfigDependentProperties()
        }
        async getOrderDialogOptions(e) {
          if (void 0 !== this._brokerConnection.getOrderDialogOptions)
            try {
              return await this._brokerConnection.getOrderDialogOptions(e)
            } catch (e) {
              return void this._brokerLogger.logError(
                `Failed to fetch options for the order dialog: ${(0, k.getLoggerMessage)(e)}`,
              )
            }
        }
        getPositionDialogOptions() {
          return void 0 !== this._brokerConnection.getPositionDialogOptions
            ? this._brokerConnection.getPositionDialogOptions()
            : void 0
        }
        async getSymbolSpecificTradingOptions(e) {
          var t, i
          try {
            const { allowedDurations: r, allowedOrderTypes: s } =
                await this.symbolInfo(e),
              {
                supportOrderBrackets: o,
                supportPositionBrackets: n,
                supportIndividualPositionBrackets: a,
                supportReversePosition: l,
                supportModifyBrackets: c,
                supportAddBracketsToExistingOrder: d,
              } = this._brokerMetainfo.configFlags
            return {
              allowedDurations: r,
              allowedOrderTypes: s,
              supportOrderBrackets: o,
              supportPositionBrackets: n,
              supportIndividualPositionBrackets: a,
              supportReversePosition: l,
              supportModifyBrackets: c,
              supportAddBracketsToExistingOrder: d,
              ...(await (null ===
                (i = (t = this._brokerConnection)
                  .getSymbolSpecificTradingOptions) || void 0 === i
                ? void 0
                : i.call(t, e))),
            }
          } catch (e) {
            return void this._brokerLogger.logWarn((0, k.getLoggerMessage)(e))
          }
        }
        getValidationRules(e) {
          return void 0 !== this._brokerConnection.getValidationRules
            ? this._brokerConnection.getValidationRules(e)
            : void 0
        }
        chartContextMenuActions(e, t) {
          return this._brokerConnection.chartContextMenuActions(e, t)
        }
        buttonDropdownActions() {
          return this._host.buttonDropdownActions()
        }
        connectionStatus() {
          return this._brokerConnection.connectionStatus()
        }
        isConnected() {
          return 1 === this._brokerConnection.connectionStatus()
        }
        signIn(e, t, i, r) {
          return (
            this._brokerLogger.logNormal(`Try to login with username: ${e}`),
            (this._loggedInManually = !0),
            this._brokerConnection.signIn(e, t, i, r)
          )
        }
        loggedInManually() {
          return this._loggedInManually
        }
        disconnect(e = !1) {
          try {
            return this._brokerConnection.disconnect(e)
          } catch (e) {
            J.logWarn('Failed to disconnect')
          }
        }
        currentAccount() {
          return this._brokerConnection.currentAccount
            ? this._brokerConnection.currentAccount()
            : ''
        }
        currentAccountType() {
          return this._brokerConnection.currentAccountType
            ? this._brokerConnection.currentAccountType()
            : void 0
        }
        checkUserHasLiveAccount() {
          return void 0 !== this._brokerConnection.checkUserHasLiveAccount
            ? this._brokerConnection.checkUserHasLiveAccount()
            : this.currentAccountType() === c.AccountType.Live
        }
        metainfo() {
          return this._brokerMetainfo
        }
        brokerPlan() {
          return this._brokerPlan
        }
        bro() {
          return this._brokerConnection
        }
        fireSubscription(e, t, i, r) {
          if (
            (void 0 === this._lastFireResult[t] &&
              (this._lastFireResult[t] = {
                Realtime: null,
                PL: null,
                Equity: null,
                DOM: null,
                IndividualPositionPL: null,
                PipValue: null,
                MarginAvailable: null,
                CryptoBalance: null,
              }),
            ((0, h.ensure)(this._lastFireResult[t])[e] = {
              data: i,
              time: Date.now(),
            }),
            void 0 === this._subscriptions[t])
          )
            return
          const s = (0, h.ensure)(this._subscriptions[t])
          ;(0, h.ensure)(s[e]).forEach((e) => e(t, i, r))
        }
        positions(e) {
          return this.config.supportPositions
            ? (this._makeSureBrokerIsConnected(),
              this._positions().then((t) =>
                t.filter((t) => void 0 === e || t.symbol === e),
              ))
            : Promise.resolve([])
        }
        disconnectWarningMessage() {
          return this._brokerConnection.disconnectWarningMessage
            ? this._brokerConnection.disconnectWarningMessage()
            : null
        }
        connectWarningMessage() {
          return this._brokerConnection.connectWarningMessage
            ? this._brokerConnection.connectWarningMessage()
            : null
        }
        individualPositions(e) {
          return (
            this._makeSureBrokerIsConnected(),
            (0, h.assert)(
              !!this.config.supportPositionNetting,
              'Broker doesn`t support individual positions',
            ),
            this._individualPositions().then((t) =>
              t.filter((t) => void 0 === e || t.symbol === e),
            )
          )
        }
        positionById(e) {
          return this._brokerConnection.positionById
            ? this._brokerConnection.positionById(e)
            : this.positions().then((t) => t.find((t) => t.id === e))
        }
        individualPositionById(e) {
          return (
            (0, h.assert)(
              !!this.config.supportPositionNetting,
              'Broker doesn`t support individual positions',
            ),
            this.individualPositions().then((t) => t.find((t) => t.id === e))
          )
        }
        orders(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._orders().then((t) =>
              t.filter((t) => void 0 === e || t.symbol === e),
            )
          )
        }
        ordersHistory() {
          return (
            this._makeSureBrokerIsConnected(),
            this.config.supportOrdersHistory &&
            this._brokerConnection.ordersHistory
              ? this._brokerConnection.ordersHistory()
              : Promise.resolve([])
          )
        }
        async executions(e) {
          return this.config.supportExecutions
            ? (this._makeSureBrokerIsConnected(),
              this._brokerConnection.executions(e))
            : []
        }
        async allExecutions() {
          return void 0 === this._brokerConnection.allExecutions
            ? []
            : this._brokerConnection.allExecutions()
        }
        orderById(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._brokerConnection
              .orders()
              .then((t) => t.find((t) => t.id === e))
          )
        }
        accountManagerInfo() {
          return this._brokerConnection.accountManagerInfo()
        }
        isTradable(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._brokerConnection
              .isTradable(e)
              .then(
                (t) => (
                  'object' != typeof t && (t = { tradable: t }),
                  t.tradable ||
                    void 0 !== t.reason ||
                    (t.reason = (0, k.makeNonTradableSymbolText)(
                      (0, S.htmlEscape)(e),
                      this._brokerMetainfo.title,
                    )),
                  t
                ),
              )
          )
        }
        formatter(e, t = !0) {
          return (
            this._makeSureBrokerIsConnected(),
            this._formattersCache[e] ||
              (this._formattersCache[e] =
                (this._brokerConnection.formatter &&
                  this._brokerConnection.formatter(e, t)) ||
                this._host.defaultFormatter(e, t)),
            (0, m.makeTimeLimited)(
              this._formattersCache[e],
              1e4,
              'formatter not received',
            )
          )
        }
        spreadFormatter(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._spreadFormattersCache[e] ||
              (this._spreadFormattersCache[e] =
                (this._brokerConnection.spreadFormatter &&
                  this._brokerConnection.spreadFormatter(e)) ||
                this._host.defaultFormatter(e, !1)),
            (0, m.makeTimeLimited)(
              this._spreadFormattersCache[e],
              1e4,
              'spreadFormatter not received',
            )
          )
        }
        quantityFormatter(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._quantityFormattersCache[e] ||
              (this._quantityFormattersCache[e] =
                (this._brokerConnection.quantityFormatter &&
                  this._brokerConnection.quantityFormatter(e)) ||
                this._host.quantityFormatter()),
            (0, m.makeTimeLimited)(
              this._quantityFormattersCache[e],
              1e4,
              'quantityFormatter not received',
            )
          )
        }
        async createInitialPreOrder(e) {
          const [t, i] = await Promise.all([
            this.getOrderDialogOptions(e.symbol),
            this.symbolInfo(e.symbol),
          ])
          return this._createInitialPreOrder(e, i, t)
        }
        async createPlaceOrderContext(e, t, i = !0) {
          var r
          const s = this._placeOrderContextWithMetaInfo
          if (
            void 0 !== s &&
            s.context.data().symbol === e.symbol &&
            s.isValidationEnabled === i
          )
            return await s.context.setData(e, t), s.context
          null === (r = this._placeOrderContextWithMetaInfo) ||
            void 0 === r ||
            r.context.destroy()
          const o = await this._createPlaceOrderContext(e, t, i)
          return (
            s === this._placeOrderContextWithMetaInfo &&
              (this._placeOrderContextWithMetaInfo = {
                context: o,
                isValidationEnabled: i,
              }),
            o
          )
        }
        async createEditOrderContext(e, t, i = !0) {
          const r = this._editOrderContextWithMetaInfo
          if (
            void 0 !== r &&
            r.context.data().id === e.id &&
            r.isValidationEnabled === i
          )
            return await r.context.setData(e, t), r.context
          const s = await this._createEditOrderContext(e, t, i)
          return (
            r === this._editOrderContextWithMetaInfo &&
              (this._editOrderContextWithMetaInfo = {
                context: s,
                isValidationEnabled: i,
              }),
            s
          )
        }
        placeOrder(e, t) {
          return this._placeOrder(e, t)
        }
        previewOrder(e) {
          return this._previewOrder(e)
        }
        modifyOrder(e, t) {
          return this._modifyOrder(e, t)
        }
        cancelOrder(e) {
          return (
            ee(e),
            this._makeSureBrokerIsConnected(),
            this.processErrors(
              this._brokerConnection.cancelOrder(e),
              !0,
              r.t(null, void 0, i(915926)),
            )
          )
        }
        cancelOrders(e, t, s) {
          return (
            this._makeSureBrokerIsConnected(),
            this.processErrors(
              this._brokerConnection.cancelOrders(e, t, s),
              !0,
              r.t(null, void 0, i(305140)),
            )
          )
        }
        async closePosition(e, t) {
          let i
          ee(e),
            this._makeSureBrokerIsConnected(),
            (0, h.assert)(
              void 0 === t || !!this.config.supportPartialClosePosition,
              'Broker doesn`t support partial position closing',
            )
          const r = new Promise(async (r, s) => {
            try {
              const s = await this._positionCopyById(e)
              ;(i = (e) => {
                void 0 !== s &&
                  e.id === s.id &&
                  e.symbol === s.symbol &&
                  e.qty !== s.qty &&
                  (this.positionUpdate.unsubscribe(this, i), r(!0))
              }),
                this.positionUpdate.subscribe(this, i),
                await this._closePosition(e, t)
            } catch (e) {
              s(e)
            }
          })
          return (0, m.makeTimeLimited)(
            r,
            3e4,
            'Position closing timeout',
          ).catch(
            (e) => (
              this._brokerLogger.logError(
                `${X}: ${(0, k.getLoggerMessage)(e)}`,
              ),
              this.positionUpdate.unsubscribe(this, i),
              !1
            ),
          )
        }
        async closeIndividualPosition(e, t) {
          var s
          ee(e),
            this._makeSureBrokerIsConnected(),
            (0, h.assert)(
              !!this.config.supportPositionNetting,
              'Broker doesn`t support individual positions',
            ),
            (0, h.assert)(
              void 0 === t ||
                (null !==
                  (s = this.config.supportPartialCloseIndividualPosition) &&
                  void 0 !== s &&
                  s),
              'Broker doesn`t support partial individual position closing',
            )
          const o = (0, h.ensureDefined)(await this.individualPositionById(e))
          if (0 === o.qty)
            return (
              this._host.showNotification(
                r.t(null, void 0, i(791401)),
                r.t(null, void 0, i(715842)),
                0,
              ),
              !1
            )
          if (void 0 === t || t <= Math.abs(o.qty)) {
            if (this._brokerConnection.closeIndividualPosition) {
              const i = B(null != t ? t : Math.abs(o.qty), o)
              return this.processErrors(
                this._brokerConnection.closeIndividualPosition(e, t),
                !0,
                X,
                () =>
                  (0, h.ensureNotNull)(this._tradingStat).trackOrderPlaced(i),
              )
            }
            throw new Error('Method closeIndividualPosition is not implemented')
          }
          return (
            this._host.showNotification(
              r.t(null, void 0, i(791401)),
              r.t(null, void 0, i(365389)),
              0,
            ),
            !1
          )
        }
        reversePosition(e) {
          if (
            (ee(e),
            this._makeSureBrokerIsConnected(),
            this.config.supportMultiposition &&
              !this.config.supportNativeReversePosition)
          )
            throw new Error('Cannot reverse position on multiposition account')
          let t
          const i = new Promise(async (i, r) => {
            try {
              const r = await this._positionCopyById(e)
              ;(t = (e) => {
                void 0 !== r &&
                  e.symbol === r.symbol &&
                  e.side !== r.side &&
                  (this.positionUpdate.unsubscribe(this, t), i(!0))
              }),
                this.positionUpdate.subscribe(this, t),
                await this._reversePosition(e)
            } catch (e) {
              r(e)
            }
          })
          return (0, m.makeTimeLimited)(
            i,
            3e4,
            'Position reversing timeout',
          ).catch(
            (e) => (
              this._brokerLogger.logError(
                `${Y}: ${(0, k.getLoggerMessage)(e)}`,
              ),
              this.positionUpdate.unsubscribe(this, t),
              !1
            ),
          )
        }
        editPositionBrackets(e, t, s) {
          if (
            (this._makeSureBrokerIsConnected(),
            this._brokerConnection.editPositionBrackets)
          )
            return this.processErrors(
              this._brokerConnection.editPositionBrackets(e, t, s),
              !0,
              r.t(null, void 0, i(140766)),
            )
          throw new Error('Method editPositionBrackets is not implemented')
        }
        editIndividualPositionBrackets(e, t) {
          if (
            (this._makeSureBrokerIsConnected(),
            (0, h.assert)(
              !!this.config.supportIndividualPositionBrackets,
              'Broker doesn`t support brackets on individual positions',
            ),
            this._brokerConnection.editIndividualPositionBrackets)
          )
            return this.processErrors(
              this._brokerConnection.editIndividualPositionBrackets(e, t),
              !0,
              r.t(null, void 0, i(140766)),
            )
          throw new Error(
            'Method editIndividualPositionBrackets is not implemented',
          )
        }
        async subscribeRealtime(e, t) {
          this._makeSureBrokerIsConnected()
          const i = { symbol: e, listener: t, provider: 0 }
          this._realtimeSubscriptionState.push(i)
          const r = await this.symbolInfo(e),
            s = this._realtimeSubscriptionState.findIndex(
              (i) => i.symbol === e && i.listener === t,
            )
          if (-1 !== s)
            return void 0 !== r.hasQuotes && !1 === r.hasQuotes
              ? ((this._realtimeSubscriptionState[s].provider = 1),
                (0, h.ensure)(this._brokerRealtimeAdapter).subscribeRealtime(
                  e,
                  t,
                ))
              : ((this._realtimeSubscriptionState[s].provider = 2),
                this._addSubscription('Realtime', e, t))
        }
        async quotesSnapshot(e) {
          let t, i
          const r = (e, s) => {
              ;(i = s),
                (s.ask || s.bid) &&
                  (this.unsubscribeRealtime(e, r), null == t || t(s))
            },
            s = new Promise((i) => {
              ;(t = i), this.subscribeRealtime(e, r)
            })
          try {
            return await (0, m.makeTimeLimited)(
              s,
              1e4,
              'quotesSnapshot not received',
            )
          } catch (t) {
            if ((this.unsubscribeRealtime(e, r), void 0 !== i)) return i
            throw t
          }
        }
        subscribeDOM(e, t) {
          return (
            this._makeSureBrokerIsConnected(),
            this._addSubscription('DOM', e, t)
          )
        }
        subscribePipValue(e, t) {
          return (
            this._makeSureBrokerIsConnected(),
            this._addSubscription('PipValue', e, t)
          )
        }
        subscribePL(e, t) {
          this._makeSureBrokerIsConnected(), this._addSubscription('PL', e, t)
        }
        subscribeIndividualPositionPL(e, t) {
          return (
            this._makeSureBrokerIsConnected(),
            this._addSubscription('IndividualPositionPL', e, t)
          )
        }
        subscribeCryptoBalance(e, t) {
          return (
            this._makeSureBrokerIsConnected(),
            this._addSubscription('CryptoBalance', e, t)
          )
        }
        subscribeEquity(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._addSubscription('Equity', 'Equity', e)
          )
        }
        subscribeMarginAvailable(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._addSubscription('MarginAvailable', 'MarginAvailable', e)
          )
        }
        unsubscribeRealtime(e, t) {
          const i = this._realtimeSubscriptionState.findIndex(
            (i) => i.symbol === e && i.listener === t,
          )
          ;-1 !== i &&
            (1 === this._realtimeSubscriptionState[i].provider
              ? (0, h.ensure)(this._brokerRealtimeAdapter).unsubscribeRealtime(
                  e,
                  t,
                )
              : this._removeSubscription('Realtime', e, t),
            this._realtimeSubscriptionState.splice(i, 1))
        }
        unsubscribeDOM(e, t) {
          this._removeSubscription('DOM', e, t)
        }
        unsubscribePipValue(e, t) {
          this._removeSubscription('PipValue', e, t)
        }
        unsubscribePL(e, t) {
          this._removeSubscription('PL', e, t)
        }
        unsubscribeIndividualPositionPL(e, t) {
          this._removeSubscription('IndividualPositionPL', e, t)
        }
        unsubscribeCryptoBalance(e, t) {
          this._removeSubscription('CryptoBalance', e, t)
        }
        unsubscribeEquity(e) {
          this._removeSubscription('Equity', 'Equity', e)
        }
        unsubscribeMarginAvailable(e) {
          this._removeSubscription('MarginAvailable', 'MarginAvailable', e)
        }
        async accountMetainfo() {
          const e = await this.accountsMetainfo(),
            t = this.currentAccount(),
            i = e.find((e) => e.id === t)
          if (void 0 === i) throw new Error('accountMetainfo not received')
          return i
        }
        accountsMetainfo() {
          return (0, m.makeTimeLimited)(
            this._brokerConnection.accountsMetainfo(),
            1e4,
            'accountsMetainfo not received',
          )
        }
        setCurrentAccount(e) {
          if (void 0 === this._brokerConnection.setCurrentAccount)
            throw new Error(
              `${this._brokerMetainfo.title} doesn't support sub-accounts`,
            )
          this._brokerConnection.setCurrentAccount(e)
        }
        symbolInfo(e) {
          return (0, m.makeTimeLimited)(
            this._brokerConnection.symbolInfo(e),
            1e4,
            'symbolInfo not received',
          )
        }
        async getPositionCurrency(e) {
          try {
            const t = await this._brokerConnection.symbolInfo(e)
            if (
              this._brokerMetainfo.configFlags.positionPLInInstrumentCurrency &&
              void 0 !== t.currency
            )
              return t.currency
            const i = await this.accountMetainfo()
            return (0, w.getCurrency)(i, !0)
          } catch (e) {
            return void J.logError(e)
          }
        }
        sessionId() {
          return this._sessionId
        }
        bugReportInfo() {
          function e(e) {
            return JSON.parse(JSON.stringify(e))
          }
          function t(e) {
            if ('object' != typeof e) return e
            if ((0, d.isArray)(e)) return e.map(t)
            const i = {}
            for (const t in e) 'object' != typeof e[t] && (i[t] = e[t])
            return i
          }
          return Promise.all([
            this.orders(),
            this.positions(),
            this.config.supportPositionNetting
              ? this.individualPositions()
              : Promise.resolve([]),
          ]).then((i) => ({
            activeBroker: this.metainfo().title,
            orders: t(e(i[0])),
            positions: t(e(i[1])),
            individualPositions: t(e(i[2])),
            silentOrdersPlacement: this._host.silentOrdersPlacement().value(),
            floatingPanel: (0, h.ensureNotNull)(
              this._host.sellBuyButtonsVisibility(),
            ).value(),
            account: this.currentAccount(),
            accountType: this.currentAccountType(),
            lastUpdates: this._lastFireResult,
            time: Date.now(),
            brokerSpecific: this._brokerConnection.bugReportInfo
              ? this._brokerConnection.bugReportInfo()
              : null,
            sessionId: this._sessionId,
          }))
        }
        processErrors(e, t, i, r) {
          if (!(0, d.isPromise)(e))
            throw new Error(
              'Broker incorrectly implements API, should return Promise',
            )
          return e
            .then((e) => r && r(e))
            .then((e) => 'boolean' != typeof e || e)
            .catch(
              (e) => (
                (0, o.isAbortError)((0, k.getErrorCauses)(e)[0]) ||
                  (t && l.enabled('trading_notifications')
                    ? this._showErrorNotification(e, i)
                    : J.logWarn(e)),
                Promise.resolve(!1)
              ),
            )
            .then((e) => (this.tradingOperationFinished.fire(e), e))
        }
        setDurations(e) {
          this._brokerMetainfo.durations = e.slice()
        }
        setSymbolSearchId(e) {
          this._brokerMetainfo.backendBrokerName = e
        }
        getRealtimeDataCheckParams() {
          return this._brokerConnection.getRealtimeDataCheckParams
            ? this._brokerConnection.getRealtimeDataCheckParams()
            : {}
        }
        getVerifyLiveAccountParams() {
          if (void 0 === this._brokerConnection.getVerifyLiveAccountParams)
            throw new Error(
              `Method getVerifyLiveAccountParams for broker ${this._brokerMetainfo.id} is not implemented`,
            )
          return this._brokerConnection.getVerifyLiveAccountParams()
        }
        unhideSymbolSearchGroups() {
          return this._brokerConnection.unhideSymbolSearchGroups
            ? this._brokerConnection.unhideSymbolSearchGroups()
            : []
        }
        destroy() {
          void 0 !== this._brokerConnection.destroy &&
            this._brokerConnection.destroy()
        }
        currentBroker() {
          return this._brokerMetainfo.id
        }
        _showErrorNotification(e, t) {
          let s = ''
          'string' == typeof e
            ? (s = e)
            : 'object' == typeof e &&
              null !== e &&
              'message' in e &&
              'string' == typeof e.message &&
              (s = (0, S.removeTags)(e.message)),
            0 !== s.length &&
              (s =
                (0, w.addAsciiDotIfTextDoesNotEndWithSentenceEndingMark)(s) +
                ' '),
            (s += r.t(null, void 0, i(352303))),
            this._host.showNotification(t || '', s, 0)
        }
        _makeContextErrorHandler(e) {
          return l.enabled('trading_notifications')
            ? (t) => this._showErrorNotification(t, e)
            : (e) => J.logWarn((0, k.getErrorMessage)(e))
        }
        async _createEditOrderContext(e, t, s = !0) {
          const o = new G({
            orderData: e,
            source: t,
            callbacks: {
              modifyOrder: this._modifyOrder.bind(this),
              metainfo: this.metainfo.bind(this),
              symbolInfo: this.symbolInfo.bind(this),
              orderById: this.orderById.bind(this),
              previewOrder: this._previewOrder.bind(this),
              handleError: this._makeContextErrorHandler(
                r.t(null, void 0, i(54746)),
              ),
            },
          })
          return await o.onReady(), o
        }
        async _createPlaceOrderContext(e, t, s = !0) {
          const [o, l, c] = await Promise.all([
              this.symbolInfo(e.symbol),
              this.formatter(e.symbol),
              this.getOrderDialogOptions(e.symbol),
            ]),
            { configFlags: d } = this.metainfo(),
            u =
              d.supportBalances && o.baseCurrency
                ? this._cryptoBalanceObservable(o.baseCurrency)
                : (0, n.of)(null),
            h =
              d.supportBalances && o.quoteCurrency
                ? this._cryptoBalanceObservable(o.quoteCurrency)
                : (0, n.of)(null),
            p = (0, Z.extractTakeProfitValidationRules)(this, e.symbol),
            g = (0, Z.extractStopLossValidationRules)(this, e.symbol),
            m = (0, a.fromEventPattern)(
              (t) => this.subscribeRealtime(e.symbol, t),
              (t) => this.unsubscribeRealtime(e.symbol, t),
              (e, t) => t,
            ),
            _ = new Q({
              orderData: e,
              source: t,
              instrumentInfo: o,
              quotes$: m,
              configFlags: d,
              formatter: l,
              isValidationEnabled: s,
              orderDialogOptions: c,
              tpValidationRules: p,
              slValidationRules: g,
              baseCurrencyCryptoBalance$: u,
              quoteCurrencyCryptoBalance$: h,
              callbacks: {
                createInitialPreOrder: async (e) =>
                  this._createInitialPreOrder(e, o, c),
                placeOrder: (e, t) => this._placeOrder(e, t),
                previewOrder: (e) => this._previewOrder(e),
                handleError: this._makeContextErrorHandler(
                  r.t(null, void 0, i(842180)),
                ),
              },
            })
          return await _.onReady(), _
        }
        _createInitialPreOrder(e, t, i) {
          var r, s, o
          if (void 0 === e.duration) {
            const { durations: i } = this.metainfo(),
              n = (0, w.getOrderDuration)({
                orderDuration: void 0,
                orderType: e.type,
                savedDuration:
                  null !==
                    (o =
                      null ===
                        (s =
                          null === (r = this._getTradingSettingsStorage) ||
                          void 0 === r
                            ? void 0
                            : r.call(this)) || void 0 === s
                        ? void 0
                        : s.duration(e.symbol, e.type)) && void 0 !== o
                    ? o
                    : null,
                orderDurations: i,
                symbolDurations: t.allowedDurations,
              })
            null !== n && (e.duration = n)
          }
          if (void 0 === e.customFields) {
            const t = this._getSavedCustomFields(e.symbol, e.type, i)
            void 0 !== t && (e.customFields = t)
          }
          return e
        }
        _getSavedCustomFields(e, t, i) {
          var r, s
          const o =
            null !==
              (s =
                null === (r = this._getTradingSettingsStorage) || void 0 === r
                  ? void 0
                  : r.call(this)) && void 0 !== s
              ? s
              : void 0
          if (
            void 0 === o ||
            void 0 === (null == i ? void 0 : i.customFields) ||
            0 === i.customFields.length
          )
            return
          const n = i.customFields.map((e) => e.id),
            a = o.customFields(e, t, n),
            l = (0, w.adjustSavedCustomFieldsValues)(a, i)
          return 0 !== Object.keys(l).length ? l : void 0
        }
        _placeOrder(e, t) {
          return (
            this._makeSureBrokerIsConnected(),
            this.processErrors(
              this._brokerConnection.placeOrder(e, t),
              !0,
              r.t(null, void 0, i(842180)),
              (t) => {
                ;(0, h.ensureNotNull)(this._tradingStat).trackOrderPlaced({
                  ...e,
                  id: t.orderId,
                }),
                  this._host.trackEvent(
                    '',
                    'SilentMode',
                    this._host.silentOrdersPlacement().value() ? 'On' : 'Off',
                  )
              },
            )
          )
        }
        async _modifyOrder(e, t) {
          this._makeSureBrokerIsConnected()
          const s = new Set((await this._orders()).map(({ id: e }) => e))
          s.delete(e.id)
          return (
            (await this.processErrors(
              this._brokerConnection.modifyOrder(e, t),
              !0,
              r.t(null, void 0, i(54746)),
              () =>
                (0, h.ensureNotNull)(this._tradingStat).trackOrderModified(e),
            )) && this._waitForOrderModification(e, s)
          )
        }
        _previewOrder(e) {
          if (!this._brokerConnection.previewOrder)
            throw new Error('Order preview is not supported')
          return this._brokerConnection.previewOrder(e)
        }
        _initializeConnectProtection() {
          let e = null
          this.connectionStatusUpdate.subscribe(null, (t) => {
            if ((e && (clearTimeout(e), (e = null)), 2 === t)) {
              const t = (0, w.isOAuthAuthType)(this.config.authorizationType)
                ? 3e5
                : 6e4
              e = setTimeout(() => {
                this._host.selectBroker(),
                  this._host.showNotification(
                    r.t(null, void 0, i(170891)),
                    r.t(null, void 0, i(247956)),
                  )
              }, t)
            }
          })
        }
        _fakeSubscribeDOM(e) {
          ;(this._fakeDOMSubscriptions[e] = (e, t) => {
            const i = t.ask || t.trade,
              r = t.bid || t.trade,
              s = {
                snapshot: !0,
                asks: i ? [{ price: i, volume: t.ask_size || 1 / 0 }] : [],
                bids: r ? [{ price: r, volume: t.bid_size || 1 / 0 }] : [],
              }
            this._host.domUpdate(e, s)
          }),
            this.subscribeRealtime(e, this._fakeDOMSubscriptions[e])
        }
        _fakeUnsubscribeDOM(e) {
          this.unsubscribeRealtime(e, this._fakeDOMSubscriptions[e])
        }
        _isMaintenance() {
          return isFeatureEnabled(
            (0, w.makeMaintananceFeatureToggleName)(this._brokerMetainfo.id),
          )
        }
        _isBrokerSideMaintenance() {
          return isFeatureEnabled(
            (0, w.makeBrokerSideMaintananceFeatureToggleName)(
              this._brokerMetainfo.id,
            ),
          )
        }
        async _positionCopyById(e) {
          const t = await this.positionById(e)
          return void 0 !== t ? (0, s.default)(t) : void 0
        }
        _patchBrokerSubscribeUnsubscribeDOMMethods() {
          const e = !this._brokerMetainfo.configFlags.supportLevel2Data
          ;(this._brokerConnection.subscribeDOM = e
            ? (e) => {
                this._fakeSubscribeDOM(e)
              }
            : this._originalDOMSubscriptionMethods.subscribeDOM),
            (this._brokerConnection.unsubscribeDOM = e
              ? (e) => {
                  this._fakeUnsubscribeDOM(e)
                }
              : this._originalDOMSubscriptionMethods.unsubscribeDOM)
        }
        _patchMetainfo(e) {
          const t = (0, P.deepCopy)(e)
          return (
            (t.configFlags.supportNativeReversePosition =
              !this.config.supportMultiposition ||
              this.config.supportNativeReversePosition),
            (t.configFlags.supportClosePosition = !0),
            (t.configFlags.supportPLUpdate = !0),
            t
          )
        }
        _addSubscription(e, t, i) {
          this._pendingSubscriptions.push({
            brokerMethodName: e,
            symbol: t,
            listener: i,
          })
          const r = this._lastFireResult[t]
          if (
            (void 0 !== r &&
              void 0 !== r[e] &&
              null !== r[e] &&
              i(t, r[e].data),
            !this._removePendingSubscription({
              brokerMethodName: e,
              symbol: t,
              listener: i,
            }))
          )
            return
          void 0 === this._subscriptions[t] &&
            (this._subscriptions[t] = {
              Realtime: [],
              PL: [],
              Equity: [],
              DOM: [],
              IndividualPositionPL: [],
              PipValue: [],
              MarginAvailable: [],
              CryptoBalance: [],
            })
          const s = (0, h.ensure)(this._subscriptions[t]),
            o = s[e].length > 0
          if (
            (s[e].push(i), !o && (s[e].length > 0 || 'CryptoBalance' === e))
          ) {
            const i = 'subscribe' + e
            this._brokerConnection[i] && this._brokerConnection[i](t)
          }
        }
        _removePendingSubscription(e) {
          const t = this._pendingSubscriptions.findIndex(
            (t) =>
              t.symbol === e.symbol &&
              t.brokerMethodName === e.brokerMethodName &&
              t.listener === e.listener,
          )
          return -1 !== t && (this._pendingSubscriptions.splice(t, 1), !0)
        }
        _removeSubscription(e, t, i) {
          if (
            this._removePendingSubscription({
              brokerMethodName: e,
              symbol: t,
              listener: i,
            })
          )
            return
          if (void 0 === this._subscriptions[t]) return
          const r = (0, h.ensure)(this._subscriptions[t]),
            s = r[e].indexOf(i)
          if ((s > -1 && r[e].splice(s, 1), 0 === r[e].length)) {
            const i = 'unsubscribe' + e
            this._brokerConnection[i] && this._brokerConnection[i](t)
          }
        }
        _positions() {
          return this._positionsCache
            ? this._positionsCache.getObjects()
            : Promise.resolve([])
        }
        _individualPositions() {
          return this._individualPositionsCache
            ? this._individualPositionsCache.getObjects()
            : Promise.resolve([])
        }
        _orders() {
          return this._ordersCache.getObjects()
        }
        _makeSureBrokerIsConnected() {
          ;(0, h.assert)(
            1 === this.connectionStatus(),
            'Broker is not connected',
          )
        }
        _placeReversePositionOrder(e) {
          const t = B(2 * e.qty, e)
          return this._placeOrder(t)
        }
        async _closePosition(e, t) {
          const s = (0, h.ensureDefined)(await this.positionById(e))
          if (!(0, w.checkIsExistingPosition)(s)) {
            const e = r.t(null, void 0, i(715842))
            throw (this._host.showNotification(X, e, 0), new Error(e))
          }
          if (!(void 0 === t || t <= Math.abs(s.qty))) {
            const e = r.t(null, void 0, i(365389))
            throw (this._host.showNotification(X, e, 0), new Error(e))
          }
          {
            const i = B(null != t ? t : Math.abs(s.qty), s)
            if (
              this.config.supportClosePosition &&
              this._brokerConnection.closePosition
            ) {
              if (
                !(await this.processErrors(
                  this._brokerConnection.closePosition(e, t),
                  !0,
                  X,
                  () =>
                    (0, h.ensureNotNull)(this._tradingStat).trackOrderPlaced(i),
                ))
              )
                throw new Error(X)
            } else {
              if (
                !(await this.processErrors(
                  this._brokerConnection.placeOrder(i),
                  !0,
                  X,
                  () =>
                    (0, h.ensureNotNull)(this._tradingStat).trackOrderPlaced(i),
                ))
              )
                throw new Error(X)
            }
          }
        }
        async _reversePosition(e) {
          const t = (0, h.ensureDefined)(await this.positionById(e))
          if (0 === t.qty) {
            const e = r.t(null, void 0, i(726500))
            throw (this._host.showNotification(Y, e, 0), new Error(e))
          }
          this.config.supportNativeReversePosition &&
          this._brokerConnection.reversePosition
            ? await this.processErrors(
                this._brokerConnection.reversePosition(e),
                !0,
                Y,
              )
            : await this.processErrors(
                this._placeReversePositionOrder(t),
                !0,
                Y,
                () =>
                  (0, h.ensureNotNull)(this._tradingStat).trackOrderPlaced(),
              )
        }
        async _waitForOrderModification(e, t) {
          return new Promise(async (i) => {
            const r = () => {
                i(!0), o(), clearTimeout(n)
              },
              s = (t) => {
                this._areOrdersEqual(t, e) && r()
              },
              o = () => this.orderUpdate.unsubscribe(this, s),
              n = setTimeout(() => {
                i(!1),
                  this._brokerLogger.logError(
                    'Failed to modify order: timeout waiting for new order',
                  ),
                  o()
              }, 3e4)
            this.orderUpdate.subscribe(this, s)
            for (const i of await this._orders())
              if (!t.has(i.id) && this._areOrdersEqual(e, i)) return void r()
          })
        }
        _areOrdersEqual(e, t) {
          const { checkBracketsAfterOrderModification: i } =
            this._brokerMetainfo.configFlags
          return (
            ((e, t) =>
              e.type === t.type &&
              e.qty === t.qty &&
              e.limitPrice === t.limitPrice &&
              e.stopPrice === t.stopPrice)(e, t) &&
            (!i ||
              ((e, t) =>
                e.stopLoss === t.stopLoss &&
                e.takeProfit === t.takeProfit &&
                e.trailingStopPips === t.trailingStopPips)(e, t))
          )
        }
        _updateConfigDependentProperties() {
          var e, t
          const { supportPositions: i } = this._brokerMetainfo.configFlags
          i
            ? (null === (e = this._fakePositionUpdateDelegate) ||
                void 0 === e ||
                e.destroy(),
              (this._fakePositionUpdateDelegate = null))
            : (null !== (t = this._fakePositionUpdateDelegate) &&
                void 0 !== t) ||
              (this._fakePositionUpdateDelegate = new u.Delegate())
        }
        _cryptoBalanceObservable(e) {
          return (0, a.fromEventPattern)(
            (t) => this.subscribeCryptoBalance(e, t),
            (t) => this.unsubscribeCryptoBalance(e, t),
            (e, t) => t,
          )
        }
      }
      var ie = i(870122),
        re = i.n(ie),
        se = i(650802),
        oe = i(673317),
        ne = i(424030),
        ae = i(814127),
        le = i(382563),
        ce = i(918114),
        de = i(153055),
        ue = i(156115),
        he = i(252546),
        pe = i(120283),
        ge = i(314996),
        me = i(66786)
      class _e {
        constructor(e, t, i, r) {
          ;(this._lastPL = 0),
            (this._isActive = !1),
            (this._realtimeUpdate = (e, t) => {
              ;(this._realtimeData = t), this._updatePL()
            }),
            (this._symbol = e.symbol),
            (this._adapter = i),
            (this._onPlUpdate = t),
            (this._side = e.side),
            (this._qty = e.qty),
            (this._avgPrice = e.avgPrice || e.price),
            (this._instrumentInfo = r),
            this.positionUpdate(e)
        }
        positionUpdate(e) {
          ;(this._avgPrice = e.avgPrice || e.price),
            (this._qty = e.qty),
            (this._side = e.side),
            this._updatePL()
        }
        lastPL() {
          return this._lastPL
        }
        start() {
          this._isActive ||
            (this._adapter.subscribeRealtime(
              this._symbol,
              this._realtimeUpdate,
            ),
            (this._isActive = !0))
        }
        stop() {
          this._isActive &&
            (this._adapter.unsubscribeRealtime(
              this._symbol,
              this._realtimeUpdate,
            ),
            (this._isActive = !1))
        }
        _updatePL() {
          var e
          if (
            !this._realtimeData ||
            void 0 === this._realtimeData.bid ||
            void 0 === this._realtimeData.ask
          )
            return
          const t = Number(
            new N.Big(
              1 === this._side
                ? this._realtimeData.bid
                : this._realtimeData.ask,
            )
              .minus(Math.abs(this._avgPrice))
              .mul(1 === this._side ? 1 : -1)
              .mul(this._qty)
              .mul(
                null !== (e = this._instrumentInfo.lotSize) && void 0 !== e
                  ? e
                  : 1,
              )
              .div(this._instrumentInfo.pipSize)
              .mul(this._instrumentInfo.pipValue),
          )
          ;(this._lastPL = t), this._onPlUpdate(t)
        }
      }
      new Set(['type', 'typespecs', 'pricescale', 'minmov', 'fractional'])
      function be(e, t) {
        return (0, le.getQuoteSessionInstance)('full').snapshot(e)
      }
      function ve(e) {
        return 'error' === e.status
      }
      class ye {
        constructor(e, t, i, r) {
          var s
          ;(this._setDefaultDropdownActionsBound =
            this._setDefaultDropdownActions.bind(this)),
            (this._qtyChangedSubscriptions = new Map()),
            (this.serverLogger = () => this._serverLogger),
            (this.orderPartialUpdate = (e, t) => {
              this._adapter.onOrderPartialUpdate(e, t)
            }),
            (this.positionPartialUpdate = (e, t) => {
              this._adapter.onPositionPartialUpdate(e, t)
            }),
            (this.individualPositionPartialUpdate = (e, t) => {
              this._adapter.onIndividualPositionPartialUpdate(e, t)
            }),
            (this.createMapperAsync = (e, t) => ({
              tvToBroker: async (e) => e,
              brokerToTv: async (e) => e,
            })),
            (this.createMapperSync = (e, t) => {
              let i = null
              {
                const e = Promise.resolve()
                i = {
                  ready: () => e,
                  tvToBroker: (e) => e,
                  brokerToTv: (e) => e,
                }
              }
              return i
            }),
            (this._trading = e),
            (this._metainfo = t),
            (this._serverLogger =
              null !== i ? this._makeServerLoggerWithFilledInfo(i) : null),
            (this._setDefaultDropdownActionsBound =
              this._setDefaultDropdownActions.bind(this)),
            (this._defaultDropdownActions = !0),
            (this._credentialsStorage = r),
            this._setDefaultDropdownActions(),
            null !== this._trading &&
              (null === (s = this.sellBuyButtonsVisibility()) ||
                void 0 === s ||
                s.subscribe(this._setDefaultDropdownActionsBound),
              (0, h.ensureNotNull)(this.orderPanelVisibility()).subscribe(
                this._setDefaultDropdownActionsBound,
              ),
              (0, h.ensureNotNull)(this.domPanelVisibility()).subscribe(
                this._setDefaultDropdownActionsBound,
              ))
        }
        createPLEmitter(e, t, i) {
          return new _e(e, t, this._adapter, i)
        }
        getLogger() {
          return (0, g.getLogger)('Trading.' + this._metainfo.id)
        }
        translate(e) {
          return e
        }
        setBrokerConnectionAdapter(e) {
          this._adapter = e
        }
        patchConfig(e) {
          this._adapter.patchConfig(e)
        }
        showOrderDialog(e, t) {
          return (0, h.ensureNotNull)(this._trading)
            .orderViewController()
            .showOrderView({ order: e, focus: t })
        }
        showPositionBracketsDialog(e, t, i) {
          return (0, h.ensureNotNull)(this._trading)
            .orderViewController()
            .showPositionView(e, t, i)
        }
        showCancelOrderDialog(e, t) {
          return pe.ConfirmOrderCancelDialog.get()
            .open(e)
            .then((e) => {
              e &&
                this._adapter.processErrors(
                  t(),
                  !0,
                  r.t(null, void 0, i(915926)),
                )
            })
        }
        showCancelMultipleOrdersDialog(e, t, s, o) {
          return pe.ConfirmOrderCancelDialog.get()
            .multiple(e, t, s)
            .then((e) => {
              e &&
                this._adapter.processErrors(
                  o(),
                  !0,
                  r.t(null, void 0, i(305140)),
                )
            })
        }
        showCancelBracketsDialog(e, t) {
          return ge.ConfirmBracketsCancelDialog.get()
            .open(e)
            .then((e) => {
              e &&
                this._adapter.processErrors(
                  t(),
                  !0,
                  r.t(null, void 0, i(951099)),
                )
            })
        }
        showCancelMultipleBracketsDialog(e, t) {
          return ge.ConfirmBracketsCancelDialog.get()
            .multiple(e)
            .then((e) => {
              e &&
                this._adapter.processErrors(
                  t(),
                  !0,
                  r.t(null, void 0, i(951099)),
                )
            })
        }
        showReversePositionDialog(e, t) {
          return (0, me.reversePositionDialog)({
            positionId: e,
            showErrorNotification: (0, h.ensureNotNull)(this._trading)
              .showErrorNotification,
            handler: t,
          })
        }
        showMessageDialog(e, t, i = !1) {
          i
            ? (0, de.showWarning)({ title: e, html: t })
            : (0, de.showWarning)({ title: e, text: t })
        }
        showConfirmDialog(e, t, i, r, s) {
          return (0, ue.showConfirmDialog)({
            title: e,
            content: t,
            mainButtonText: i,
            cancelButtonText: r,
            showDisableConfirmationsCheckbox: s,
          })
        }
        showSimpleConfirmDialog(e, t, i, r, s) {
          return (0, he.showSimpleConfirmDialog)({
            title: e,
            text: Array.isArray(t) ? t.join(' ') : t,
            mainButtonText: i,
            mainButtonIntent: 'primary',
            cancelButtonText: r,
            showDisableConfirmationsCheckbox: s,
          })
        }
        showSimpleConfirmDialogAndRespectAbort(e, t, i, r, s, o) {
          return (0, he.showSimpleConfirmDialog)({
            title: e,
            text: Array.isArray(t) ? t.join(' ') : t,
            abortSignal: i,
            mainButtonText: r,
            mainButtonIntent: 'primary',
            cancelButtonText: s,
            showDisableConfirmationsCheckbox: o,
          })
        }
        setDurations(e) {
          this._adapter.setDurations(e)
        }
        setSymbolSearchId(e) {
          this._adapter.setSymbolSearchId(e)
        }
        activateBottomWidget() {
          return null !== this._trading
            ? this._trading.toggleTradingWidget()
            : Promise.reject(
                'Activate bottom widget failed: trading is not defined',
              )
        }
        bottomWidgetMode() {
          if (null === this._trading)
            throw new Error(
              'Unable to provide bottom widget mode: trading is not defined',
            )
          return this._trading.bottomWidgetBarMode()
        }
        trackEvent(e, t, i) {
          null !== this._trading && this._trading.trackEvent(e, t, i)
        }
        defaultFormatter(e, t) {
          return (0, le.getQuoteSessionInstance)('simple').formatter(e, t)
        }
        numericFormatter(e) {
          return Promise.resolve(new ne.NumericFormatter(e))
        }
        quantityFormatter(e) {
          return Promise.resolve(new ae.QuantityFormatter(e))
        }
        selectBroker() {
          null !== this._trading && this._trading.selectBroker(null)
        }
        showTradingProperties() {
          null !== this._trading && this._trading.showTradingProperties()
        }
        async getSymbolTypespecs(e) {
          var t
          const i = await be(e)
          return 'values' in i
            ? ve(i) || void 0 === i.values.typespecs
              ? []
              : i.values.typespecs
            : null !== (t = i.typespecs) && void 0 !== t
              ? t
              : []
        }
        async getSymbolType(e) {
          var t
          const i = await be(e)
          return 'values' in i
            ? ve(i)
              ? 'undefined'
              : i.values.type
            : null !== (t = i.type) && void 0 !== t
              ? t
              : 'undefined'
        }
        async getSymbolMinTick(e) {
          const t = await be(e)
          return 'values' in t
            ? ve(t) ||
              void 0 === t.values.minmov ||
              void 0 === t.values.pricescale
              ? 1
              : (0, N.Big)(t.values.minmov).div(t.values.pricescale).toNumber()
            : (0, N.Big)(t.minmov).div(t.pricescale).toNumber()
        }
        silentOrdersPlacement() {
          return (0, h.ensureNotNull)(this._trading).noConfirmEnabled
        }
        sellBuyButtonsVisibility() {
          return null !== this._trading && l.enabled('buy_sell_buttons')
            ? this._trading.showSellBuyButtons
            : null
        }
        domPanelVisibility() {
          return null !== this._trading
            ? this._trading.domPanelVisibility()
            : null
        }
        orderPanelVisibility() {
          return null !== this._trading
            ? this._trading.orderPanelVisibility()
            : null
        }
        showPricesWithZeroVolume() {
          return (0, h.ensureNotNull)(this._trading).showPricesWith().zeroVolume
        }
        showNotification(e, t, i = 0) {
          null !== this._trading &&
            (0 === i
              ? this._trading.showErrorNotification(e, t)
              : this._trading.showSuccessNotification(e, t))
        }
        connectionStatusUpdate(e, t) {
          this._adapter.connectionStatusUpdate.fire(e, t),
            1 === e && this._setDefaultDropdownActions()
        }
        orderUpdate(e) {
          this._adapter.onOrderUpdate(e)
        }
        positionUpdate(e, t) {
          this._adapter.onPositionUpdate(e, t)
        }
        individualPositionUpdate(e, t) {
          this._adapter.onIndividualPositionUpdate(e, t)
        }
        executionUpdate(e) {
          this._adapter.executionUpdate.fire(e)
        }
        currentAccountUpdate() {
          this._adapter.onCurrentAccountChanged()
        }
        realtimeUpdate(e, t) {
          this._adapter.fireSubscription('Realtime', e, t)
        }
        domUpdate(e, t) {
          this._adapter.fireSubscription('DOM', e, t)
        }
        pipValueUpdate(e, t) {
          this._adapter.fireSubscription('PipValue', e, t)
        }
        setQty(e, t) {
          ;(0, h.ensureNotNull)(this._trading).getQtySuggester().setQty(e, t)
        }
        getQty(e) {
          return (0, h.ensureNotNull)(this._trading).getQtySuggester().getQty(e)
        }
        subscribeSuggestedQtyChange(e, t) {
          var i
          const r =
            null !== (i = this._qtyChangedSubscriptions.get(e)) && void 0 !== i
              ? i
              : new Map()
          if (r.has(t)) return
          this._qtyChangedSubscriptions.has(e) ||
            this._qtyChangedSubscriptions.set(e, r)
          const s = (0, h.ensureNotNull)(this._trading)
            .getQtySuggester()
            .suggestedQtyChanged(e)
          r.set(t, s.subscribe(t))
        }
        unsubscribeSuggestedQtyChange(e, t) {
          const i = this._qtyChangedSubscriptions.get(e)
          if (void 0 === i) return
          const r = i.get(t)
          void 0 !== r &&
            (r.unsubscribe(),
            i.delete(t),
            0 === i.size && this._qtyChangedSubscriptions.delete(e))
        }
        plUpdate(e, t) {
          this._adapter.fireSubscription('PL', e, t)
        }
        individualPositionPLUpdate(e, t) {
          this._adapter.fireSubscription('IndividualPositionPL', e, t)
        }
        equityUpdate(e) {
          this._adapter.fireSubscription('Equity', 'Equity', e)
        }
        marginAvailableUpdate(e) {
          this._adapter.fireSubscription(
            'MarginAvailable',
            'MarginAvailable',
            e,
          )
        }
        cryptoBalanceUpdate(e, t) {
          this._adapter.fireSubscription('CryptoBalance', e, t)
        }
        setButtonDropdownActions(e) {
          var t
          null !== this._trading &&
            this._defaultDropdownActions &&
            ((this._defaultDropdownActions = !1),
            null === (t = this.sellBuyButtonsVisibility()) ||
              void 0 === t ||
              t.unsubscribe(this._setDefaultDropdownActionsBound),
            (0, h.ensureNotNull)(this.orderPanelVisibility()).unsubscribe(
              this._setDefaultDropdownActionsBound,
            ),
            (0, h.ensureNotNull)(this.domPanelVisibility()).unsubscribe(
              this._setDefaultDropdownActionsBound,
            )),
            (this._buttonDropdownActions = e)
        }
        buttonDropdownActions() {
          return this._buttonDropdownActions
        }
        defaultContextMenuActions(...e) {
          return null !== this._trading
            ? this._trading.defaultContextMenuActions(...e)
            : Promise.resolve([])
        }
        defaultDropdownMenuActions(e) {
          return null !== this._trading
            ? this._trading.defaultDropdownMenuActions(e)
            : []
        }
        get factory() {
          return {
            createDelegate: () => new u.Delegate(),
            createWatchedValue: (e) => new se.WatchedValue(e),
            createPriceFormatter: (e, t, i, r, s) =>
              new ce.PriceFormatter(e, t, i, r, s),
          }
        }
        get settings() {
          return {
            save: (e, t) => re().setJSON(`${this._metainfo.id}.${e}`, t),
            load: (e, t) => re().getJSON(`${this._metainfo.id}.${e}`, t),
            clear: (e, t) => re().remove(`${this._metainfo.id}.${e}`, t),
          }
        }
        get credentialsStorage() {
          return this._credentialsStorage
        }
        convertTimezone(e, t, i) {
          const r = oe.get_timezone(t),
            s = oe.get_timezone(i),
            o = oe.cal_to_utc(r, e)
          return oe.utc_to_cal(s, o)
        }
        language() {
          return window.language
        }
        getUserSpecificHash() {
          return window.user.private_channel || ''
        }
        activateFXCMCFD() {
          re().setValue('fxcm_cfd', !0)
        }
        async isFractional(e) {
          var t
          const i = await be(e)
          return 'values' in i
            ? !ve(i) && void 0 !== i.values.fractional && i.values.fractional
            : null !== (t = i.fractional) && void 0 !== t && t
        }
        _makeServerLoggerWithFilledInfo(e) {
          return {
            log: (t) =>
              e.log({ ...this._makeServerLoggerEventAdditionalInfo(), ...t }),
            debounceLog: (t, i, r) =>
              e.debounceLog(
                { ...this._makeServerLoggerEventAdditionalInfo(), ...t },
                i,
                r,
              ),
          }
        }
        _makeServerLoggerEventAdditionalInfo() {
          return {
            accountType: this._adapter.currentAccountType(),
            brokerId: this._adapter.metainfo().id,
            sessionId: this._adapter.sessionId(),
            tvUsername: window.user.username,
            ref: location.href,
            online: navigator.onLine,
            platform: (0, w.getPlatform)(),
          }
        }
        _setDefaultDropdownActions() {
          null !== this._trading &&
            this._defaultDropdownActions &&
            (this._buttonDropdownActions = this.defaultDropdownMenuActions())
        }
      }
      var fe = i(340794)
      const ke = (0, g.getLogger)('Trading.EncryptedWebStorage')
      class Se {
        constructor({
          prefix: e,
          storageName: t,
          storage: i,
          cryptographer: r,
        }) {
          ;(this._transientStorage = {}),
            (this._handleStorageStateChange = (e) => {
              const { key: t, storageArea: i } = e
              i === this._persistentStorage &&
                this._storageName === t &&
                this._decryptStorage()
            }),
            (this._storageName = t),
            (this._prefix = null == e ? void 0 : e.toLowerCase()),
            (this._persistentStorage = i),
            (this._cryptographer = r),
            (this._decryptStorage = (0, fe.sequentialize)(
              this._decryptStorage,
            )),
            window.addEventListener('storage', this._handleStorageStateChange)
        }
        async setItem(e, t) {
          const i = this._addPrefix(e)
          this._transientStorage[i] = JSON.stringify(t)
          try {
            await this._encryptStorageAndSave()
          } catch (e) {
            ke.logError(
              `Unable to save value using key ${i}: ${(0, k.getLoggerMessage)(e)}`,
            )
          }
        }
        getItem(e, t = null) {
          const i = this._transientStorage[this._addPrefix(e)]
          if (void 0 === i) return t
          if ('string' != typeof i) return i
          try {
            return JSON.parse(i)
          } catch (e) {
            return i
          }
        }
        async removeItem(e) {
          delete this._transientStorage[this._addPrefix(e)],
            await this._encryptStorageAndSave()
        }
        destroy() {
          window.removeEventListener('storage', this._handleStorageStateChange)
        }
        static async create(e, t, i, r) {
          const s = new Se({
            prefix: e,
            storageName: t,
            storage: i,
            cryptographer: r,
          })
          return await s._decryptStorage(), s
        }
        _addPrefix(e) {
          return void 0 !== this._prefix ? `${this._prefix}.${e}` : e
        }
        async _decryptStorage() {
          const e = this._persistentStorage.getItem(this._storageName)
          if (null === e) return void (this._transientStorage = {})
          const t = await this._cryptographer.decrypt(e)
          if (null === t)
            return (
              this._persistentStorage.removeItem(this._storageName),
              void (this._transientStorage = {})
            )
          try {
            this._transientStorage = JSON.parse(t)
          } catch (e) {
            this._transientStorage = {}
          }
        }
        async _encryptStorageAndSave() {
          const e = await this._cryptographer.encrypt(
            JSON.stringify(this._transientStorage),
          )
          this._persistentStorage.setItem(this._storageName, e)
        }
      }
      const Pe = 'credentials-storage'
      class Ce {
        constructor(e, t, i) {
          ;(this._rememberCredentials = e),
            (this._encryptedLocalStorage = t),
            (this._encryptedSessionStorage = i)
        }
        async save(e, t) {
          this._currentEncryptedStorage().setItem(e, t)
        }
        load(e, t) {
          return this._currentEncryptedStorage().getItem(e, t)
        }
        async clear(e) {
          this._currentEncryptedStorage().removeItem(e)
        }
        destroy() {
          this._encryptedLocalStorage.destroy(),
            this._encryptedSessionStorage.destroy()
        }
        static async create(e, t, i) {
          const r = await Se.create(e, Pe, localStorage, i),
            s = await Se.create(e, Pe, sessionStorage, i)
          return new Ce(t, r, s)
        }
        _currentEncryptedStorage() {
          return this._rememberCredentials.value()
            ? this._encryptedLocalStorage
            : this._encryptedSessionStorage
        }
      }
      var we = i(34694)
      const Be = {
        isSuspended: !1,
        supportDemoLiveSwitcher: !0,
        supportModifyOrderPrice: !0,
        supportEditAmount: !0,
        supportModifyBrackets: !0,
        supportMarketBrackets: !0,
        supportMarketOrders: !0,
        supportStopOrders: !0,
        supportLimitOrders: !0,
        supportLeverageButton: !0,
        supportStopLimitOrders: !1,
        supportPositions: !0,
        supportDOM: !0,
        supportModifyTrailingStop: !0,
        supportAddBracketsToExistingOrder: !0,
        supportVerifyLiveAccount: !0,
        supportReversePosition: !0,
        showNotificationsLog: !0,
        supportPLUpdate: !0,
        supportTwoFactorAuthorization: !1,
        supportDisplayBrokerNameInSymbolSearch: !0,
        supportCurrencyInOrderPreview: !0,
        supportRiskControls: !0,
        supportCreateAccount: !1,
        supportDeleteAccount: !1,
        checkBracketsAfterOrderModification: !0,
        supportStrictCheckingLimitOrderPrice: !1,
      }
      class Te {
        constructor(e, t) {
          ;(this._settingsKey = `trading.${e}.rememberCredentials`),
            (this._trackEvent = t)
          const i = re().getBool(this._settingsKey)
          void 0 !== i &&
            (localStorage.setItem(this._settingsKey, JSON.stringify(i)),
            re().remove(this._settingsKey))
        }
        value() {
          const e = localStorage.getItem(this._settingsKey)
          return null === e || Boolean(JSON.parse(e))
        }
        setValue(e) {
          var t
          null === (t = this._trackEvent) ||
            void 0 === t ||
            t.call(this, "Don't remember me", String(!e)),
            localStorage.setItem(this._settingsKey, JSON.stringify(e))
        }
      }
      const Ee = []
      function Oe(e, t) {
        var i
        ;(e.configFlags = ((i = e.configFlags), Object.assign({}, Be, i))),
          Ee.push({ metainfo: e, createBrokerFunction: t })
      }
      function De() {
        return Ee.map((e) => e.metainfo)
      }
      let Ie
      async function xe(e, t, i, r, s) {
        const o = Ee.filter((e) => e.metainfo.id === t)[0]
        let n
        if (null === r) {
          const i = await Ce.create(t, new Te(t), Ie),
            r = (s) => {
              ;(null == s ? void 0 : s.metainfo().id) !== t &&
                (null == e || e.onBrokerChange.unsubscribe(null, r),
                i.destroy())
            }
          null == e || e.onBrokerChange.subscribe(null, r), (n = i)
        } else n = r
        const a = new ye(e, o.metainfo, i, n)
        try {
          const t = await o.createBrokerFunction(
              a,
              null == e ? void 0 : e.brokerTelemetry,
            ),
            i = new we.BrokerRealtimeAdapter(o.metainfo.id)
          return new te({
            brokerMetainfo: o.metainfo,
            brokerConnection: t,
            host: a,
            brokerRealtimeAdapter: i,
            tradingStat: e && e.tradingStat(),
            tradingSettingsStorageGetter:
              e && e.getBrokerTradingSettingsStorage,
            brokerPlan: s,
          })
        } catch (e) {
          return Promise.reject(
            `${t} broker creation error: ${(0, k.getLoggerMessage)(e)}`,
          )
        }
      }
      function Me(e) {
        return De().filter((t) => t.id === e)[0]
      }
      Ie = { encrypt: async (e) => e, decrypt: async (e) => e }
    },
    768819: (e, t, i) => {
      i.d(t, { DialogVisibility: () => o })
      var r = i(947488),
        s = i(218286)
      class o {
        constructor() {
          ;(this._value$ = new r.BehaviorSubject({ isVisible: !1 })),
            (this.value$ = this._value$
              .asObservable()
              .pipe(
                (0, s.distinctUntilChanged)(
                  (e, t) =>
                    e.isVisible === t.isVisible &&
                    e.isFullScreen === t.isFullScreen,
                ),
              ))
        }
        getValue() {
          return this._value$.getValue()
        }
        setValue(e) {
          this._value$.next(e)
        }
      }
    },
    948776: (e, t, i) => {
      i.d(t, { DisabledConfirmations: () => u })
      var r = i(870122),
        s = i.n(r),
        o = i(855385),
        n = i.n(o),
        a = i(322625)
      const l = /[0-9]+([\.,][0-9]+)*([\.,][0-9]+)?|\.[0-9]+/gm,
        c = /[A-Z]+/gm,
        d = a.settingsKeys.DISABLED_CONFIRMATIONS
      class u {
        add(e) {
          const t = this._getAll(),
            i = this._makeMessageHash(e)
          t.add(i), s().setJSON(d, Array.from(t))
        }
        has(e) {
          const t = this._getAll(),
            i = this._makeMessageHash(e)
          return t.has(i)
        }
        clear() {
          s().remove(d)
        }
        _getAll() {
          return new Set(s().getJSON(d))
        }
        _makeMessageHash(e) {
          const t = e.replace(l, '').replace(c, '')
          return (
            (i = n()(t)),
            btoa(String.fromCharCode.apply(null, new Uint8Array(i)))
          )
          var i
        }
      }
    },
    998018: (e, t, i) => {
      function r(e) {
        return 'string' == typeof e ? e : Array.isArray(e) ? e.join('') : void 0
      }
      i.d(t, { makeConfirmation: () => r })
    },
    156115: (e, t, i) => {
      i.d(t, { showConfirmDialog: () => a })
      var r = i(609838),
        s = i(998018),
        o = i(948776),
        n = i(148442)
      async function a(e) {
        const {
            title: t,
            content: a,
            mainButtonText: l,
            cancelButtonText: c,
            showDisableConfirmationsCheckbox: d,
            onOpen: u,
            onClose: h,
            abortSignal: p,
          } = e,
          g = new o.DisabledConfirmations(),
          m = (0, s.makeConfirmation)(a)
        if (d && void 0 !== m && g.has(m)) return !0
        const { ConfirmDialogRenderer: _ } = await Promise.all([
            i.e(580),
            i.e(8194),
            i.e(4215),
            i.e(3610),
            i.e(3717),
            i.e(1282),
            i.e(7084),
            i.e(3566),
          ]).then(i.bind(i, 537954)),
          b = new _(g),
          v = {
            title: t,
            message: a,
            closeButton: null != c ? c : r.t(null, void 0, i(606255)),
            confirmButton: null != l ? l : r.t(null, void 0, i(879831)),
            showDisableConfirmationsCheckbox: d,
            onOpen: u,
            onClose: h,
            abortSignal: p,
          }
        try {
          return (await b.open(v)).status
        } catch (e) {
          if ((0, n.isAbortError)(e)) return !1
          throw e
        }
      }
    },
    252546: (e, t, i) => {
      i.d(t, { showSimpleConfirmDialog: () => o })
      var r = i(148442),
        s = i(948776)
      async function o(e) {
        const {
            showDisableConfirmationsCheckbox: t,
            text: o,
            onConfirm: n,
            onClose: a,
            onCancel: l,
            abortSignal: c,
          } = e,
          d = new s.DisabledConfirmations()
        if (t && d.has(o)) return Promise.resolve(!0)
        if (null == c ? void 0 : c.aborted) return Promise.resolve(!1)
        const [{ showSimpleDialog: u }, { SimpleConfirmDialog: h }] =
          await Promise.all([
            Promise.all([
              i.e(580),
              i.e(8194),
              i.e(4215),
              i.e(3610),
              i.e(3717),
              i.e(1282),
              i.e(7084),
              i.e(3566),
            ]).then(i.bind(i, 480994)),
            Promise.all([
              i.e(580),
              i.e(8194),
              i.e(4215),
              i.e(3610),
              i.e(3717),
              i.e(1282),
              i.e(7084),
              i.e(3566),
            ]).then(i.bind(i, 210795)),
          ])
        return new Promise((t, i) => {
          if (null == c ? void 0 : c.aborted)
            return void i((0, r.createAbortError)())
          const s = u(
            {
              ...e,
              disabledConfirmations: d,
              onConfirm: (e) => {
                t(!0), void 0 !== n && n(), e.dialogClose()
              },
              onClose: () => {
                t(!1), void 0 !== a && a()
              },
              onCancel: (e) => {
                t(!1), void 0 !== l && l(e), e.dialogClose()
              },
            },
            h,
          )
          null == c ||
            c.addEventListener(
              'abort',
              () => {
                s(), i((0, r.createAbortError)())
              },
              { once: !0 },
            )
        })
      }
    },
    314996: (e, t, i) => {
      i.d(t, { ConfirmBracketsCancelDialog: () => o })
      var r = i(609838),
        s = i(252546)
      const o = {
        get() {
          return this
        },
        open: (e, t) =>
          (0, s.showSimpleConfirmDialog)({
            title: r.t(null, void 0, i(232668)),
            text: r
              .t(null, void 0, i(289302))
              .replace('{orderId}', '' !== e ? e + ' ' : ''),
            mainButtonIntent: 'primary',
            abortSignal: t,
          }),
        multiple: (e, t) =>
          (0, s.showSimpleConfirmDialog)({
            title: r.t(null, void 0, i(232668)),
            text: r
              .t(null, void 0, i(915610))
              .replace('{orderId}', '' !== e ? e + ' ' : ''),
            mainButtonIntent: 'primary',
            abortSignal: t,
          }),
      }
    },
    120283: (e, t, i) => {
      i.d(t, { ConfirmOrderCancelDialog: () => o })
      i(336379)
      var r = i(609838),
        s = i(252546)
      const o = {
        get() {
          return this
        },
        open: (e, t) =>
          (0, s.showSimpleConfirmDialog)({
            title: r.t(null, void 0, i(709498)),
            text: r.t(null, void 0, i(438540)).replace('{orderId}', e),
            mainButtonIntent: 'primary',
            abortSignal: t,
          }),
        multiple(e, t, o, n) {
          let a = e
          if (void 0 !== t) {
            a = `${a} ${1 === t ? r.t(null, void 0, i(864351)) : r.t(null, void 0, i(807889))}`
          }
          return (0, s.showSimpleConfirmDialog)({
            title: r.t(null, void 0, i(709498)),
            text: r
              .t(null, void 0, i(109886))
              .replace('{qty}', String(o))
              .replace('{side}', a),
            mainButtonIntent: 'primary',
            abortSignal: n,
          })
        },
      }
    },
    66786: (e, t, i) => {
      i.d(t, { reversePositionDialog: () => o })
      var r = i(609838),
        s = i(252546)
      async function o(e) {
        const {
          positionId: t,
          showErrorNotification: o,
          handler: n,
          closePositionCancelsOrders: a,
          abortSignal: l,
        } = e
        if (
          !(await (0, s.showSimpleConfirmDialog)({
            title: r.t(null, void 0, i(172361)).replace('{positionId}', t),
            text:
              r.t(null, void 0, i(492698)).replace('{positionId}', t) +
              (a ? ' ' + r.t(null, void 0, i(893827)) : ''),
            mainButtonText: r.t(null, void 0, i(920848)),
            mainButtonIntent: 'primary',
            cancelButtonText: r.t(null, void 0, i(620036)),
            showBackdrop: !0,
            abortSignal: l,
          }))
        )
          return !1
        try {
          return await n()
        } catch (e) {
          return (
            o(
              r.t(null, void 0, i(945593)),
              ((e) => {
                let t = ''
                null !== e && 'object' == typeof e && e.message
                  ? (t = e.message)
                  : 'string' == typeof e && (t = e)
                return t
              })(e),
            ),
            !1
          )
        }
      }
    },
    795820: (e, t, i) => {
      i.d(t, {
        HeaderContainer: () => L,
        mountHeader: () => V,
        unmountHeader: () => R,
      })
      var r = i(50959),
        s = i(500962),
        o = i(32133),
        n = i(72571),
        a = i(661851),
        l = i(609838),
        c = i(930052),
        d = i(518799),
        u = i(395907),
        h = i(996038),
        p = i(311757)
      var g = i(958057),
        m = i(363111),
        _ = i(497754),
        b = i.n(_),
        v = i(75577),
        y = i(476853),
        f = i(2537)
      function k(e) {
        const {
          icon: t,
          iconClassName: i,
          title: s,
          titleColor: o,
          text: a,
          solutionId: l,
        } = e
        return r.createElement(
          d.ToolWidgetMenu,
          {
            arrow: !1,
            content: r.createElement(n.Icon, { icon: t }),
            className: b()(f.icon, f.button, i),
            drawerBreakpoint: v.TradingLayoutBreakpoint.Mobile,
            title: s,
            horizontalAttachEdge: y.HorizontalAttachEdge.Right,
            horizontalDropDirection: y.HorizontalDropDirection.FromRightToLeft,
          },
          r.createElement(
            'div',
            { className: f.wrapper },
            r.createElement(n.Icon, { icon: t, className: b()(f.icon, i) }),
            r.createElement(
              'div',
              { className: f.infoContainer },
              r.createElement(
                'span',
                { className: f.title, style: { color: o } },
                s,
              ),
              r.createElement('span', { className: f.text }, a),
              false,
            ),
          ),
        )
      }
      var S = i(643959),
        P = i(966883),
        C = i(513729),
        w = i(29834),
        B = i(512646),
        T = i(552828),
        E = i(867838)
      const O = l.t(null, void 0, i(348836))
      function D(e) {
        const {
          settingsItems: t,
          title: s,
          description: o,
          symbol: a,
          hasDelayedWarning: _,
          hasBatsQuotes: b,
          informerMessage: v,
          back: y,
          close: f,
          cancel: D,
        } = e
        let I
        if (
          (_ &&
            (I = {
              icon: B,
              iconClassName: E.delayedDataIcon,
              title: l.t(null, void 0, i(675649)),
              titleColor: E.delayedDataTitleColor,
              text: O,
            }),
          b)
        ) {
          const [e, t] = a.split(':'),
            i = `${g.batsToRealtimeHtml1.replace('{symbolName}', t).replace('{exchange}', g.notAccurateCboeTooltip)} ${g.batsToRealtimeHtml2WithExchange.replace('{exchange}', e)}`
          I = {
            icon: T,
            iconClassName: E.batsQuotesIcon,
            title: (0, p.htmlEscape)(
              g.exchangeByOriginalExchangeTooltip,
            ).format({
              exchange: e,
              originalExchange: g.notAccurateCboeTooltip,
            }),
            titleColor: E.batsQuotesTitleColor,
            text: i,
            solutionId: 43000473924,
          }
        }
        const x =
          r.useContext(m.Context).mode === m.OrderEditorDisplayMode.Popup
            ? { 'data-dragg-area': !0 }
            : {}
        return r.createElement(
          'div',
          { className: E.header },
          void 0 !== y &&
            r.createElement(u.ToolWidgetIconButton, {
              title: l.t(null, void 0, i(762592)),
              onClick: y,
              className: E.button,
              'data-name': 'button-back',
              icon: S,
            }),
          r.createElement(
            'div',
            { className: E.wrapper, ...x },
            r.createElement('span', { className: E.text }, s, o && `, ${o}`),
            (void 0 !== v || void 0 !== I) &&
              r.createElement(
                'div',
                { className: E.statusLine },
                void 0 !== v &&
                  r.createElement(TradingInformer, { informerMessage: v }),
                void 0 !== I && r.createElement(k, { ...I }),
              ),
          ),
          void 0 !== D &&
            r.createElement(u.ToolWidgetIconButton, {
              title: l.t(null, void 0, i(620036)),
              onClick: D,
              className: E.button,
              'data-name': 'button-cancel',
              icon: P,
            }),
          0 !== r.Children.count(t) &&
            r.createElement(
              c.MatchMedia,
              { rule: h.DialogBreakpoints.TabletSmall },
              (e) =>
                r.createElement(d.ToolWidgetMenu, {
                  className: E.settingsButton,
                  content: r.createElement(n.Icon, { icon: w }),
                  menuClassName: E.settingsPopupMenu,
                  children: t,
                  isDrawer: e,
                  title: l.t(null, void 0, i(389517)),
                  arrow: !1,
                  closeOnClickOutside: !0,
                  'data-name': 'order-ticket-settings',
                }),
            ),
          void 0 !== f &&
            r.createElement(u.ToolWidgetIconButton, {
              title: l.t(null, { context: 'action' }, i(768508)),
              onClick: f,
              className: E.button,
              'data-name': 'button-close',
              icon: C,
            }),
        )
      }
      var I = i(379266),
        x = i(192063),
        M = i(623549)
      function A(e) {
        const { label: t, value$: i, dataName: s, onClick: o } = e,
          n = (0, a.useObservable)(i)
        return r.createElement(I.PopupMenuItemToggle, {
          'data-name': s,
          labelClassName: M.checkBoxWrapper,
          label: t,
          isChecked: !!n,
          onClick: o,
        })
      }
      function N(e) {
        const {
            onIcon: t,
            offIcon: i,
            onLabel: s,
            offLabel: o,
            value$: l,
            dataName: c,
            onClick: d,
          } = e,
          u = (0, a.useObservable)(l)
        return r.createElement(x.PopupMenuItem, {
          onClick: d,
          'data-name': c,
          label: r.createElement(
            'div',
            { className: M.toggleContentWrapper },
            r.createElement(n.Icon, { icon: u ? t : i }),
            r.createElement('span', null, u ? s : o),
          ),
        })
      }
      function L(e) {
        const {
            title$: t,
            description$: i,
            backFunction$: s,
            closeFunction$: n,
            cancelFunction$: l,
            informerMessage$: c,
            symbol$: d,
            hasBatsQuotes$: u,
            hasDelayedQuotes$: h,
            isTradable$: p,
            settings$: g,
          } = e,
          m = (0, a.useObservable)(t),
          _ = (0, a.useObservable)(i),
          b = (0, a.useObservable)(s),
          v = (0, a.useObservable)(n),
          y = (0, a.useObservable)(l),
          f = (0, a.useObservable)(d),
          k = (0, a.useObservable)(u),
          S = (0, a.useObservable)(h),
          P = (0, a.useObservable)(p),
          C = ((0, a.useObservable)(c), (0, a.useObservable)(g)),
          w = (0, r.useMemo)(
            () =>
              void 0 !== C && P
                ? C.map((e) =>
                    0 === e.settingType
                      ? r.createElement(A, { key: e.label, ...e })
                      : r.createElement(N, { key: e.onLabel, ...e }),
                  )
                : null,
            [C, P],
          ),
          B = (0, r.useMemo)(
            () =>
              void 0 !== v
                ? () => {
                    ;(0, o.trackEvent)('GUI', 'Close Order Panel from panel'),
                      v()
                  }
                : void 0,
            [v],
          ),
          T = (0, r.useMemo)(
            () =>
              void 0 !== y
                ? () => {
                    ;(0, o.trackEvent)('GUI', 'Reset Order Panel'), y()
                  }
                : void 0,
            [y],
          )
        return r.createElement(D, {
          title: m || '',
          description: _,
          symbol: null != f ? f : '',
          settingsItems: w,
          hasDelayedWarning: S,
          hasBatsQuotes: k,
          isTradable: P,
          informerMessage: void 0,
          back: b,
          close: B,
          cancel: T,
        })
      }
      function V(e, t) {
        s.render(r.createElement(L, { ...t }), e)
      }
      function R(e) {
        s.unmountComponentAtNode(e)
      }
    },
    529719: (e, t, i) => {
      i.d(t, {
        alignQuotesToMinTick: () => T,
        calculatePipValue: () => y,
        calculateTradeValue: () => f,
        calculateTradeValueByBigPointValue: () => k,
        calculateUsedMargin: () => S,
        calculatedMarginRatio: () => P,
        checkPriceByOrderType: () => E,
        comparator: () => _,
        convertToBaseMonetaryUnit: () => x,
        createCustomFieldModels: () => D,
        displayedLeverage: () => v,
        formatInfoValue: () => C,
        formatRiskReward: () => B,
        makeSubjectFromWatchedValue: () => m,
        prepareCalculatorEventText: () => O,
        prepareTradableSolution: () => I,
        shouldShowTotal: () => b,
      })
      var r = i(609838),
        s = i(688401),
        o = i(947488),
        n = i(960521),
        a = i(466052),
        l = i(650802),
        c = i(372605),
        d = i(481330),
        u = i(793361),
        h = i(357407),
        p = i(600297),
        g = i(807107)
      function m(e) {
        const t = new o.BehaviorSubject(e.value()),
          i = (e) => {
            t.next(e)
          }
        return (
          e.subscribe(i), { subject: t, unsubscribe: () => e.unsubscribe(i) }
        )
      }
      function _(e, t) {
        return (0, c.deepEquals)(e, t)[0]
      }
      function b(e) {
        return void 0 !== e && Boolean(e.showTotal)
      }
      function v(e, t) {
        if (void 0 !== e) return e
        if (void 0 !== t) {
          const e = Math.round(1 / t)
          return String(e) + ':1'
        }
        return null
      }
      function y(e, t, i) {
        return null !== e ? (void 0 !== i ? e * i : e) * t : 0
      }
      function f(e, t, i, r, s) {
        return k(e, t, i / r, s)
      }
      function k(e, t, i, r) {
        return e * t * i * (r || 1)
      }
      function S(e, t) {
        return void 0 !== t ? e * t : 0
      }
      function P(e, t) {
        const i = 0 !== t ? (100 * e) / t : 0
        return i > 100 ? 100 : i
      }
      function C(e) {
        if ('number' == typeof e) {
          const t = (0, u.splitThousands)((e || 0).toFixed(2), ' ')
          return Number.isInteger(e) || e >= 1
            ? t
            : ((e) => {
                if (Number.isInteger(e)) return e + ''
                return e < 1
                  ? ((e) => {
                      const t = (e + '').split('.')[1] || ''
                      let i = t.length
                      for (let e = 0; e < t.length; e++)
                        if ('0' !== t[e]) {
                          i = e + 1
                          break
                        }
                      return e.toFixed(i)
                    })(e)
                  : e.toFixed(2)
              })(e)
        }
        return (0, u.splitThousands)(e, ' ')
      }
      const w = new h.VolumeFormatter(2)
      function B(e, t) {
        return null !== e && null !== t && e / t > 0 ? w.format(e / t) : ''
      }
      function T(e, t, i) {
        const r = Object.assign({}, e)
        return (
          ['trade', 'ask', 'bid'].forEach((e) => {
            const s = r[e]
            if (void 0 !== s) {
              const o = (0, g.getMinTick)({
                minTick: t,
                price: s,
                variableMinTickData: i,
              })
              r[e] = (0, d.alignToMinTick)(s, o)
            }
          }),
          r
        )
      }
      function E(e, t, i) {
        return 4 === e
          ? null === t || null === i
          : 3 === e
            ? null === i
            : null === t
      }
      function O(e, t) {
        switch (t) {
          case p.ButtonType.IncDec:
            return e < 0 ? '-' : '+'
          case p.ButtonType.PlusValue:
            return String(e)
          case p.ButtonType.Clear:
            return 'Clear'
          default:
            return 'Default'
        }
      }
      function D(e) {
        const {
            modifyMode: t,
            alwaysShowAttachedErrors$: i,
            tradingDialogOptions: r,
            existedValues: s,
          } = e,
          n = []
        return (
          void 0 !== r &&
            Array.isArray(r.customFields) &&
            r.customFields.forEach((e) => {
              if ('TextWithCheckBox' === e.inputType) {
                const t = new o.BehaviorSubject(e.value.text),
                  i = new o.BehaviorSubject(e.value.checked),
                  r = new l.WatchedValue(!0),
                  s = new l.WatchedValue(),
                  c = e.validator,
                  d =
                    void 0 !== c
                      ? (e) => {
                          const t = c(e)
                          r.setValue(t.valid),
                            s.setValue(t.valid ? void 0 : t.errorMessage)
                        }
                      : void 0,
                  u = void 0 !== d ? t.subscribe(d) : void 0
                n.push({
                  id: e.id,
                  type: e.inputType,
                  inputType: e.customInfo.asterix ? 'password' : 'text',
                  placeholder: e.placeHolder || '',
                  title: e.title || '',
                  checkboxTitle: e.customInfo.checkboxTitle,
                  text$: t.asObservable(),
                  getText: t.getValue.bind(t),
                  setText: t.next.bind(t),
                  checked$: i.asObservable(),
                  getChecked: i.getValue.bind(i),
                  setChecked: i.next.bind(i),
                  onControlFocused: new a.Delegate(),
                  isValid: r,
                  errorMessage: s,
                  destroy: () => (null == u ? void 0 : u.unsubscribe()),
                })
              }
              if ('Checkbox' === e.inputType) {
                let i
                const r = null == s ? void 0 : s[e.id]
                try {
                  i = JSON.parse(r)
                } catch (e) {
                  i = r
                }
                const c = new o.BehaviorSubject(null != i ? i : e.value)
                n.push({
                  id: e.id,
                  type: e.inputType,
                  title: e.title,
                  help: e.help,
                  checked$: c.asObservable(),
                  getChecked: c.getValue.bind(c),
                  setChecked: c.next.bind(c),
                  onControlFocused: new a.Delegate(),
                  disabled: t && !e.supportModify,
                  saveToSettings: e.saveToSettings,
                  isValid: new l.WatchedValue(!0),
                  errorMessage: new l.WatchedValue(),
                  destroy: () => {},
                })
              }
              if ('ComboBox' === e.inputType && Array.isArray(e.items)) {
                let r = e.items[0]
                if (s && e.id in s) {
                  const t = s[e.id],
                    i = e.items.find((e) => e.value === t)
                  void 0 !== i && (r = i)
                } else e.forceUserEnterInitialValue && !t && (r = void 0)
                const c = new o.BehaviorSubject(null == r ? void 0 : r.value)
                n.push({
                  id: e.id,
                  type: e.inputType,
                  title: e.title,
                  items: e.preventModify && t && r ? [r] : e.items,
                  selectedItem$: c.asObservable(),
                  getSelectedItem: c.getValue.bind(c),
                  setSelectedItem: c.next.bind(c),
                  onControlFocused: new a.Delegate(),
                  saveToSettings: e.saveToSettings,
                  alwaysShowAttachedErrors$: i,
                  isValid: new l.WatchedValue(!0),
                  errorMessage: new l.WatchedValue(),
                  destroy: () => {},
                })
              }
            }),
          n
        )
      }
      async function I(e, t) {
        if (void 0 === e.solutions) return
        if ('changeSymbol' in e.solutions) {
          const t = e.solutions.changeSymbol
          return {
            title: r.t(null, void 0, i(562030)),
            apply: () => s.linking.setSymbolAndLogInitiator(t, 'order ticket'),
          }
        }
        if ('changeAccount' in e.solutions) {
          const s = e.solutions.changeAccount,
            o = (await t.accountsMetainfo()).filter((e) => e.id === s)[0].name
          return {
            title: r.t(null, void 0, i(134542)).replace('{accountName}', o),
            apply: () => t.setCurrentAccount(s),
          }
        }
        const o = e.solutions.openUrl.url
        return {
          title: e.solutions.openUrl.text,
          apply: () => window.open(o, '_blank'),
        }
      }
      function x(e, t) {
        return void 0 === t ? e : (0, n.Big)(e).div(t).toNumber()
      }
    },
    864348: (e, t, i) => {
      var r, s
      function o(e) {
        return (null == e ? void 0 : e.type) === s.PlaceOrder
      }
      i.d(t, {
        PlaceOrEditContextStatus: () => r,
        PlaceOrEditContextType: () => s,
        isContextPlaceOrderContext: () => o,
      }),
        ((e) => {
          ;(e[(e.Undefined = 0)] = 'Undefined'),
            (e[(e.Loading = 1)] = 'Loading'),
            (e[(e.Error = 2)] = 'Error')
        })(r || (r = {})),
        ((e) => {
          ;(e[(e.PlaceOrder = 0)] = 'PlaceOrder'),
            (e[(e.EditOrder = 1)] = 'EditOrder'),
            (e[(e.EditPosition = 2)] = 'EditPosition'),
            (e[(e.EditIndividualPosition = 3)] = 'EditIndividualPosition')
        })(s || (s = {}))
    },
    690839: (e, t, i) => {
      i.d(t, {
        OrdersService: () => g,
        cropOrderData: () => p,
        isBracketOrderRawData: () => u,
      })
      var r = i(650151),
        s = i(466052),
        o = i(372605),
        n = i(6835),
        a = i(481853),
        l = i(481330),
        c = i(397728)
      const d = (0, n.getLogger)('Trading.OrderService')
      function u(e) {
        return (
          'parentId' in e &&
          void 0 !== e.parentId &&
          'parentType' in e &&
          void 0 !== e.parentType
        )
      }
      function h(e) {
        return 1 === e.type
          ? (0, r.ensureDefined)(e.limitPrice)
          : (0, r.ensureDefined)(e.stopPrice)
      }
      function p(e) {
        return {
          id: e.id,
          parentId: e.parentId,
          parentType: e.parentType,
          symbol: e.symbol,
          type: e.type,
          side: e.side,
          avgPrice: e.avgPrice,
          limitPrice: e.limitPrice,
          stopPrice: e.stopPrice,
          price: e.price,
          stopLoss: e.stopLoss,
          trailingStopPips: e.trailingStopPips,
          stopType: e.stopType,
          takeProfit: e.takeProfit,
          status: e.status,
          qty: e.qty,
        }
      }
      class g extends a.BrokerService {
        constructor() {
          super(...arguments),
            (this._existingOrdersIds = new Set()),
            (this._activeOrders = new Map()),
            (this._activeOrderUpdate = new s.Delegate()),
            (this._activeOrdersRemoved = new s.Delegate()),
            (this._ordersRejected = new s.Delegate())
        }
        destroy() {
          this.stopService()
        }
        async getCurrency() {
          const e = (0, r.ensureNotNull)(this.activeBroker()),
            t = await e.accountMetainfo()
          return (0, l.getCurrency)(t, !0) || 'USD'
        }
        orders() {
          return (0, r.ensureNotNull)(this.activeBroker()).orders()
        }
        find(e) {
          return this._activeOrders.get(e) || null
        }
        activeOrders() {
          return Array.from(this._activeOrders.values())
        }
        activeOrdersUpdated() {
          return this._activeOrderUpdate
        }
        activeOrdersRemoved() {
          return this._activeOrdersRemoved
        }
        orderRejected() {
          return this._ordersRejected
        }
        stopService() {
          this._clearOrders()
          ;(0, r.ensureNotNull)(this.activeBroker()).orderUpdate.unsubscribeAll(
            this,
          )
        }
        startService() {
          this._clearOrders(), this._requestOrders()
        }
        _clearOrders() {
          const e = Array.from(this._activeOrders.keys())
          this._activeOrders.clear(),
            this._existingOrdersIds.clear(),
            e.length > 0 && d.logNormal(`All orders removed, id's: ${e}`),
            this._activeOrdersRemoved.fire(e)
        }
        async _requestOrders() {
          const e = this.activeBroker()
          if (!e) return
          const t = await e.orders()
          for (const e of t) this._addActiveOrder(e)
          e.orderUpdate.unsubscribeAll(this),
            e.orderUpdate.subscribe(this, this._addActiveOrder)
        }
        _addActiveOrder(e) {
          this._logOrderUpdate(e)
          const t = e.id,
            i = this._activeOrders.has(t),
            r = 5 === e.status,
            s = 6 !== e.status && 3 !== e.status,
            o = 2 === e.type
          if (i) {
            if (s || o)
              return (
                this._activeOrders.delete(t),
                void this._activeOrdersRemoved.fire([t])
              )
          } else {
            if (o || (s && !r)) return
            if (r) return void this._ordersRejected.fire(h(e))
          }
          const n = this._getOrderData(e)
          this._activeOrders.set(t, n), this._activeOrderUpdate.fire(n)
        }
        _logOrderUpdate(e) {
          const t = e.id
          let i = 'update'
          this._existingOrdersIds.has(t) ||
            ((i = 'add'), this._existingOrdersIds.add(t)),
            ((e, t) => {
              t(JSON.stringify(p(e)))
            })(e, (e) => {
              d.logNormal(`Order ${i}: ${e}`)
            })
        }
        _getOrderData(e) {
          const t = h(e)
          ;(0, o.isNumber)(t) || d.logError('order price is not defined')
          const i = (0, r.ensureNotNull)(this.activeBroker()).metainfo()
            .configFlags
          return (0, o.merge)((0, o.clone)(e), {
            price: t,
            considerFilledQty: !0,
            supportModify: (0, l.isModifyOrderSupported)(e, i),
            supportMove: (0, l.isMoveOrderSupported)(e, i),
            supportCancel: !0,
            supportModifyOrderPrice: Boolean(i.supportModifyOrderPrice),
            supportTrailingStop: (0, c.checkTrailingStopAvailability)(i),
          })
        }
      }
    },
    583705: (e, t, i) => {
      i.d(t, {
        PositionsService: () => h,
        PositionsUpdateType: () => d,
        cropPositionData: () => u,
      })
      var r = i(650151),
        s = i(466052),
        o = i(372605),
        n = i(6835),
        a = i(481853),
        l = i(397728)
      const c = (0, n.getLogger)('Trading.PositionService')
      var d
      function u(e) {
        const t = e
        return {
          id: t.id,
          symbol: t.symbol,
          side: t.side,
          avgPrice: t.avgPrice,
          pl: t.pl,
          price: t.price,
          qtyBySide: t.qtyBySide,
          stopType: t.stopType,
          takeProfit: t.takeProfit,
          stopLoss: t.stopLoss,
          trailingStopPips: t.trailingStopPips,
        }
      }
      !((e) => {
        ;(e[(e.Full = 0)] = 'Full'), (e[(e.Partial = 1)] = 'Partial')
      })(d || (d = {}))
      class h extends a.BrokerService {
        constructor() {
          super(...arguments),
            (this._existingPositionIds = new Set()),
            (this._positions = new Map()),
            (this._positionUpdate = new s.Delegate()),
            (this._positionsRemoved = new s.Delegate()),
            (this._displayMode = 1),
            (this._updatePositionPLHandler = this._updatePositionPL.bind(this))
        }
        destroy() {
          this.stopService()
        }
        positions() {
          return Array.from(this._positions.values())
        }
        find(e) {
          return this._positions.get(e) || null
        }
        async realIdFromBroker(e) {
          const t = (0, r.ensureNotNull)(this.activeBroker())
          if (1 === this._displayMode) {
            const i = await t.positionById(e)
            if (void 0 !== i) return i.id
          } else {
            const i = await t.individualPositionById(e)
            if (void 0 !== i) return i.id
          }
          return null
        }
        positionUpdate() {
          return this._positionUpdate
        }
        positionsRemoved() {
          return this._positionsRemoved
        }
        isDisplayModeIndividualPositions() {
          return 0 === this._displayMode
        }
        async getCurrency(e) {
          return (
            (await (0, r.ensureNotNull)(
              this.activeBroker(),
            ).getPositionCurrency(e)) || ''
          )
        }
        supportBrackets(e) {
          return Boolean(
            this.isDisplayModeIndividualPositions()
              ? e.supportIndividualPositionBrackets
              : e.supportPositionBrackets,
          )
        }
        supportReverse(e) {
          return Boolean(
            !this.isDisplayModeIndividualPositions() &&
              e.supportReversePosition,
          )
        }
        stopService() {
          this._clearPositions()
          const e = (0, r.ensureNotNull)(this.activeBroker())
          this.isDisplayModeIndividualPositions()
            ? e.individualPositionUpdate.unsubscribeAll(this)
            : e.positionUpdate.unsubscribeAll(this)
        }
        startService() {
          this._clearPositions(),
            (this._displayMode = ((e) => {
              if (null === e) return 1
              const t = e.metainfo().configFlags
              return t.supportPositionNetting
                ? t.supportPositionBrackets
                  ? 1
                  : t.supportCloseIndividualPosition
                    ? 0
                    : 1
                : 1
            })(this.activeBroker())),
            this._requestPositions()
        }
        _clearPositions() {
          const e = (0, r.ensureNotNull)(this.activeBroker()),
            t = Array.from(this._positions.keys())
          for (const i of t)
            this.isDisplayModeIndividualPositions()
              ? e.unsubscribeIndividualPositionPL(
                  i,
                  this._updatePositionPLHandler,
                )
              : e.unsubscribePL(i, this._updatePositionPLHandler)
          this._positions.clear(),
            this._existingPositionIds.clear(),
            t.length > 0 && c.logNormal(`All positions removed, id's: ${t}`),
            this._positionsRemoved.fire(t)
        }
        async _requestPositions() {
          const e = this.activeBroker()
          if (!e) return
          const t = this.isDisplayModeIndividualPositions(),
            i = await (t ? e.individualPositions() : e.positions())
          for (const e of i) this._addPosition(e)
          t
            ? e.individualPositionUpdate.subscribe(this, this._addPosition)
            : e.positionUpdate.subscribe(this, this._addPosition)
        }
        _addPosition(e) {
          const t = e.id,
            i = this._positions.has(t),
            s = (0, r.ensureNotNull)(this.activeBroker()),
            o = this.isDisplayModeIndividualPositions()
          if (!e.qty)
            return (
              i &&
                (o
                  ? s.unsubscribeIndividualPositionPL(
                      t,
                      this._updatePositionPLHandler,
                    )
                  : s.unsubscribePL(t, this._updatePositionPLHandler),
                this._positions.delete(t),
                this._positionsRemoved.fire([t])),
              void this._logPositionUpdate(e, !0)
            )
          const n = this._getPositionData(e),
            a = this._updateType(n)
          this._logPositionUpdate(n, a === d.Full),
            this._positions.set(t, n),
            this._firePositionUpdate(n, a),
            i ||
              (o
                ? s.subscribeIndividualPositionPL(
                    t,
                    this._updatePositionPLHandler,
                  )
                : s.subscribePL(t, this._updatePositionPLHandler))
        }
        _updatePositionPL(e, t) {
          const i = (0, r.ensureDefined)(this._positions.get(e))
          ;(i.pl = (0, o.isNumber)(t) ? t : null),
            this._firePositionUpdate(i, d.Partial)
        }
        _getPositionData(e) {
          var t, i
          const s = (0, r.ensureNotNull)(this.activeBroker()).metainfo()
              .configFlags,
            o = this._positions.get(e.id),
            n = this.isDisplayModeIndividualPositions(),
            a = Boolean(
              n
                ? s.supportIndividualPositionBrackets
                : s.supportPositionBrackets,
            )
          let c,
            d = !1,
            u = null
          if (n) {
            const t = e
            ;(c = t.price), (d = Boolean(t.canBeClosed))
          } else {
            const r = e
            ;(c = r.avgPrice),
              (u =
                null !==
                  (i =
                    null !== (t = r.pl) && void 0 !== t
                      ? t
                      : null == o
                        ? void 0
                        : o.pl) && void 0 !== i
                  ? i
                  : null)
          }
          return {
            ...e,
            pl: u,
            plBasedOnLast: s.calculatePLUsingLast || !1,
            price: Math.abs((0, r.ensureDefined)(c)),
            qtyBySide: Math.abs(e.qty) * (1 === e.side ? 1 : -1),
            supportClose: Boolean(
              n
                ? s.supportCloseIndividualPosition && d
                : s.supportClosePosition,
            ),
            supportReverse: Boolean(!n && s.supportReversePosition),
            supportBrackets: a,
            supportOnlyPairBrackets: Boolean(s.supportOnlyPairPositionBrackets),
            supportTrailingStop: (0, l.checkTrailingStopAvailability)(s),
          }
        }
        _firePositionUpdate(e, t) {
          this._positionUpdate.fire({ data: e, type: t })
        }
        _updateType(e) {
          const t = this._positions.get(e.id)
          if (void 0 === t) return d.Full
          for (const i of Object.keys(t)) {
            const r = i
            if ('pl' !== r && 'unrealizedPl' !== r && t[r] !== e[r])
              return d.Full
          }
          return d.Partial
        }
        _logPositionUpdate(e, t) {
          if (!t) return
          const i = e.id
          let r = 'update'
          this._existingPositionIds.has(i) ||
            ((r = 'add'), this._existingPositionIds.add(i)),
            ((e, t) => {
              t(JSON.stringify(u(e)))
            })(e, (e) => {
              c.logNormal(`Position  ${r}: ${e}`)
            })
        }
      }
    },
    397728: (e, t, i) => {
      function r(e) {
        return Boolean(
          e.supportTrailingStop && e.supportAddBracketsToExistingOrder,
        )
      }
      function s(e, t, i = !0) {
        switch (
          ((e, t = !0) => {
            const i = null != e ? e : 0,
              r = t ? Math.round(100 * i) / 100 : i
            return r > 0 ? 'positive' : r < 0 ? 'negative' : 'neutral'
          })(t, i)
        ) {
          case 'negative':
            return e.negativePlColor
          case 'positive':
            return e.positivePlColor
          default:
            return e.text.textColor
        }
      }
      i.d(t, {
        checkTrailingStopAvailability: () => r,
        profitLossTextColor: () => s,
      })
    },
    75577: (e, t, i) => {
      i.d(t, { TradingLayoutBreakpoint: () => s })
      var r = i(312282)
      const s = { Mobile: r.mobile }
    },
    974945: (e, t, i) => {
      i.r(t), i.d(t, { Trading: () => Qi, showSellBuyButtonsDefault: () => $i })
      var r = i(650151),
        s = i(609838),
        o = i(870122),
        n = i(376202),
        a = i(180185),
        l = i(69111),
        c = i(6835),
        d = i(650802)
      const u = i.p + 'alarm_clock.ba219c712b5dce956b08.mp3',
        h = (0, c.getLogger)('Lib.Sound', { color: '#dea433' }),
        p = 'notification/notification',
        g = [
          {
            title: s.t(null, void 0, i(792586)),
            path: 'alert/alarm_clock',
            soundForAlerts: !0,
            filePath: u,
          },
        ]
      const m = {}
      function _() {
        return g.filter((e) => !!e.soundForAlerts)
      }
      function b(e) {
        if ((0, l.isOnMobileAppPage)('any')) return
        if (!e) return
        if (
          !/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(
            window.navigator.userAgent,
          )
        )
          return
        if (
          (Array.isArray(e) || (e = [e]),
          0 ===
            (e = e.filter((e) => {
              const t = v(e)
              return (
                !(!t || !t.el.load || t._mobilePreloadActive) &&
                ((t._mobilePreloadActive = !0), !0)
              )
            })).length)
        )
          return void h.logNormal('enableForMobile no sounds passed')
        const t = () => {
            const r = []
            Array.isArray(e) &&
              e.forEach((e) => {
                const t = v(e)
                t.el.load()
                const i = t.play().catch((e) => {
                  if ('AbortError' !== e.name)
                    throw (
                      (h.logError(
                        `enableForMobile for "${t.el.src}" preload error: - ${e.message}`,
                      ),
                      e)
                    )
                })
                t.el.pause(), r.push(i)
              }),
              Promise.all(r).then(() => {
                h.logNormal('enableForMobile sounds initialized')
              }),
              i.forEach((e) => {
                document.removeEventListener(e, t, !0)
              })
          },
          i = ['click', 'touchend', 'keydown']
        i.forEach((e) => {
          document.addEventListener(e, t, !0)
        })
      }
      const v = (e) => {
        if (e in m) return m[e]
        h.logNormal(
          `requested sound  ${e} not cached, building a new audio element`,
        )
        const t = g.find((t) => t.path === e)
        if (void 0 === t) throw new Error(`Cannot find sound "${e}"`)
        const i = new Audio(t.filePath),
          r = {
            el: i,
            playing: new d.WatchedValue(!1),
            play: (t = 0) =>
              r.playing.value()
                ? (h.logNormal('sound already playing'),
                  Promise.reject('already playing'))
                : (r.playing.setValue(!0),
                  new Promise((i, s) => {
                    let o = t > 0
                    const n = () => {
                      const t = ((e) => {
                        try {
                          h.logNormal(
                            `"${e.el.src}" triggering html5 play method, readyState - ${e.el.readyState}; muted - ${e.el.muted}; volume - ${e.el.volume}; currentTime - ${e.el.currentTime}`,
                          )
                          let t = e.el.play()
                          return t || (t = Promise.resolve()), t
                        } catch (t) {
                          return (
                            h.logError(
                              `play method for "${e.el.src}" catch error - ${t.message}`,
                            ),
                            Promise.reject(t)
                          )
                        }
                      })(r)
                      t.catch((t) => {
                        h.logNormal(
                          `stop counting sound "${e}"; as playing due to an error: ${t.message}`,
                        ),
                          r.stop(),
                          s(t)
                      })
                    }
                    ;(r._onEnded = () => {
                      o ? n() : (r.stop(), i())
                    }),
                      r.el.addEventListener('ended', r._onEnded),
                      o &&
                        setTimeout(() => {
                          h.logNormal(`"${e}" repeat timeout - ${t}s off`),
                            (o = !1)
                        }, 1e3 * t),
                      n()
                  })),
            stop: (e = !1) => {
              r.el.pause(),
                e && (r.el.currentTime = 0),
                r.playing.setValue(!1),
                r._onEnded && r.el.removeEventListener('ended', r._onEnded)
            },
          }
        m[e] = r
        return (
          ['canplaythrough', 'error'].forEach((t) => {
            i.addEventListener(
              t,
              () => {
                h.logNormal(`for sound "${e}", event - ${t} is fired`)
              },
              !1,
            )
          }),
          h.logNormal(`canPlayType - ${i.canPlayType('audio/mp3')}`),
          m[e]
        )
      }
      b(g.filter((e) => !!e.common).map((e) => e.path))
      var y = i(150335),
        f = i(947488),
        k = i(323002),
        S = i(997345),
        P = i(586639),
        C = i(275734),
        w = i(757604),
        B = i(958261),
        T = i(114501),
        E = i(839874),
        O = i(196573),
        D = i(423869),
        I = i(656846),
        x = i(481330),
        M = i(391664),
        A = i(807107),
        N = i(637401),
        L = i(350299),
        V = i(340794),
        R = i(156963),
        F = i(330012),
        W = i(144273),
        q = i(466052),
        U = i(642469)
      var z = i(148442),
        $ = i(768819),
        H = i(758094),
        Q = i(326285),
        j = i(322625),
        K = i(34694),
        G = i(511990)
      const Z = (0, c.getLogger)('Trading.RealtimeProvider')
      class J {
        constructor(e) {
          ;(this._results = {}), (this._getter = e)
        }
        get(e) {
          return (
            this._results[e] || (this._results[e] = this._getter(e)),
            this._results[e]
          )
        }
      }
      class X {
        constructor(e) {
          ;(this._stopped = !1),
            (this._subscribed = !1),
            (this._provider = null),
            (this._formatters = null)
          const {
            symbol: t,
            callback: i,
            providersCache: r,
            formattersCache: s,
            subscriptionType: o,
            actualSymbolGetter: n,
          } = e
          ;(this._symbol = t),
            (this._subscriptionType = o),
            (this._callback = i),
            (this._providersCache = r),
            (this._formattersCache = s),
            (this._getActualSymbol = n),
            'Realtime' === this._subscriptionType
              ? (this._handler = (e, t) => {
                  this._stopped || i(e, t, this._formatters)
                })
              : (this._handler = (e, t) => {
                  this._stopped || i(e, t)
                }),
            this._start().catch((e) => {})
        }
        symbol() {
          return this._symbol
        }
        type() {
          return this._subscriptionType
        }
        callback() {
          return this._callback
        }
        destroy() {
          this._ensureNotStopped(),
            this._subscribed &&
              void 0 !== this._actualSymbol &&
              ('Realtime' === this._subscriptionType
                ? (0, r.ensureNotNull)(this._provider).unsubscribeRealtime(
                    this._actualSymbol,
                    this._handler,
                  )
                : (0, r.ensureNotNull)(this._provider).unsubscribeDOM(
                    this._actualSymbol,
                    this._handler,
                  )),
            (this._stopped = !0)
        }
        async _start() {
          const { symbol: e } = await this._getActualSymbol(this._symbol)
          this._ensureNotStopped(),
            (this._provider = await this._providersCache.get(e)),
            this._ensureNotStopped(),
            (this._formatters = await this._formattersCache.get(e)),
            (0, r.ensure)(this._formatters),
            this._ensureNotStopped(),
            (this._actualSymbol = e),
            (this._subscribed = !0),
            'Realtime' === this._subscriptionType
              ? this._provider.subscribeRealtime(e, this._handler)
              : this._provider.subscribeDOM(e, this._handler)
        }
        _ensureNotStopped() {
          ;(0, r.assert)(!this._stopped, 'Should not be stopped')
        }
      }
      class Y {
        constructor(e, t, i, r) {
          ;(this.onStatusChanged = new q.Delegate()),
            (this._subscriptions = []),
            (this._currentBroker = null),
            (this._activeBrokerGetter = e),
            (this._actualSymbolGetter = r),
            t.subscribe(this, this._connectionStatusChanged),
            i.subscribe(this, this._connectionStatusChanged),
            (this._tvProvider = new K.BrokerRealtimeAdapter(
              'RealtimeProvider',
            )),
            this._connectionStatusChanged()
        }
        isTradable(e) {
          return this._tradableCache.get(e)
        }
        subscribeRealtime(e, t) {
          this._subscriptions.some(
            (i) =>
              i.symbol() === e && i.callback() === t && 'Realtime' === i.type(),
          ) ||
            this._subscriptions.push(
              new X({
                symbol: e,
                callback: t,
                providersCache: this._providersCache,
                formattersCache: this._formattersCache,
                subscriptionType: 'Realtime',
                actualSymbolGetter: this._actualSymbolGetter,
              }),
            )
        }
        unsubscribeRealtime(e, t) {
          const i = this._subscriptions.findIndex(
            (i) =>
              i.symbol() === e && i.callback() === t && 'Realtime' === i.type(),
          )
          if (-1 === i) return
          this._subscriptions[i].destroy(), this._subscriptions.splice(i, 1)
        }
        subscribeDOM(e, t) {
          this._subscriptions.some(
            (i) => i.symbol() === e && i.callback() === t && 'DOM' === i.type(),
          ) ||
            this._subscriptions.push(
              new X({
                symbol: e,
                callback: t,
                providersCache: this._providersCache,
                formattersCache: this._formattersCache,
                subscriptionType: 'DOM',
                actualSymbolGetter: this._actualSymbolGetter,
              }),
            )
        }
        unsubscribeDOM(e, t) {
          const i = this._subscriptions.findIndex(
            (i) => i.symbol() === e && i.callback() === t && 'DOM' === i.type(),
          )
          if (-1 === i) return void Z.logWarn('Subscription not found')
          this._subscriptions[i].destroy(), this._subscriptions.splice(i, 1)
        }
        formatter(e) {
          return this._formattersCache.get(e).then((e) => e.formatter)
        }
        spreadFormatter(e) {
          return this._formattersCache.get(e).then((e) => e.spreadFormatter)
        }
        quantityFormatter(e) {
          return this._formattersCache.get(e).then((e) => e.quantityFormatter)
        }
        symbolInfo(e) {
          if (!e) {
            const e = {
              minTick: Number.NaN,
              qty: { min: Number.NaN, max: Number.NaN, step: Number.NaN },
              pipValue: Number.NaN,
              pipSize: Number.NaN,
              description: 'no symbol',
            }
            return Promise.resolve(e)
          }
          return this._providersCache.get(e).then((t) =>
            t !== this._tvProvider
              ? t
                  .symbolInfo(e)
                  .then((t) => t || this._tvProvider.symbolInfo(e))
                  .catch((t) => this._tvProvider.symbolInfo(e))
              : this._tvProvider.symbolInfo(e),
          )
        }
        quotesSnapshot(e) {
          return this._providersCache.get(e).then((t) => t.quotesSnapshot(e))
        }
        activeBroker() {
          return null !== this._currentBroker &&
            this._currentBroker !== this._tvProvider
            ? this._currentBroker
            : null
        }
        _isTradable(e) {
          if (
            null === this._currentBroker ||
            this._currentBroker === this._tvProvider
          )
            return Promise.resolve({ tradable: !1 })
          try {
            return (0, G.makeTimeLimited)(
              this._currentBroker.isTradable(e),
              6e4,
              'isTradable Promise Timeout',
            ).catch(() => Promise.resolve({ tradable: !1 }))
          } catch (e) {
            return Promise.resolve({ tradable: !1 })
          }
        }
        _haveRealtime(e) {
          return (
            this._tradableCache.get(e) ||
            Promise.resolve(null === this._currentBroker)
          )
        }
        _connectionStatusChanged() {
          const e = this._activeBrokerGetter(),
            t = this._currentBroker,
            i = e && 1 === e.connectionStatus() ? e : null
          if ((this._createCaches(), t !== i)) {
            const e = this._subscriptions.map((e) => ({
              symbol: e.symbol(),
              callback: e.callback(),
              type: e.type(),
            }))
            this._unsubscribeAll(),
              (this._currentBroker = i),
              this._subscribeAll(e),
              this.onStatusChanged.fire()
          }
        }
        _createCaches() {
          ;(this._providersCache = new J((e) => this._provider(e))),
            (this._tradableCache = new J((e) => this._isTradable(e))),
            (this._formattersCache = new J((e) =>
              this._providersCache
                .get(e)
                .then((t) =>
                  Promise.all([
                    t.formatter(e, !1),
                    t.spreadFormatter(e),
                    t.quantityFormatter(e),
                  ]),
                )
                .then(([e, t, i]) => ({
                  formatter: e,
                  spreadFormatter: t,
                  quantityFormatter: i,
                })),
            ))
        }
        _provider(e) {
          return R.enabled('enable_dom_data_for_untradable_symbols')
            ? Promise.resolve(this._currentBroker || this._tvProvider)
            : this._haveRealtime(e).then((e) =>
                e.tradable &&
                this._currentBroker &&
                1 === this._currentBroker.connectionStatus()
                  ? this._currentBroker
                  : this._tvProvider,
              )
        }
        _unsubscribeAll() {
          this._subscriptions.forEach((e) => {
            e.destroy()
          }),
            (this._subscriptions = [])
        }
        _subscribeAll(e) {
          e.forEach((e) => {
            this._subscriptions.push(
              new X({
                symbol: e.symbol,
                callback: e.callback,
                providersCache: this._providersCache,
                formattersCache: this._formattersCache,
                subscriptionType: e.type,
                actualSymbolGetter: this._actualSymbolGetter,
              }),
            )
          })
        }
      }
      var ee = i(481853)
      class te extends ee.BrokerService {
        constructor(e) {
          super(e),
            (this._userId = (window.user.id || '').toString()),
            window.loginStateChange &&
              window.loginStateChange.subscribe(this, this._onLoginStateChange)
        }
        trackOrderPlaced(e) {
          this._trackOrderEvent('Placed', e)
        }
        trackOrderModified(e) {
          this._trackOrderEvent('Modified', e)
        }
        startService() {
          ;(0, r.ensure)(this.activeBroker()).orderUpdate.subscribe(
            this,
            this._orderUpdate,
          ),
            this._trackTradingBrokerConnnected()
        }
        stopService() {
          ;(0, r.ensure)(this.activeBroker()).orderUpdate.unsubscribe(
            this,
            this._orderUpdate,
          )
        }
        _orderUpdate(e, t) {
          t ||
            (5 === e.status
              ? this._trackOrderEvent('Rejected', e)
              : 2 === e.status
                ? this._trackOrderEvent('Executed', e)
                : 1 === e.status && this._trackOrderEvent('Canceled', e))
        }
        async _trackOrderEvent(e, t) {
          var i
          const r = this.trading().linking().value(),
            s = this.activeBroker()
          if (void 0 === t || null === s) return
          const o = await s.symbolInfo(t.symbol),
            n = t.qty * (o.lotSize || 1),
            a =
              'Placed' === e && void 0 !== r.continuous && r.symbol === t.symbol
                ? 'continuous'
                : o.type,
            l = {
              amount: n,
              orderId: t.id,
              instrumentType: a,
              eventName: 'Order ' + e,
              userId: this._userId,
              symbol: t.symbol,
              currency: null !== (i = o.currency) && void 0 !== i ? i : null,
            }
          this._trackTradingOrder(l)
        }
        _trackTradingOrder(e) {
          const t = this.activeBroker()
          if (!t) throw new Error('no active broker')
        }
        _trackTradingBrokerConnnected() {
          const e = this.activeBroker()
          null !== e && e.metainfo().id
          if (!e) throw new Error('no active broker')
        }
        _onLoginStateChange() {
          this._userId = (window.user.id || '').toString()
        }
      }
      var ie = i(863697),
        re = i(106056),
        se = i(32133)
      function oe(e = 'default') {
        switch (e) {
          case 'danger':
            return ie.ToastIntent.Danger
          case 'attention':
            return ie.ToastIntent.Warning
          case 'success':
            return ie.ToastIntent.Success
          default:
            return ie.ToastIntent.Default
        }
      }
      class ne {
        constructor(e) {
          this._chartWidgetCollection = e
        }
        showTradingProperties() {
          this._chartWidgetCollection.activeChartWidget
            .value()
            .showGeneralChartProperties(U.TabNames.trading)
        }
        async closeAllNotifications() {
          const e = await this._chartWidgetCollection.getToasts()
          null !== e && e.reset()
        }
        async showNotification(e, t, i, r) {
          const s = await this._chartWidgetCollection.getToasts()
          if (null === s) return
          let o = ''
          'string' == typeof t && (o = t),
            s.showSimpleToast({
              text: o,
              time: r,
              title: e,
              intent: oe(i),
              priority: re.ToastPriority.Low,
            })
        }
        showMaintenance(e) {
          0
        }
        showBrokerSideMaintenance(e) {
          0
        }
        trackEvent(e, t, i) {
          !(async (e, t, i) => {
            ;(0, se.trackEvent)(e, t, i)
          })(e, t, i)
        }
        showReplayConfirmationDialog() {
          return Promise.resolve()
        }
        reconnectChartApi(e) {
          0
        }
        setBroker(e) {
          const t =
            (null == e ? void 0 : e.metainfo().backendBrokerName) ||
            (null == e ? void 0 : e.metainfo().id.toLowerCase()) ||
            ''
          this._chartWidgetCollection.setBroker(t)
        }
      }
      var ae = i(822914),
        le = (i(336379), i(156115))
      async function ce(e) {
        const {
          showErrorNotification: t,
          handler: r,
          message: o,
          onOpen: n,
          onClose: a,
          abortSignal: l,
        } = e
        if (
          !(await (0, le.showConfirmDialog)({
            title: s.t(null, void 0, i(424356)),
            content: o,
            mainButtonText: s.t(null, void 0, i(424356)),
            cancelButtonText: s.t(null, void 0, i(620036)),
            onOpen: n,
            onClose: a,
            abortSignal: l,
            showErrorNotification: t,
          }))
        )
          return !1
        try {
          return await r()
        } catch (e) {
          return (
            t(
              s.t(null, void 0, i(791401)),
              ((e) => {
                let t = ''
                null !== e && 'object' == typeof e && e.message
                  ? (t = e.message)
                  : 'string' == typeof e && (t = e)
                return t
              })(e),
            ),
            !1
          )
        }
      }
      var de = i(66786),
        ue = i(120283),
        he = i(314996)
      i(651049), i(702054), i(529719), i(627687), i(816105)
      async function pe(e, t, r, o) {
        const n = await (async (e, t) => {
          const { PartiallyClosingDialogRenderer: r } = await i
              .e(3168)
              .then(i.bind(i, 531570)),
            s = new r()
          return new Promise((i, r) => {
            ;(null == t ? void 0 : t.aborted)
              ? i({ status: !1 })
              : (s.open({ ...e, dialogActionHandler: i }),
                null == t ||
                  t.addEventListener(
                    'abort',
                    () => {
                      s.close(), i({ status: !1 })
                    },
                    { once: !0 },
                  ))
          })
        })(e, o)
        if (!n.status) return !1
        try {
          return await t(n.qty)
        } catch (e) {
          return (
            r(
              s.t(null, void 0, i(791401)),
              ((e) => {
                let t = ''
                null !== e && 'object' == typeof e && e.message
                  ? (t = e.message)
                  : 'string' == typeof e && (t = e)
                return t
              })(e),
            ),
            !1
          )
        }
      }
      var ge = i(252546)
      const me = {
          async show(e) {
            const t = s.t(null, { replace: { symbol: e } }, i(97929)),
              r = s.t(null, { replace: { symbol: e } }, i(469497))
            return (0, ge.showSimpleConfirmDialog)({ title: r, text: t })
          },
        },
        _e = {
          async show(e) {
            const t = s.t(null, { replace: { symbol: e } }, i(965603)),
              r = s.t(null, { replace: { symbol: e } }, i(447600))
            return (0, ge.showSimpleConfirmDialog)({ title: r, text: t })
          },
        }
      var be = i(50959),
        ve = i(793361)
      function ye(e) {
        const {
            symbol: t,
            side: r,
            qty: o,
            price: n,
            id: a,
            closePositionCancelsOrders: l,
          } = e,
          c = (0, ve.splitThousands)(o, ' '),
          d = (0, ve.splitThousands)(n, ' ')
        return be.createElement(
          be.Fragment,
          null,
          be.createElement(
            'div',
            null,
            void 0 !== a
              ? s.t(null, void 0, i(170392)).replace('{id}', a)
              : s.t(null, void 0, i(381617)),
          ),
          be.createElement('div', null, be.createElement('b', null, t)),
          be.createElement(
            'div',
            null,
            be.createElement('b', null, `${r} ${c} @ ${d}`),
          ),
          be.createElement(
            'div',
            null,
            l && ` ${s.t(null, void 0, i(218329))}`,
          ),
        )
      }
      var fe = i(484095)
      const ke = (0, c.getLogger)('Trading.BrokerCommandsUI'),
        Se = { symbol: 1, qty: 1, side: 1, type: 1, seenPrice: 1 }
      class Pe {
        constructor({
          activeBroker: e,
          guiAccessor: t,
          noConfirmEnabled: i,
          orderViewController: r,
          showErrorNotification: s,
          trackEvent: o,
          tradingLinking: n,
          abortSignalGetter: a,
        }) {
          ;(this._closePositionDialogVisibility = new $.DialogVisibility()),
            (this._isClosePositionDialogLoading = !1),
            (this._isCloseIndividualPositionDialogLoading = !1),
            (this._onClosePositionDialogOpen = (e) => {
              this._closePositionDialogVisibility.setValue({
                isVisible: !0,
                isFullScreen: e,
              })
            }),
            (this._onClosePositionDialogClose = () => {
              this._closePositionDialogVisibility.setValue({
                isVisible: !1,
              })
            }),
            (this._tradingLinking = n),
            (this._activeBroker = e),
            (this._guiAccessor = t),
            (this._orderViewController = r),
            (this._showErrorNotification = s),
            (this._noConfirmEnabled = i),
            (this._trackEvent = o),
            (this._getAbortSignal = a),
            (this.closePositionDialogVisibility =
              this._closePositionDialogVisibility.value$)
        }
        async placeOrder(e, t, i) {
          const r = t && this._noConfirmEnabled.value(),
            s =
              this._guiAccessor && r
                ? this._guiAccessor.showReplayConfirmationDialog()
                : Promise.resolve(!1)
          try {
            await s
          } catch (e) {
            Promise.resolve(!1)
          }
          const o = await this._activeBroker.isTradable(e.symbol)
          if (
            !(
              r &&
              o.tradable &&
              ((e) => {
                for (const t in Se) if (!(t in e)) return !1
                return !0
              })(e)
            )
          ) {
            {
              const t = this._activeBroker.metainfo()
              if (t.customUI && void 0 !== t.customUI.showOrderDialog)
                return t.customUI.showOrderDialog(e)
            }
            return this._orderViewController().then((t) =>
              this._activeBroker
                ? t.showOrderView({
                    order: e,
                    focus: void 0,
                    forceOrderDialog: i,
                  })
                : Promise.reject('Broker connection adapter is null'),
            )
          }
          {
            const t = await this._activeBroker.createPlaceOrderContext(
              e,
              'instant',
              !1,
            )
            try {
              return await t.send()
            } finally {
              t.destroy()
            }
          }
        }
        async modifyOrder(e, t, i, r) {
          if (t && this._noConfirmEnabled.value() && 1 === e.parentType) {
            const t = await this._activeBroker.createEditOrderContext(
              e,
              'instant',
            )
            try {
              return await t.send()
            } finally {
              t.destroy()
            }
          }
          return this._modifyOrder(e, t, i, r)
        }
        async closePosition(e) {
          var t, i
          if (
            (this._makeSureBrokerIsConnected(),
            this._isClosePositionDialogLoading)
          )
            return !1
          let r, s
          this._isClosePositionDialogLoading = !0
          try {
            if (((r = await this._activeBroker.positionById(e)), void 0 === r))
              return !1
            const { tradable: t } = await this._activeBroker.isTradable(
              r.symbol,
            )
            if ((await this._assertPositionExistsAndNotClosed(r.id), !t))
              return this._closePositionForNonTradableSymbol(r)
            if (this._noConfirmEnabled.value())
              return this._activeBroker.closePosition(e)
            s = await this._obtainPositionClosingData(r)
          } finally {
            this._isClosePositionDialogLoading = !1
          }
          if (void 0 === s) return !1
          const { supportPartialClosePosition: o, ...n } = s,
            a = this._activeBroker.metainfo()
          if (
            void 0 !==
            (null === (t = a.customUI) || void 0 === t
              ? void 0
              : t.showClosePositionDialog)
          )
            return null === (i = a.customUI) || void 0 === i
              ? void 0
              : i.showClosePositionDialog(r)
          if (o) {
            const t = (t) => (
              t !== (null == r ? void 0 : r.qty)
                ? this._trackEvent('', 'Close Position Dialog', 'partial')
                : this._trackEvent('', 'Close Position Dialog', 'full'),
              this._activeBroker.closePosition(e, t)
            )
            return pe(
              {
                ...n,
                positionOrIndividualPosition: r,
                onOpen: this._onClosePositionDialogOpen,
                onClose: this._onClosePositionDialogClose,
              },
              t,
              this._showErrorNotification,
              this._getAbortSignal(),
            )
          }
          {
            const t = () => this._activeBroker.closePosition(e)
            return ce({
              showErrorNotification: this._showErrorNotification,
              handler: t,
              message: s.message,
              onOpen: this._onClosePositionDialogOpen,
              onClose: this._onClosePositionDialogClose,
              abortSignal: this._getAbortSignal(),
            })
          }
        }
        async closeIndividualPosition(e) {
          if (
            (this._makeSureBrokerIsConnected(),
            (0, r.assert)(
              !!this._activeBroker.config.supportPositionNetting,
              'Broker doesn`t support individual positions',
            ),
            this._noConfirmEnabled.value())
          )
            return this._activeBroker.closeIndividualPosition(e)
          {
            if (this._isCloseIndividualPositionDialogLoading) return !1
            const t = await this._obtainIndividualPositionClosingData(e)
            if (void 0 === t) return !1
            const {
              supportPartialCloseIndividualPosition: i,
              individualPosition: r,
              ...s
            } = t
            if (i) {
              const t = async (t) => (
                t !== r.qty
                  ? this._trackEvent(
                      '',
                      'Close Individual Position Dialog',
                      'partial',
                    )
                  : this._trackEvent(
                      '',
                      'Close Individual Position Dialog',
                      'full',
                    ),
                this._activeBroker.closeIndividualPosition(e, t)
              )
              return pe(
                {
                  ...s,
                  positionOrIndividualPosition: r,
                  onOpen: this._onClosePositionDialogOpen,
                  onClose: this._onClosePositionDialogClose,
                },
                t,
                this._showErrorNotification,
                this._getAbortSignal(),
              )
            }
            return ce({
              showErrorNotification: this._showErrorNotification,
              handler: () => this._activeBroker.closeIndividualPosition(e),
              message: t.message,
              onOpen: this._onClosePositionDialogOpen,
              onClose: this._onClosePositionDialogClose,
              abortSignal: this._getAbortSignal(),
            })
          }
        }
        editPositionBrackets(e, t, i, s) {
          return (
            this._makeSureBrokerIsConnected(),
            (0, r.assert)(
              !!this._activeBroker.config.supportPositionBrackets,
              'Broker doesn`t support brackets on positions',
            ),
            s && this._noConfirmEnabled.value()
              ? this._activeBroker.editPositionBrackets(e, null != t ? t : {})
              : this._activeBroker
                  .positionById(e)
                  .then((e) =>
                    this._activeBroker
                      ? this._showPositionDialog((0, r.ensureDefined)(e), t, i)
                      : Promise.reject('Broker connection adapter is null'),
                  )
          )
        }
        editIndividualPositionBrackets(e, t, i, s) {
          return s && this._noConfirmEnabled.value()
            ? this._activeBroker.editIndividualPositionBrackets(
                e,
                null != t ? t : {},
              )
            : this._activeBroker
                .individualPositionById(e)
                .then((e) =>
                  this._activeBroker
                    ? this._showIndividualPositionDialog(
                        (0, r.ensureDefined)(e),
                        t,
                        i,
                      )
                    : Promise.reject('Broker connection adapter is null'),
                )
        }
        reversePosition(e) {
          return (
            this._makeSureBrokerIsConnected(),
            this._activeBroker.metainfo().configFlags.supportMultiposition &&
            !this._activeBroker.config.supportNativeReversePosition
              ? Promise.reject(
                  'Cannot reverse position on multiposition acount',
                )
              : this._noConfirmEnabled.value()
                ? this._activeBroker.reversePosition(e)
                : this._activeBroker.positionById(e).then((t) => {
                    if (!this._activeBroker)
                      return Promise.reject('Broker connection adapter is null')
                    const i = this._activeBroker.reversePosition.bind(
                      this._activeBroker,
                      e,
                    )
                    return (0, de.reversePositionDialog)({
                      positionId: e,
                      showErrorNotification: this._showErrorNotification,
                      handler: i,
                      closePositionCancelsOrders:
                        this._activeBroker.config.closePositionCancelsOrders,
                      abortSignal: this._getAbortSignal(),
                    })
                  })
          )
        }
        async cancelOrder(e) {
          var t, i
          this._makeSureBrokerIsConnected()
          const r = await this._activeBroker.orderById(e)
          if (void 0 === r) return Promise.reject('Failed to find order')
          const { tradable: s } = await this._activeBroker.isTradable(r.symbol)
          if ((await this._assertOrderExistsAndNotCanceled(r.id), !s))
            return this._cancelOrderForNonTradableSymbol(r.symbol, r.id)
          if (this._noConfirmEnabled.value())
            return this._activeBroker.cancelOrder(e)
          {
            const s = this._activeBroker.cancelOrder.bind(
                this._activeBroker,
                e,
              ),
              o = this._activeBroker.metainfo()
            if (
              void 0 !==
              (null === (t = o.customUI) || void 0 === t
                ? void 0
                : t.showCancelOrderDialog)
            )
              return null === (i = o.customUI) || void 0 === i
                ? void 0
                : i.showCancelOrderDialog(r)
            if (r.parentId) {
              const e = (await this._activeBroker.orders()).filter(
                (e) => e.refNumber === r.refNumber,
              )
              return o.configFlags.supportCancellingBothBracketsOnly &&
                e.length > 1
                ? this._showCancelMultipleBracketsDialog(r.parentId, s)
                : this._showCancelBracketsDialog(r.id, s)
            }
            return this._showCancelOrderDialog(r.id, s)
          }
        }
        cancelOrders(e, t) {
          return (
            this._makeSureBrokerIsConnected(),
            this._activeBroker.orders().then((i) => {
              if (!this._activeBroker)
                return Promise.reject('Broker connection adapter is null')
              const r = i.filter(
                (i) =>
                  i.symbol === e &&
                  (!t || i.side === t) &&
                  ((e) => 4 === e.status || 3 === e.status || 6 === e.status)(
                    i,
                  ),
              )
              if (!r.length) return Promise.resolve(!1)
              if (1 === r.length) return this.cancelOrder(r[0].id)
              const s = r.map((e) => e.id)
              if (this._noConfirmEnabled.value())
                return this._activeBroker.cancelOrders(e, t, s)
              {
                const i = this._activeBroker.cancelOrders.bind(
                  this._activeBroker,
                )
                return this._showCancelMultipleOrdersDialog(e, t, s, i)
              }
            })
          )
        }
        async _modifyOrder(e, t, r, o) {
          const n = this._activeBroker.metainfo()
          if (
            (this._makeSureBrokerIsConnected(), e.flags && e.flags.trailingStop)
          )
            return (
              ke.logError('Attempt to modify trailing stop loss order' + e.id),
              this._showErrorNotification(
                s.t(null, void 0, i(292559)),
                s.t(null, void 0, i(507214)),
              ),
              Promise.resolve(!1)
            )
          await this._setSymbol(e.symbol)
          const a = await this._activeBroker.symbolInfo(e.symbol)
          if (
            ((e.limitPrice =
              void 0 !== a.limitPriceStep && void 0 !== e.limitPrice
                ? (0, N.roundToStepByPriceTypeAndSide)(
                    e.limitPrice,
                    a.limitPriceStep,
                    1,
                    e.side,
                  )
                : e.limitPrice),
            (e.stopPrice =
              void 0 !== a.stopPriceStep && void 0 !== e.stopPrice
                ? (0, N.roundToStepByPriceTypeAndSide)(
                    e.stopPrice,
                    a.stopPriceStep,
                    2,
                    e.side,
                  )
                : e.stopPrice),
            !n.configFlags.supportModifyTrailingStop)
          ) {
            const t = await this._activeBroker.orderById(e.id)
            e.hasTrailingStopBracket =
              void 0 !== (null == t ? void 0 : t.trailingStopPips)
          }
          const l = t && this._noConfirmEnabled.value()
          let c = r || (1 === e.type ? 1 : 2)
          if (e.parentId && !R.enabled('always_pass_called_order_to_modify')) {
            const t = await this._getParentOrderOrPosition(e)
            if (void 0 !== t) {
              c = r || (1 === e.type ? 3 : 4)
              const i = {
                takeProfit: e.limitPrice || t.takeProfit,
                trailingStopPips: e.trailingStopPips || t.trailingStopPips,
                stopLoss: e.stopPrice || t.stopLoss,
              }
              if (3 === e.parentType)
                return l
                  ? this._activeBroker.editIndividualPositionBrackets(t.id, i)
                  : this._showIndividualPositionDialog(t, i, c)
              if (2 === e.parentType && e.qty === Math.abs(t.qty))
                return l
                  ? this._activeBroker.editPositionBrackets(t.id, i)
                  : this._showPositionDialog(t, i, c)
              1 === e.parentType &&
                (0, x.isOrderActive)(t.status) &&
                (((e = (0, ae.default)(t)).takeProfit = i.takeProfit),
                (e.trailingStopPips = i.trailingStopPips),
                (e.stopLoss = i.stopLoss),
                (e.hasTrailingStopBracket = void 0 !== t.trailingStopPips))
            }
          }
          return l
            ? this._activeBroker.modifyOrder(e)
            : n.customUI && void 0 !== n.customUI.showOrderDialog
              ? n.customUI.showOrderDialog(e, c)
              : this._orderViewController().then((t) =>
                  this._activeBroker
                    ? t.showOrderView({
                        order: e,
                        focus: c,
                        forceOrderDialog: o,
                      })
                    : Promise.reject('Broker connection adapter is null'),
                )
        }
        async _setSymbol(e) {
          this._tradingLinking.value().symbol !== e &&
            (await this._tradingLinking.setSymbol(e))
        }
        _makeSureBrokerIsConnected() {
          ;(0, r.assert)(
            1 === this._activeBroker.connectionStatus(),
            'Broker is not connected',
          )
        }
        async _showPositionDialog(e, t = {}, r) {
          await this._setSymbol(e.symbol)
          const o = await this._activeBroker.isTradable(e.symbol)
          if (!o.tradable) {
            const t =
              void 0 !== o.reason
                ? o.reason
                : (0, N.makeNonTradableSymbolText)(
                    e.symbol,
                    this._activeBroker.metainfo().title,
                  )
            return (
              this._showErrorNotification(s.t(null, void 0, i(326704)), t),
              Promise.resolve(!1)
            )
          }
          {
            const i = this._activeBroker.metainfo()
            if (i.customUI && void 0 !== i.customUI.showPositionDialog)
              return i.customUI.showPositionDialog(
                e,
                {
                  stopLoss: t.stopLoss || e.stopLoss,
                  takeProfit: t.takeProfit || e.takeProfit,
                },
                r,
              )
          }
          return this._orderViewController().then((i) =>
            this._activeBroker
              ? i.showPositionView(
                  e,
                  {
                    stopLoss: t.stopLoss,
                    takeProfit: t.takeProfit,
                    trailingStopPips: t.trailingStopPips,
                  },
                  r || (e.limitPrice && 3) || (e.stopPrice && 4),
                )
              : Promise.reject('Broker connection adapter is null'),
          )
        }
        async _showIndividualPositionDialog(e, t = {}, i) {
          await this._setSymbol(e.symbol)
          {
            const r = this._activeBroker.metainfo()
            if (r.customUI && void 0 !== r.customUI.showPositionDialog)
              return r.customUI.showPositionDialog(
                e,
                {
                  stopLoss: t.stopLoss || e.stopLoss,
                  takeProfit: t.takeProfit || e.takeProfit,
                },
                i,
              )
          }
          return this._orderViewController().then((r) =>
            this._activeBroker
              ? r.showIndividualPositionView(
                  e,
                  {
                    stopLoss: t.stopLoss,
                    takeProfit: t.takeProfit,
                    trailingStopPips: t.trailingStopPips,
                  },
                  i || (e.limitPrice && 3) || (e.stopPrice && 4),
                )
              : Promise.reject('Broker connection adapter is null'),
          )
        }
        _isMaintenance() {
          return isFeatureEnabled(
            (0, x.makeMaintananceFeatureToggleName)(
              this._activeBroker.metainfo().id,
            ),
          )
        }
        _isBrokerSideMaintenance() {
          return isFeatureEnabled(
            (0, x.makeBrokerSideMaintananceFeatureToggleName)(
              this._activeBroker.metainfo().id,
            ),
          )
        }
        _showCancelOrderDialog(e, t) {
          return ue.ConfirmOrderCancelDialog.get()
            .open(e, this._getAbortSignal())
            .then((i) => (i ? t(e) : Promise.resolve(!1)))
        }
        _showCancelMultipleOrdersDialog(e, t, i, r) {
          const s = i.length
          return ue.ConfirmOrderCancelDialog.get()
            .multiple(e, t, s, this._getAbortSignal())
            .then((s) => (s ? r(e, t, i) : Promise.resolve(!1)))
        }
        async _showCancelBracketsDialog(e, t) {
          return he.ConfirmBracketsCancelDialog.get()
            .open(e, this._getAbortSignal())
            .then((i) => (i ? t(e) : Promise.resolve(!1)))
        }
        _showCancelMultipleBracketsDialog(e, t) {
          return he.ConfirmBracketsCancelDialog.get()
            .multiple(e, this._getAbortSignal())
            .then((i) => (i ? t(e) : Promise.resolve(!1)))
        }
        async _obtainPositionClosingData(e) {
          try {
            const {
                supportLots: t,
                qtyStep: r,
                uiQtyStep: o,
                minQty: n,
                qtyLabel: a,
                qtyFormatter: l,
                priceFormatter: c,
              } = await this._obtainPositionOrIndividualPositionClosingCommonData(
                e,
              ),
              d =
                this._activeBroker.metainfo().configFlags
                  .supportPartialClosePosition,
              u = ye({
                symbol: e.symbol,
                side:
                  1 === e.side
                    ? s.t(null, void 0, i(273064))
                    : s.t(null, void 0, i(777851)),
                qty: l.format(e.qty),
                price: c.format(e.avgPrice),
                closePositionCancelsOrders:
                  this._activeBroker.config.closePositionCancelsOrders,
              })
            return {
              position: e,
              supportLots: t,
              qtyStep: r,
              uiQtyStep: o,
              minQty: n,
              qtyLabel: a,
              supportPartialClosePosition: d,
              qtyFormatter: l,
              message: u,
            }
          } catch (e) {
            return
          }
        }
        async _obtainIndividualPositionClosingData(e) {
          try {
            this._isCloseIndividualPositionDialogLoading = !0
            const t = (0, r.ensureDefined)(
                await this._activeBroker.individualPositionById(e),
              ),
              {
                supportLots: o,
                qtyStep: n,
                uiQtyStep: a,
                minQty: l,
                qtyLabel: c,
                qtyFormatter: d,
                priceFormatter: u,
              } = await this._obtainPositionOrIndividualPositionClosingCommonData(
                t,
              ),
              h =
                this._activeBroker.metainfo().configFlags
                  .supportPartialCloseIndividualPosition,
              p = ye({
                symbol: t.symbol,
                side:
                  1 === t.side
                    ? s.t(null, void 0, i(273064))
                    : s.t(null, void 0, i(777851)),
                qty: d.format(t.qty),
                price: u.format(t.price),
                id: e,
                closePositionCancelsOrders:
                  this._activeBroker.config.closePositionCancelsOrders,
              })
            return (
              (this._isCloseIndividualPositionDialogLoading = !1),
              {
                individualPosition: t,
                supportLots: o,
                qtyStep: n,
                uiQtyStep: a,
                minQty: l,
                qtyLabel: c,
                supportPartialCloseIndividualPosition: h,
                qtyFormatter: d,
                message: p,
              }
            )
          } catch (e) {
            return void (this._isCloseIndividualPositionDialogLoading = !1)
          }
        }
        async _obtainPositionOrIndividualPositionClosingCommonData(e) {
          const t = await this._activeBroker.symbolInfo(e.symbol),
            i = void 0 !== t.lotSize,
            r = t.qty.step,
            s = t.qty.uiStep,
            o = t.qty.min,
            n = t.units
          return {
            supportLots: i,
            qtyStep: r,
            uiQtyStep: s,
            minQty: o,
            qtyFormatter: await this._activeBroker.quantityFormatter(e.symbol),
            priceFormatter: await this._activeBroker.formatter(e.symbol, !1),
            qtyLabel: n,
          }
        }
        async _closePositionForNonTradableSymbol(e) {
          const {
            supportClosePositionForNonTradableSymbol: t,
            supportClosePosition: r,
          } = this._activeBroker.metainfo().configFlags
          if (!t || !r) {
            const t = s.t(null, { replace: { symbol: e.symbol } }, i(946305))
            return (
              this._showErrorNotification(t, s.t(null, void 0, i(348434))), !1
            )
          }
          return (
            !!(await me.show(e.symbol)) &&
            this._activeBroker.closePosition(e.id)
          )
        }
        async _cancelOrderForNonTradableSymbol(e, t) {
          if (
            !this._activeBroker.metainfo().configFlags
              .supportCancelOrderForNonTradableSymbol
          ) {
            const t = s.t(null, { replace: { symbol: e } }, i(993545))
            return (
              this._showErrorNotification(t, s.t(null, void 0, i(30665))), !1
            )
          }
          return !!(await _e.show(e)) && this._activeBroker.cancelOrder(t)
        }
        async _assertPositionExistsAndNotClosed(e) {
          const t = await this._activeBroker.positionById(e)
          if (!(0, x.checkIsExistingPosition)(t))
            throw new fe.UserFriendlyError({
              userFriendlyMessage: s.t(
                null,
                { replace: { positionId: e } },
                i(969233),
              ),
              detailedErrorMessage: `Position ${e} doesn't exist or has already been closed`,
            })
        }
        async _getParentOrderOrPosition(e) {
          try {
            return 1 === e.parentType
              ? await this._activeBroker.orderById(e.parentId)
              : 2 === e.parentType
                ? await this._activeBroker.positionById(e.parentId)
                : 3 === e.parentType
                  ? await this._activeBroker.individualPositionById(e.parentId)
                  : void 0
          } catch (e) {
            return
          }
        }
        async _assertOrderExistsAndNotCanceled(e) {
          const t = await this._activeBroker.orderById(e)
          if (void 0 === t || 1 === t.status)
            throw new fe.UserFriendlyError({
              userFriendlyMessage: s.t(
                null,
                { replace: { orderId: e } },
                i(579287),
              ),
              detailedErrorMessage: `Order ${e} doesn't exist or has already been canceled`,
            })
        }
      }
      class Ce {
        constructor(e, t, i, r, s, o) {
          ;(this._domPanel = null),
            (this._resizerBridge = e),
            (this._trading = i),
            (this._qtySuggester = r),
            (this._tradingLinking = s),
            (this._headerState = o),
            (this._getDOMPanel = (0, V.sequentialize)(this._getDOMPanel)),
            (this._close = () => {
              this.unmount(), t()
            })
        }
        mount() {
          return this._getDOMPanel().then((e) => {
            e.setVisibility(!0)
          })
        }
        unmount() {
          this._getDOMPanel().then((e) => {
            e.setVisibility(!1)
          })
        }
        headerStateValue() {
          return this._headerState
        }
        async _getDOMPanel() {
          if (null !== this._domPanel) return this._domPanel
          const { DOMPanel: e } = await Promise.all([
              i.e(9072),
              i.e(580),
              i.e(8194),
              i.e(2639),
              i.e(7845),
              i.e(4474),
              i.e(7194),
              i.e(5295),
              i.e(6209),
              i.e(5896),
              i.e(75),
              i.e(9244),
              i.e(2256),
              i.e(7125),
              i.e(4119),
              i.e(5380),
              i.e(9389),
              i.e(4627),
            ]).then(i.bind(i, 73245)),
            t = (this._domPanel = new e(
              this._trading,
              this._resizerBridge,
              this._qtySuggester,
              this._tradingLinking,
              this._headerState,
            ))
          return t.setCloseHandler(this._close), t
        }
      }
      class we {
        constructor(e) {
          this._headerState = e
        }
        mount() {
          return Promise.resolve()
        }
        unmount() {}
        headerStateValue() {
          return this._headerState
        }
      }
      var Be = i(795820),
        Te = i(500962),
        Ee = i(497754),
        Oe = i.n(Ee),
        De = i(192517),
        Ie = i.n(De)
      function xe(e) {
        const {
            className: t,
            type: i = 'secondary',
            size: r = 'small',
            orientation: s = 'horizontal',
          } = e,
          o = Ee(
            t,
            Ie().divider,
            Ie()[`size-${r}`],
            Ie()[`type-${i}`],
            Ie()[`orientation-${s}`],
          )
        return be.createElement('hr', { className: o, 'aria-orientation': s })
      }
      var Me = i(273388),
        Ae = i(72571),
        Ne = i(713450)
      function Le(e) {
        const { startIcon: t, endSlot: i, children: r, title: s } = e
        return be.createElement(
          be.Fragment,
          null,
          t &&
            be.createElement(Ae.Icon, {
              icon: t,
              className: Ne['start-icon-wrap'],
              'aria-hidden': !0,
            }),
          r &&
            be.createElement(
              'span',
              {
                title: s,
                className: Oe()(
                  Ne.content,
                  s ? 'apply-common-tooltip' : 'apply-overflow-tooltip',
                ),
              },
              r,
            ),
          i,
        )
      }
      const Ve = (0, be.forwardRef)((e, t) => {
        const {
          id: i,
          active: r,
          startIcon: s,
          children: o,
          endSlot: n,
          className: a,
          title: l,
          ...c
        } = e
        return be.createElement(
          'button',
          {
            ...c,
            id: i,
            ref: t,
            className: Oe()(Ne['light-tab-button'], r && Ne.selected, a),
          },
          be.createElement(Le, { startIcon: s, endSlot: n, title: l }, o),
        )
      })
      Ve.displayName = 'LightTabBaseButton'
      const Re = (0, be.forwardRef)((e, t) => {
        const {
            item: i,
            highlighted: r,
            handleItemRef: s,
            onClick: o,
            ...n
          } = e,
          a = (0, be.useCallback)(() => {
            o && o(i)
          }, [o, i]),
          l = (0, be.useCallback)(
            (e) => {
              s && s(i, e), (0, Me.isomorphicRef)(t)(e)
            },
            [i, s, t],
          )
        return be.createElement(
          Ve,
          {
            ...n,
            id: i.id,
            title: i.title,
            onClick: a,
            ref: l,
            startIcon: i.startIcon,
            endSlot: i.endSlot,
          },
          i.children,
        )
      })
      Re.displayName = 'LightTabButton'
      var Fe = i(897107),
        We = i(298563),
        qe = i(867941)
      function Ue(e) {
        const {
            items: t,
            isRtl: i,
            classNameWrap: r,
            className: s,
            style: o,
            'data-name': n = 'light-tabs-buttons',
          } = e,
          {
            getBindings: a,
            scrollWrapBinding: l,
            tablistBinding: c,
            handleActivate: d,
          } = (0, We.useTabsMainHandlers)(Fe.TabNames.LightButtonTabs, e, {
            isRtl: i,
          })
        return be.createElement(
          'div',
          { ...l, 'data-name': n, className: r, style: o },
          be.createElement(
            'div',
            { ...c, className: Oe()(qe['light-tabs'], s) },
            t.map((e, t) =>
              be.createElement(Re, {
                ...a(e),
                key: e.id,
                item: e,
                onClick: () => d(e),
                'data-name': `light-tab-${t}`,
              }),
            ),
          ),
        )
      }
      var ze = i(661851),
        $e = i(710263),
        He = i(396789)
      function Qe(e) {
        const { items: t, activeTabId: i, isVisible$: r, onSelect: s } = e,
          o = (0, ze.useObservable)(r),
          n = (0, be.useCallback)((e) => e.id === i, [i]),
          a = (0, be.useCallback)(
            (e) => {
              const t = e.id
              s(t),
                (0, se.trackEvent)(
                  'GUI',
                  t === H.TradingPage.OrderPanel
                    ? 'Select Order Tab'
                    : 'Select DOM Tab',
                )
            },
            [s],
          )
        return o
          ? be.createElement(
              be.Fragment,
              null,
              be.createElement(Ue, {
                id: 'trading-panel-page-tabs',
                classNameWrap: He.tabs,
                items: t,
                isRtl: $e.isRtl,
                isActive: n,
                onActivate: a,
              }),
              be.createElement(xe, { className: He.divider, size: 'xsmall' }),
            )
          : be.createElement(be.Fragment, null)
      }
      var je = i(483830)
      const Ke = R.enabled('show_order_panel_on_start')
      class Ge {
        constructor(e, t) {
          ;(this.isOpened = new d.WatchedValue(!1)),
            (this.isOpeningAvailable = new d.WatchedValue(!1)),
            (this.isLoading = new d.WatchedValue(!1)),
            (this._pageTabs = null),
            (this._pages = {}),
            (this._panelWidth = H.minPanelWidth),
            (this.setPage = (e) => {
              this.isOpened.value() &&
                this.activePage.value() !== e &&
                this._pages[this.activePage.value()] &&
                this._pages[this.activePage.value()].unmount(),
                this.activePage.setValue(e),
                o.setValue(j.settingsKeys.TRADING_PANEL_ACTIVE_PAGE, e)
            }),
            (this.openPage = (e) => {
              this.setPage(e), this.open()
            }),
            (this.open = () => {
              const e = this._pages[this.activePage.value()]
              if (this.isOpeningAvailable.value() && e) {
                this._togglePanel(!0), this.isOpened.setValue(!0)
                const r = e.headerStateValue()
                ;(0, Be.mountHeader)(this._header, r),
                  null !== this._tabsConfig &&
                    null !== this._pageTabs &&
                    ((t = this._pageTabs),
                    (i = {
                      items: this._tabsConfig.items,
                      activeTabId: this.activePage.value(),
                      isVisible$: r.backFunction$.pipe(
                        (0, S.map)((e) => void 0 === e),
                      ),
                      onSelect: this._tabsConfig.onSelect,
                    }),
                    Te.render(be.createElement(Qe, { ...i }), t)),
                  e.mount()
              }
              var t, i
            }),
            (this.close = () => {
              this.isOpened.setValue(!1),
                this._pages[this.activePage.value()] &&
                  this._pages[this.activePage.value()].unmount(),
                (0, Be.unmountHeader)(this._header),
                this._togglePanel(!1)
            }),
            (this._onLayoutResizeHandleMousedown = (e) => {
              if (e.defaultPrevented || !e.cancelable) return
              e.preventDefault()
              const t = Math.max(this._resizerBridge.width.value(), 0)
              let i
              i = 'touches' in e ? e.touches[0].clientX : e.clientX
              const r = (e) => {
                  let r
                  e.preventDefault(),
                    (r = 'touches' in e ? e.touches[0].clientX : e.clientX)
                  let s = t - (r - i)
                  s < H.minPanelWidth
                    ? (s = H.minPanelWidth)
                    : s > H.maxPanelWidth && (s = H.maxPanelWidth),
                    this._requestWidth(s)
                },
                s = () => {
                  document.removeEventListener('mousemove', r),
                    document.removeEventListener('touchmove', r),
                    document.removeEventListener('mouseup', s),
                    document.removeEventListener('touchend', s),
                    o.setValue(j.settingsKeys.PANEL_WIDTH, this._panelWidth)
                }
              document.addEventListener('mousemove', r),
                document.addEventListener('touchmove', r, { passive: !1 }),
                document.addEventListener('mouseup', s),
                document.addEventListener('touchend', s, { passive: !1 })
            })
          const i = o.getValue(
            j.settingsKeys.TRADING_PANEL_ACTIVE_PAGE,
            R.enabled('order_panel')
              ? H.TradingPage.OrderPanel
              : H.TradingPage.DOMPanel,
          )
          this.activePage = new d.WatchedValue(i)
          {
            const e = o.getBool(j.settingsKeys.TRADING_PANEL_OPENED, Ke)
            this.isOpened.setValue(e)
          }
          ;(this._tabsConfig = t),
            (this._resizerBridge = e),
            (this._rootContainer = this._resizerBridge.container.value()),
            (this.container = document.createElement('div')),
            this.container.classList.add(
              je['trading-panel-content'],
              'trading-panel-content',
            ),
            (this._header = document.createElement('div')),
            this._header.classList.add(je['trading-panel-header']),
            this._rootContainer.appendChild(this._header),
            null !== this._tabsConfig &&
              ((this._pageTabs = document.createElement('div')),
              this._pageTabs.classList.add(je['trading-panel-tabs']),
              this._rootContainer.appendChild(this._pageTabs)),
            this._rootContainer.appendChild(this.container),
            this._addSpinner(),
            this._addResizeHandler(),
            this._subscribeVisibility(),
            this.isLoading.subscribe(this._setLoading.bind(this)),
            (this._rootContainer.style.overflow = this.isOpened.value()
              ? ''
              : 'hidden')
        }
        addPage(e, t) {
          this._pages[e] = t
        }
        isPageOpened(e) {
          return this.isOpened.value() && this.activePage.value() === e
        }
        _setLoading(e) {
          e
            ? ((this._header.style.display = 'none'),
              null !== this._pageTabs &&
                (this._pageTabs.style.display = 'none'),
              (this.container.style.visibility = 'hidden'),
              (this.container.style.opacity = '0'),
              this._rootContainer.appendChild(this._spinnerContainer))
            : (this._header.style.removeProperty('display'),
              null !== this._pageTabs &&
                this._pageTabs.style.removeProperty('display'),
              this.container.style.removeProperty('visibility'),
              this.container.style.removeProperty('opacity'),
              this._rootContainer.contains(this._spinnerContainer) &&
                this._rootContainer.removeChild(this._spinnerContainer))
        }
        _addSpinner() {
          ;(this._spinnerContainer = document.createElement('div')),
            this._spinnerContainer.classList.add(je['trading-panel-spinner']),
            i
              .e(7102)
              .then(i.bind(i, 974063))
              .then((e) => {
                e.render(this._spinnerContainer)
              })
        }
        _addResizeHandler() {
          ;(this._handle = document.createElement('div')),
            this._handle.classList.add(je['trading-panel-handle']),
            this._rootContainer.appendChild(this._handle),
            this._handle.addEventListener(
              'mousedown',
              this._onLayoutResizeHandleMousedown,
              { passive: !1 },
            ),
            this._handle.addEventListener(
              'touchstart',
              this._onLayoutResizeHandleMousedown,
              { passive: !1 },
            ),
            (this._panelWidth =
              o.getInt(j.settingsKeys.PANEL_WIDTH) || H.minPanelWidth)
        }
        _togglePanel(e) {
          this._resizerBridge.negotiateWidth(e ? this._panelWidth : 0),
            this._resizerBridge.negotiateHeight(e ? H.panelHeight : 0),
            (this._rootContainer.style.overflow = e ? '' : 'hidden'),
            o.setValue(j.settingsKeys.TRADING_PANEL_OPENED, e)
        }
        _updateOpeningAvailability() {
          const e =
            'visible' !== document.visibilityState ||
            this._resizerBridge.visible.value()
          this.isOpeningAvailable.setValue(
            Boolean(
              e &&
                this._resizerBridge.availHeight.value() >= H.panelHeight &&
                this._resizerBridge.availWidth.value() >= this._panelWidth,
            ),
          )
        }
        _subscribeVisibility() {
          this._updateOpeningAvailability(),
            this._resizerBridge.visible.subscribe(() => {
              this._updateOpeningAvailability()
            }),
            this._resizerBridge.availHeight.subscribe(() => {
              this._updateOpeningAvailability()
            }),
            this._resizerBridge.availWidth.subscribe(() => {
              this._updateOpeningAvailability()
            })
        }
        _requestWidth(e) {
          this._canResizeWidth(e) &&
            this._resizerBridge.width.value() !== e &&
            (this._resizerBridge.negotiateWidth([
              { min: H.minPanelWidth, max: e },
            ]),
            (this._panelWidth = e))
        }
        _canResizeWidth(e) {
          return e + 45 <= this._resizerBridge.availWidth.value()
        }
      }
      var Ze = i(12481),
        Je = i(508334)
      const Xe = [
        'qty',
        'stopPrice',
        'limitPrice',
        'status',
        'filledQty',
        'stopType',
      ]
      function Ye(e, t, i) {
        if (void 0 === e || void 0 === t) return !1
        const r = i.indexOf('.')
        if (-1 !== r) {
          const s = i.substring(0, r)
          return Ye(e[s], t[s], i.substring(r + 1))
        }
        return e[i] === t[i]
      }
      function et(e, t) {
        return e.enabled.value() && (t.soundPath = e.path.value()), t
      }
      function tt(e) {
        return 6 === e || 3 === e
      }
      class it extends ee.BrokerService {
        constructor(e) {
          super(e),
            (this._orders = []),
            (this._playSound = (0, Ze.default)(this._playSoundImpl, 50)),
            b(_().map((e) => e.path))
        }
        startService() {
          const e = (0, r.ensure)(this.activeBroker())
          e.orders().then((e) => (this._orders = (0, Je.deepCopy)(e))),
            e.orderUpdate.subscribe(this, this._orderUpdate),
            (this._shouldHidePriceInOrderExecutedNotifications =
              e.metainfo().configFlags.showAvgFillPriceColumnAsLastFillPrice)
        }
        stopService() {
          ;(0, r.ensure)(this.activeBroker()).orderUpdate.unsubscribe(
            this,
            this._orderUpdate,
          )
        }
        _showNotification(e, t, i) {
          R.enabled('trading_notifications') &&
            ('error' === i
              ? this.trading().showErrorNotification(e, t)
              : this.trading().showSuccessNotification(e, t))
        }
        _formatter(e) {
          return (0, r.ensureNotNull)(this.activeBroker()).formatter(e, !0)
        }
        _checkOrderModified(e, t) {
          const i = this.activeBroker(),
            r = (i && i.metainfo().customNotificationFields) || [],
            s = Xe.concat(r)
          let o = !1
          return (
            s.forEach((i) => {
              o || Ye(e, t, i) || (o = !0)
            }),
            o
          )
        }
        _generateNotificationsInfo(e, t) {
          const r = [],
            o = e.statusMessage ? ': ' + e.statusMessage : '',
            n = (
              1 === e.side
                ? s.t(null, void 0, i(32241))
                : s.t(null, void 0, i(185631))
            ).toUpperCase()
          const a = this.trading().orderExecutedSoundParams
          return (
            t
              ? (this._checkOrderModified(e, t) &&
                  (1 === e.status
                    ? r.push({
                        text: s.t(null, void 0, i(767207)),
                        notificationType: 1,
                      })
                    : 5 === e.status
                      ? r.push({
                          text: s.t(null, void 0, i(442060)) + o,
                          type: 'error',
                          notificationType: 2,
                        })
                      : 2 === e.status
                        ? r.push(
                            et(a, {
                              side: n,
                              text: s.t(null, void 0, i(499577)),
                              notificationType: 5,
                            }),
                          )
                        : t.filledQty !== e.filledQty
                          ? r.push(
                              et(a, {
                                side: n,
                                text: s.t(null, void 0, i(23750)),
                                notificationType: 3,
                              }),
                            )
                          : tt(e.status) &&
                            r.push({
                              text: s.t(null, void 0, i(164105)),
                              notificationType: 4,
                            })),
                Object.assign(t, e))
              : tt(e.status)
                ? (this._orders.push(e),
                  r.push({
                    text: s.t(null, void 0, i(595536)),
                    notificationType: 0,
                  }),
                  this.trading().trackEvent(
                    '',
                    'Order placed symbol',
                    e.symbol,
                  ))
                : 1 === e.status
                  ? r.push({
                      text: s.t(null, void 0, i(767207)),
                      notificationType: 1,
                    })
                  : 5 === e.status
                    ? (this._orders.push(e),
                      r.push({
                        text: s.t(null, void 0, i(442060)) + o,
                        type: 'error',
                        notificationType: 2,
                      }))
                    : 2 === e.status &&
                      (this._orders.push(e),
                      r.push(
                        {
                          text: s.t(null, void 0, i(595536)),
                          notificationType: 0,
                        },
                        et(a, {
                          side: n,
                          text: s.t(null, void 0, i(499577)),
                          emptyOrderType: !0,
                          notificationType: 5,
                        }),
                      ),
                      this.trading().trackEvent(
                        '',
                        'Order placed symbol',
                        e.symbol,
                      )),
            r
          )
        }
        _orderUpdate(e, t) {
          const r = (0, Je.deepCopy)(e),
            o = this._orders.find((e) => e.id === r.id)
          if (t) return void (void 0 === o && this._orders.push(r))
          if (o && (0, N.isFinalOrderStatus)(o.status)) return
          const n = this._generateNotificationsInfo(r, o)
          0 !== n.length &&
            this._formatter(r.symbol).then((e) => {
              const t = (0, N.sideToText)(r.side, !0),
                o = r.qty,
                a =
                  void 0 !== r.filledQty && r.filledQty > 0
                    ? r.filledQty
                    : void 0
              let l = '',
                c = ''
              switch (r.type) {
                case 2:
                  ;(l = r.avgPrice
                    ? ' (' + (0, N.orderTypeToText)({ orderType: r.type }) + ')'
                    : ''),
                    (c = r.avgPrice
                      ? e.format(r.avgPrice)
                      : (0, N.orderTypeToText)({ orderType: r.type }))
                  break
                case 4:
                  ;(l =
                    ' ' +
                    s
                      .t(null, void 0, i(916322))
                      .format({ price: e.format(r.stopPrice) })),
                    (c = e.format(r.avgPrice || r.limitPrice))
                  break
                default:
                  ;(l =
                    ' (' + (0, N.orderTypeToText)({ orderType: r.type }) + ')'),
                    (c = e.format(r.avgPrice || r.limitPrice || r.stopPrice))
              }
              const d =
                void 0 !== r.message
                  ? `${r.message.text.charAt(0).toUpperCase()}${r.message.text.substring(1)}`
                  : ''
              n.forEach(
                ({
                  text: e,
                  type: n,
                  side: u,
                  emptyOrderType: h,
                  soundPath: p,
                  notificationType: g,
                }) => {
                  const m = 3 === g && void 0 !== a ? a : o
                  let _ =
                    (0, ve.splitThousands)(Math.abs(m), '') +
                    ' ' +
                    (r.brokerSymbol || r.symbol)
                  ;(!this._shouldHidePriceInOrderExecutedNotifications ||
                    (5 !== g && 3 !== g)) &&
                    (_ += ' ' + s.t(null, void 0, i(492903)) + ' ' + c)
                  const b = `${s.t(null, void 0, i(922541))} ${r.id} ${e}`,
                    v = `${u || t} ${_} ${h ? '' : l}\n${d}`
                  void 0 !== p && this._playSound(p),
                    this._showNotification(b, v, n)
                },
              )
            })
        }
        _playSoundImpl(e) {
          if (this._playingSound) {
            if (this._playingSound === e) return
            !((e, t = !1) => {
              if ((0, l.isOnMobileAppPage)('any')) return
              let i = []
              e ? i.push(v(e)) : (i = Object.values(m)),
                i.forEach((e) => {
                  e.stop(t)
                })
            })(this._playingSound)
          }
          ;(this._playingSound = e),
            ((e = p, t) => {
              ;(0, l.isOnMobileAppPage)('any')
                ? Promise.resolve()
                : (h.logNormal(
                    `Sound play attempt for "${e}" duration-${t || 0}s;`,
                  ),
                  v(e).play(t))
            })(e),
            ((e, t) => {
              ;(0, l.isOnMobileAppPage)('any') ||
                v(e).playing.subscribe(
                  (e) => {
                    e || t()
                  },
                  { once: !0 },
                )
            })(e, () => {
              delete this._playingSound
            })
        }
      }
      var rt = i(739343)
      const st = (0, c.getLogger)('Chart.PointsetManager')
      let ot = 0
      class nt {
        constructor(e, t, i, r, s) {
          ;(this._currentPointsetId = null),
            (this._onUpdate = new q.Delegate()),
            (this._requestPoints = []),
            (this._gateway = e),
            (this._pointsetSuffix = t),
            (this._isGatewayConnected = this._gateway.isConnected().spawn()),
            this._isGatewayConnected.subscribe(
              this._updateByGatewayConnection.bind(this),
            ),
            this._addPoints(i, r, s)
        }
        onUpdate() {
          return this._onUpdate
        }
        destroy() {
          this._isGatewayConnected.value() &&
            null !== this._currentPointsetId &&
            this._gateway.removePointset(this._currentPointsetId),
            (this._requestPoints = []),
            (this._currentPointsetId = null),
            this._isGatewayConnected.destroy()
        }
        _updateByGatewayConnection(e) {
          e || ((this._currentPointsetId = null), (this._requestPoints = []))
        }
        _addPoints(e, t, i) {
          var s, o
          this._isGatewayConnected.value() &&
            ((0, r.assert)(
              e.length > 0,
              "Can't possible create point set for empty array of time points",
            ),
            (this._requestPoints = e.map((e) => [e.time_t, e.offset])),
            (this._currentPointsetId =
              ((s = this._pointsetSuffix), (o = ++ot), `pointset_${s}_${o}`)),
            this._gateway.createPointset(
              this._currentPointsetId,
              'turnaround',
              t,
              (0, rt.getServerInterval)(i),
              this._requestPoints,
              this._onMessage.bind(this),
            ))
        }
        _onMessage(e) {
          switch (e.method) {
            case 'pointset_error':
              st.logNormal(
                `Pointset error with id ${e.params[0]} turnaround ${e.params[1]}`,
              )
              break
            case 'data_update': {
              const t = []
              for (const i of e.params.plots)
                t.push({
                  time_t: this._requestPoints[i.index][0],
                  index: i.value[0],
                  barTime: i.value[1],
                })
              this._onUpdate.fire(t)
              break
            }
          }
        }
      }
      var at = i(648067)
      function lt(e) {
        const t = e.mainSeries().data().first()
        return null === t ? null : t.value[0]
      }
      async function ct(e, t, r) {
        const [s, o, n] = await Promise.all([
          Promise.all([i.e(1033), i.e(1969), i.e(2650)]).then(
            i.bind(i, 289705),
          ),
          Promise.all([i.e(1033), i.e(1969), i.e(2650)]).then(
            i.bind(i, 564209),
          ),
          Promise.all([i.e(1033), i.e(1969), i.e(2650)]).then(
            i.bind(i, 856628),
          ),
        ])
        e.addCustomSource('executions', (e, i) => {
          const a = i.mainSeries(),
            l = a.dataEvents(),
            c = (0, at.createPrimitivePropertyFromGetterAndSubscription)(
              i.isInReplay.bind(i),
              i.onInReplayStateChanged(),
            ),
            d = (0, at.createPrimitivePropertyFromGetterAndSubscription)(
              () =>
                a.isConvertedToOtherCurrency() || a.isConvertedToOtherUnit(),
              a.symbolResolved(),
            ),
            u = {
              arrowVisibility: (0, at.combineProperty)(
                (e, t, i) => i && !t,
                c.ownership(),
                d.ownership(),
                i
                  .properties()
                  .childs()
                  .tradingProperties.childs()
                  .showExecutions.weakReference(),
              ),
              labelVisibility: i
                .properties()
                .childs()
                .tradingProperties.childs().showExecutionsLabels,
            },
            h = ((e, t, i) => (r) => {
              const s = i.seriesSource().symbolInstanceId(),
                o = i.interval()
              return null === s ? null : new nt(e, t, r, s, o)
            })(i.chartApi(), 'executions', a),
            p = (0, at.createWVFromGetterAndSubscription)(
              lt.bind(null, i),
              l.barReceived(),
            ),
            g = new s.ExecutionsService(
              t,
              l,
              ((e) => () => {
                const t = e.symbolInfo()
                return null !== t ? t.pro_name || t.full_name : e.proSymbol()
              })(a),
            ),
            m = new o.ExecutionsPointsManager(g, h, p)
          return new n.ExecutionsSource(e, i, u, r, m)
        })
      }
      var dt = i(583705),
        ut = i(690839),
        ht = i(409432),
        pt = i(918114),
        gt = i(372605)
      const mt = s.t(null, void 0, i(799559)),
        _t = s.t(null, void 0, i(435312)),
        bt = s.t(null, void 0, i(703396)),
        vt = s.t(null, void 0, i(538386)),
        yt = s.t(null, void 0, i(893966)),
        ft = s.t(null, void 0, i(422540)),
        kt = s.t(null, void 0, i(400241)),
        St = s.t(null, void 0, i(766596)),
        Pt = R.enabled('broker_button')
      class Ct {
        constructor({
          dataEvents: e,
          getSymbolName: t,
          isNonTradableInstrument: i,
          qtySuggester: r,
          tradingCommands: s,
          settings: o,
          isInReplay: n,
          hibernated: a,
        }) {
          ;(this.ask = new d.WatchedValue(null)),
            (this.askTooltip = new d.WatchedValue(mt)),
            (this.bid = new d.WatchedValue(null)),
            (this.bidTooltip = new d.WatchedValue(_t)),
            (this.spread = new d.WatchedValue(null)),
            (this.spreadTooltip = new d.WatchedValue(ft)),
            (this.qty = new d.WatchedValue(null)),
            (this.qtyTooltip = new d.WatchedValue('')),
            (this.brokerIconVisible = new d.WatchedValue(!1)),
            (this.brokerIconLoading = new d.WatchedValue(!1)),
            (this.brokerIconUrl = new d.WatchedValue(null)),
            (this.isQtyVisible = new d.WatchedValue(!1)),
            (this.hasAskBidAdditionalPrecision = new d.WatchedValue(!1)),
            (this.canTrade = new d.WatchedValue(!0)),
            (this._globalVisibility = null),
            (this._isSymbolTradableResult = new ht.WatchedObject(null)),
            (this._formatter = null),
            (this._spreadFormatter = null),
            (this._symbol = null),
            (this._abortController = new AbortController()),
            (this.setQty = (e) => {
              this.qty.setValue(String(e))
            }),
            (this._createTradedSymbol = () => {
              var e
              const t = this._getSymbolName()
              null === (e = this._symbolChangeSubscription) ||
                void 0 === e ||
                e.unsubscribe(),
                this._clearTradedSymbol(),
                t.length > 0 && this._initTradedSymbol(t)
            }),
            (this._onSuggestedQtyChange = (e) => {
              ;(this._lastSuggestedQty = e), this.setQty(e)
            }),
            (this._updateIsSymbolTradable = async (e) => {
              if (null === this._symbol)
                return void this._isSymbolTradableResult.setValue(null)
              const t = await this._realtimeProvider.isTradable(this._symbol)
              ;(null == e ? void 0 : e.aborted) ||
                this._isSymbolTradableResult.setValue((0, gt.clone)(t))
            }),
            (this._updateIsSymbolTradable = (0, z.respectLatest)(
              this._updateIsSymbolTradable,
            ))
          const { noConfirmEnabled: l, showSellBuyButtons: c, themeName: u } = o
          ;(this._isInstantMode = l),
            (this._dataEvents = e),
            (this._getSymbolName = t),
            (this._qtySuggester = r),
            (this._realtimeProvider = s.realtimeProvider),
            (this._onNeedSelectBroker = s.onNeedSelectBroker),
            (this._toggleTradingWidget = s.toggleTradingWidget),
            (this._toggleTradingPanelPopup = s.toggleTradingPanelPopup),
            (this._brokerCommandsUI = s.brokerCommandsUI),
            (this._makeActualTradingSymbolObservable =
              s.makeActualSymbolObservable),
            (this._updateRealtimeDataHandler =
              this._updateRealtimeData.bind(this)),
            (this._isBrokerConnected = (0,
            at.createWVFromGetterAndSubscription)(
              () => null !== this._realtimeProvider.activeBroker(),
              this._realtimeProvider.onStatusChanged,
            )),
            this._isBrokerConnected.subscribe(
              this._updateQtyTooltip.bind(this),
              { callWithLast: !0 },
            ),
            this._isBrokerConnected.subscribe(
              this._updateBrokerIcon.bind(this),
            ),
            this._isBrokerConnected.subscribe(this._createTradedSymbol),
            (this._isBrokerConnecting = (0,
            at.createWVFromGetterAndSubscription)(
              () => 2 === s.brokerConnectionStatus(),
              s.onBrokerConnectionStatusChange,
            )),
            this._isBrokerConnecting.subscribe(
              this._updateBrokerIcon.bind(this),
            ),
            (this.visible = new d.WatchedValue(!1)),
            (this._enabled = (0, W.combine)(
              (e, t) => e && !t,
              this.visible.weakReference(),
              a.ownership(),
            )),
            this._enabled.subscribe(this._toggleState.bind(this), {
              callWithLast: !0,
            }),
            (this._showSellBuyButtons = c),
            (this._isInReplay = n),
            (this._isNonTradableInstrument = i),
            this._showSellBuyButtons.subscribe(
              this._updateVisibility.bind(this),
            ),
            this._isInReplay.subscribe(this._updateVisibility.bind(this)),
            this._isNonTradableInstrument.subscribe(
              this._updateVisibility.bind(this),
            ),
            this._updateVisibility(),
            (this._themeName = u),
            this._themeName.subscribe(this._updateBrokerIcon.bind(this), {
              callWithLast: !0,
            }),
            (this._tradePossibilityComputedWV = (0, W.combine)(
              () => ({}),
              this._isBrokerConnected.weakReference(),
              this._isSymbolTradableResult.weakReference(),
              this.ask.weakReference(),
              this.bid.weakReference(),
            )),
            this._tradePossibilityComputedWV.subscribe(
              this._updateTradePossibilityAndTooltip.bind(this),
              { callWithLast: !0 },
            ),
            (this._isQtyVisibleComputedWV = (0, W.combine)(
              () => ({}),
              this.canTrade.weakReference(),
              this._isInstantMode.weakReference(),
            )),
            this._isQtyVisibleComputedWV.subscribe(
              this._updateIsQtyVisible.bind(this),
              { callWithLast: !0 },
            )
        }
        destroy() {
          var e
          this._abortController.abort(),
            this._stop(),
            this._isBrokerConnected.destroy(),
            this._showSellBuyButtons.release(),
            this._isInReplay.release(),
            this._isNonTradableInstrument.release(),
            null === (e = this._globalVisibility) ||
              void 0 === e ||
              e.release(),
            this._isInstantMode.release(),
            this._tradePossibilityComputedWV.destroy(),
            this._isQtyVisibleComputedWV.destroy(),
            this._themeName.release(),
            this._isBrokerConnecting.destroy(),
            this._enabled.destroy()
        }
        setGlobalVisibility(e) {
          ;(0, r.assert)(
            null === this._globalVisibility,
            'GlobalVisibility can be set only once',
          ),
            (this._globalVisibility = e),
            this._globalVisibility.subscribe(
              this._updateVisibility.bind(this),
              { callWithLast: !0 },
            )
        }
        async tryToPlaceSellOrder() {
          await this._tryToPlaceOrder(
            Number.parseFloat((0, r.ensureNotNull)(this.bid.value())),
            -1,
          )
        }
        async tryToPlaceBuyOrder() {
          await this._tryToPlaceOrder(
            Number.parseFloat((0, r.ensureNotNull)(this.ask.value())),
            1,
          )
        }
        async getQtyInfo() {
          return null !== this._symbol && this.canTrade.value()
            ? (await this._realtimeProvider.symbolInfo(this._symbol)).qty
            : null
        }
        applyQty() {
          if (null === this._symbol || !this.canTrade.value()) return
          const e = this.qty.value(),
            t = null !== e ? Number(e) : null
          null !== t && this._qtySuggester.setQty(this._symbol, t),
            void 0 !== this._lastSuggestedQty &&
              t !== this._lastSuggestedQty &&
              this.qty.setValue(String(this._lastSuggestedQty))
        }
        canShowMobileTrading() {
          var e
          return !(null === (e = window.TradingView.bottomWidgetBar) ||
          void 0 === e
            ? void 0
            : e.isVisible().value())
        }
        _updateVisibility() {
          const e =
            (null === this._globalVisibility ||
              this._globalVisibility.value()) &&
            this._showSellBuyButtons.value() &&
            !this._isInReplay.value() &&
            !this._isNonTradableInstrument.value()
          this.visible.setValue(e)
        }
        async _tryToPlaceOrder(e, t) {
          var i, s
          if (null === this._realtimeProvider.activeBroker())
            return (
              this.canShowMobileTrading()
                ? this._toggleTradingPanelPopup()
                : await this._toggleTradingWidget(),
              void this._onNeedSelectBroker.fire()
            )
          const o = Number(this.qty.value()) || 1,
            n = this._isMarketOrderSupported() ? 2 : 1,
            a =
              1 === t
                ? null === (i = this._currentQuotes) || void 0 === i
                  ? void 0
                  : i.ask
                : null === (s = this._currentQuotes) || void 0 === s
                  ? void 0
                  : s.bid,
            l = {
              symbol: (0, r.ensureNotNull)(this._symbol),
              qty: o,
              side: t,
              type: n,
              seenPrice: null != a ? a : null,
              currentQuotes: this._currentQuotes,
            }
          1 === n && (l.limitPrice = e),
            await (0, r.ensureNotNull)(this._brokerCommandsUI()).placeOrder(
              l,
              !0,
            )
        }
        _toggleState(e) {
          e ? this._start() : this._stop()
        }
        _start() {
          this._dataEvents
            .symbolResolved()
            .subscribe(this, this._createTradedSymbol),
            this._dataEvents
              .symbolError()
              .subscribe(this, this._createTradedSymbol),
            this._createTradedSymbol()
        }
        _stop() {
          var e
          null === (e = this._symbolChangeSubscription) ||
            void 0 === e ||
            e.unsubscribe(),
            this._clearTradedSymbol(),
            (this._symbol = null),
            this._dataEvents.symbolResolved().unsubscribeAll(this),
            this._dataEvents.symbolError().unsubscribeAll(this)
        }
        _initTradedSymbol(e) {
          ;(this._symbol = e),
            this._updateIsSymbolTradable(this._abortController.signal),
            this._realtimeProvider.subscribeRealtime(
              this._symbol,
              this._updateRealtimeDataHandler,
            ),
            this._resubscribeQtySuggester()
        }
        _clearTradedSymbol() {
          var e
          ;(this._currentQuotes = void 0),
            this.ask.setValue(null),
            this.bid.setValue(null),
            this.spread.setValue(null),
            this.qty.setValue(null),
            null !== this._symbol &&
              (this._realtimeProvider.unsubscribeRealtime(
                this._symbol,
                this._updateRealtimeDataHandler,
              ),
              null === (e = this._qtySuggesterSubscription) ||
                void 0 === e ||
                e.unsubscribe(),
              (this._symbol = null),
              this._updateIsSymbolTradable(this._abortController.signal))
        }
        async _resubscribeQtySuggester() {
          var e
          const t = this._symbol
          if (null === t) return
          null === (e = this._qtySuggesterSubscription) ||
            void 0 === e ||
            e.unsubscribe()
          const i = (this._suggestedQtyPromise = this._qtySuggester.getQty(t)),
            r = await i
          i === this._suggestedQtyPromise &&
            t === this._symbol &&
            ((this._lastSuggestedQty = r),
            this.setQty(r),
            (this._qtySuggesterSubscription = this._qtySuggester
              .suggestedQtyChanged(t)
              .subscribe(this._onSuggestedQtyChange)))
        }
        _isMarketOrderSupported() {
          const e = this._realtimeProvider.activeBroker()
          return (
            null === e || Boolean(e.metainfo().configFlags.supportMarketOrders)
          )
        }
        _updateTradePossibilityAndTooltip() {
          this._updateCanTrade(), this._updateSellBuyTooltip()
        }
        _updateCanTrade() {
          const e = this._isSymbolTradableResult.value(),
            t = this._isBrokerConnected.value() && null !== e && e.tradable
          this.canTrade.setValue(t)
        }
        _updateSellBuyTooltip() {
          var e, t
          const i = this._getNonTradedTooltip()
          this.askTooltip.setValue(
            null !== (e = null != i ? i : this._getAskTooltip()) && void 0 !== e
              ? e
              : mt,
          ),
            this.bidTooltip.setValue(
              null !== (t = null != i ? i : this._getBidTooltip()) &&
                void 0 !== t
                ? t
                : _t,
            )
        }
        _getNonTradedTooltip() {
          const e = this._isSymbolTradableResult.value()
          if (this._isBrokerConnected.value() && null !== e && !e.tradable)
            return void 0 !== e.solutions
              ? ''
              : void 0 !== e.shortReason && '' !== e.shortReason
                ? e.shortReason
                : bt
        }
        _getAskTooltip() {
          return null === this.ask.value() ? yt : void 0
        }
        _getBidTooltip() {
          return null === this.bid.value() ? vt : void 0
        }
        _updateRealtimeData(e, t, i) {
          ;(this._formatter = i.formatter),
            (this._spreadFormatter = i.spreadFormatter)
          const r = t.ask,
            s = t.bid,
            o = (0, y.isNumber)(r),
            n = (0, y.isNumber)(s),
            a = o ? this._formatter.format(r) : null,
            l = n ? this._formatter.format(s) : null
          this.ask.setValue(a),
            this.bid.setValue(l),
            o && n && (this._currentQuotes = { ask: r, bid: s })
          const c =
              t.spread ||
              ((0, y.isNumber)(r) && (0, y.isNumber)(s) && r - s) ||
              0,
            d = (0, y.isNumber)(t.spread)
              ? this._spreadFormatter
              : this._formatter
          this.spread.setValue(d.format(c))
          let u = !1
          ;(0, pt.isFormatterHasForexAdditionalPrecision)(this._formatter) &&
            (u = this._formatter.hasForexAdditionalPrecision()),
            this.hasAskBidAdditionalPrecision.setValue(u)
        }
        _updateIsQtyVisible() {
          const e = this._isInstantMode.value() && this.canTrade.value()
          this.isQtyVisible.setValue(e)
        }
        _updateQtyTooltip() {
          this.qtyTooltip.setValue(this._getQtyTooltip())
        }
        _getQtyTooltip() {
          const e = this._realtimeProvider.activeBroker()
          return null !== e &&
            e.metainfo().configFlags.showQuantityInsteadOfAmount
            ? St
            : kt
        }
        _updateBrokerIcon() {
          if (!Pt) return
          let e
          const t = this._realtimeProvider.activeBroker()
          if (null !== t) {
            const i = t.metainfo()
            e =
              'dark' === this._themeName.value() && i.logoMiniBlackUrl
                ? i.logoMiniBlackUrl
                : i.logoMiniUrl
          }
          this.brokerIconVisible.setValue(this._isBrokerConnected.value()),
            this.brokerIconLoading.setValue(this._isBrokerConnecting.value()),
            this.brokerIconUrl.setValue(e || null)
        }
      }
      var wt = i(973602),
        Bt = i(159255),
        Tt = i(343370),
        Et = i(72304),
        Ot = i(476853),
        Dt = i(462892),
        It = i(672511)
      const xt = (0, i(851237).reactLoaderRendererCreator)(It.Spinner, {
        size: 'xxsmall',
      })
      var Mt = i(521744),
        At = i(382280)
      var Nt = i(190787),
        Lt = i(199056),
        Vt = i(707488),
        Rt = i(844012),
        Ft = i(829883)
      const Wt = Number.parseInt(Rt['css-value-padding'])
      function qt(e, t, i, s) {
        let o = e.querySelector(`.${s}`)
        if (!i)
          return null !== o && o.remove(), void (0, Nt.updateTextNode)(e, t)
        null === o &&
          ((o = document.createElement('span')),
          o.classList.add(s),
          e.appendChild(o)),
          (0, Nt.updateTextNode)((0, r.ensureNotNull)(o), t.slice(-1)),
          (0, Nt.updateTextNode)(e, t.slice(0, -1))
      }
      class Ut {
        constructor({
          model: e,
          highButtonsMode: t,
          trackEvent: i,
          toggleMinimizeBottomWidgetBar: r,
        }) {
          ;(this.element = document.createElement('div')),
            (this._buttonsWrapperEl = document.createElement('div')),
            (this._informerWrapperEl = null),
            (this._sellButtonEl = document.createElement('div')),
            (this._sellButtonTextEl = document.createElement('span')),
            (this._buyButtonEl = document.createElement('div')),
            (this._buyButtonTextEl = document.createElement('span')),
            (this._spreadQtyWrapper = document.createElement('div')),
            (this._spreadEl = document.createElement('div')),
            (this._qtyEl = document.createElement('div')),
            (this._qtyTextEl = document.createElement('span')),
            (this._brokerButtonEl = document.createElement('div')),
            (this._brokerIconWrapEl = document.createElement('div')),
            (this._isCalcOpened = !1),
            (this._calcContainer = document.createElement('div')),
            (this._sellLoader = (0, Dt.createPointsLoaderRenderer)(
              this._sellButtonEl,
              { className: Lt.loader },
            )),
            (this._buyLoader = (0, Dt.createPointsLoaderRenderer)(
              this._buyButtonEl,
              { className: Lt.loader },
            )),
            (this._brokerLoader = xt(this._brokerButtonEl, {
              className: Lt.circleLoader,
            })),
            (this._windowResizeHandlerThrottle = (0, Tt.default)(
              this._windowResizeHandler.bind(this),
              100,
            )),
            (this._isHiddenByViewport = !1),
            (this._mode = 2),
            (this._height = new d.WatchedValue(0)),
            (this._resizeObserver = null),
            (this._cachedBreakPoints = {}),
            (this._parentWidth = 0),
            (this._getCurrentQty = () => {
              const e = this._qty.value()
              return null !== e ? Number(e) : null
            }),
            (this._model = e),
            (this._toggleMinimizeBottomWidgetBar = r),
            (this._ask = this._model.ask.spawn()),
            this._ask.subscribe(this._updateBuyButton.bind(this)),
            (this._bid = this._model.bid.spawn()),
            this._bid.subscribe(this._updateSellButton.bind(this)),
            (this._spread = this._model.spread.spawn()),
            this._spread.subscribe(this._updateSpread.bind(this)),
            (this._qty = this._model.qty.spawn()),
            this._qty.subscribe(this._updateQty.bind(this)),
            (this._brokerIconVisible = this._model.brokerIconVisible.spawn()),
            this._brokerIconVisible.subscribe(
              this._updateBrokerIconImage.bind(this),
            ),
            (this._brokerIconLoading = this._model.brokerIconLoading.spawn()),
            this._brokerIconLoading.subscribe(
              this._updateBrokerIconImage.bind(this),
            ),
            (this._brokerIconUrl = this._model.brokerIconUrl.spawn()),
            this._brokerIconUrl.subscribe(
              this._updateBrokerIconImage.bind(this),
              { callWithLast: !0 },
            ),
            (this._trackEvent = i),
            this._render(),
            (this._askTooltip = this._model.askTooltip.spawn()),
            this._askTooltip.subscribe(
              this._updateButtonTooltip.bind(this, this._buyButtonEl),
              { callWithLast: !0 },
            ),
            (this._bidTooltip = this._model.bidTooltip.spawn()),
            this._bidTooltip.subscribe(
              this._updateButtonTooltip.bind(this, this._sellButtonEl),
              { callWithLast: !0 },
            ),
            (this._spreadTooltip = this._model.spreadTooltip.spawn()),
            this._spreadTooltip.subscribe(
              this._updateButtonTooltip.bind(this, this._spreadEl),
              { callWithLast: !0 },
            ),
            (this._qtyTooltip = this._model.qtyTooltip.spawn()),
            this._qtyTooltip.subscribe(
              this._updateButtonTooltip.bind(this, this._qtyEl),
              { callWithLast: !0 },
            ),
            (this._canTrade = this._model.canTrade.spawn()),
            this._canTrade.subscribe(this._updateBgButtonsMode.bind(this), {
              callWithLast: !0,
            }),
            (this._isVisible = this._model.visible.spawn()),
            this._isVisible.subscribe(this._updateVisibility.bind(this), {
              callWithLast: !0,
            }),
            (this._isQtyVisible = this._model.isQtyVisible.spawn()),
            this._isQtyVisible.subscribe(this._updateQtyVisibility.bind(this), {
              callWithLast: !0,
            }),
            (this._isLastDigitSup =
              this._model.hasAskBidAdditionalPrecision.spawn()),
            this._isLastDigitSup.subscribe(this._updateLastDigitSup.bind(this)),
            (this._highButtonsMode = t.spawn()),
            this._highButtonsMode.subscribe(
              this._updateHighButtonsMode.bind(this),
              { callWithLast: !0 },
            ),
            (this._sellButtonHandler = this._onSellButton.bind(this)),
            (this._buyButtonHandler = this._onBuyButton.bind(this)),
            (this._qtyHandler = this._toggleCalcVisibility.bind(this)),
            (this._brokerButtonHandler = this._onBrokerButton.bind(this)),
            this._sellButtonEl.addEventListener(
              'click',
              this._sellButtonHandler,
            ),
            this._buyButtonEl.addEventListener('click', this._buyButtonHandler),
            this._qtyEl.addEventListener('click', this._qtyHandler),
            this._brokerButtonEl.addEventListener(
              'click',
              this._brokerButtonHandler,
            ),
            window.addEventListener(
              'resize',
              this._windowResizeHandlerThrottle,
            ),
            this._windowResizeHandler()
        }
        destroy() {
          var e
          this._ask.destroy(),
            this._askTooltip.destroy(),
            this._bid.destroy(),
            this._bidTooltip.destroy(),
            this._spread.destroy(),
            this._spreadTooltip.destroy(),
            this._qty.destroy(),
            this._qtyTooltip.destroy(),
            this._isVisible.destroy(),
            this._isQtyVisible.destroy(),
            this._isLastDigitSup.destroy(),
            this._highButtonsMode.destroy(),
            this._canTrade.destroy(),
            this._brokerIconUrl.destroy(),
            this._sellLoader.destroy(),
            this._buyLoader.destroy(),
            this._brokerLoader.destroy(),
            this._sellButtonEl.removeEventListener(
              'click',
              this._sellButtonHandler,
            ),
            this._buyButtonEl.removeEventListener(
              'click',
              this._buyButtonHandler,
            ),
            this._qtyEl.removeEventListener('click', this._qtyHandler),
            this._brokerButtonEl.removeEventListener(
              'click',
              this._brokerButtonHandler,
            ),
            null === (e = this._resizeObserver) ||
              void 0 === e ||
              e.disconnect(),
            (this._resizeObserver = null),
            this.element.remove(),
            delete this.element,
            window.removeEventListener(
              'resize',
              this._windowResizeHandlerThrottle,
            )
        }
        updateModeByWidth(e) {
          var t
          const i = this._cachedBreakPoints[0],
            r = this._cachedBreakPoints[1]
          ;(this._mode =
            void 0 !== i && e < i ? 0 : void 0 !== r && e < r ? 1 : 2),
            (this._parentWidth = e)
          const s = 1 === this._mode
          this._buttonsWrapperEl.classList.toggle(Lt.column, s),
            null === (t = this._informerWrapperEl) ||
              void 0 === t ||
              t.classList.toggle(Lt.column, s),
            this._updateVisibility()
        }
        height() {
          return this._height
        }
        renderTo(e, t) {
          void 0 !== t
            ? e.insertBefore(this.element, t)
            : e.appendChild(this.element),
            null === this._resizeObserver &&
              (this._resizeObserver = new Bt.default(
                this._updateBreakPointsAndSize.bind(this),
              )),
            this._resizeObserver.unobserve(this.element),
            this._resizeObserver.observe(this.element)
        }
        isHiddenByViewport() {
          return this._isHiddenByViewport
        }
        _render() {
          const e = this._bid.value() || '...'
          this._sellButtonTextEl.appendChild(document.createTextNode(e)),
            this._sellButtonTextEl.classList.add(Lt.buttonText),
            this._sellButtonEl.append(this._sellButtonTextEl),
            this._sellButtonEl.classList.add(
              'apply-common-tooltip',
              Lt.button,
              Lt.sellButton,
            )
          const t = this._spread.value() || ''
          this._spreadEl.appendChild(document.createTextNode(String(t))),
            this._spreadEl.classList.add('apply-common-tooltip', Lt.spread)
          const i = this._qty.value() || ''
          this._qtyTextEl.appendChild(document.createTextNode(i)),
            this._qtyEl.append(this._qtyTextEl),
            this._qtyEl.setAttribute('data-name', 'qtyEl'),
            this._qtyEl.classList.add(
              'apply-common-tooltip',
              Lt.button,
              Lt.qty,
            ),
            this._spreadQtyWrapper.classList.add(Lt.spreadQtyWrapper),
            this._spreadQtyWrapper.appendChild(this._spreadEl),
            this._spreadQtyWrapper.appendChild(this._qtyEl)
          const r = this._ask.value() || '...'
          this._buyButtonTextEl.appendChild(document.createTextNode(String(r))),
            this._buyButtonTextEl.classList.add(Lt.buttonText),
            this._buyButtonEl.append(this._buyButtonTextEl),
            this._buyButtonEl.classList.add(
              'apply-common-tooltip',
              Lt.button,
              Lt.buyButton,
            ),
            this._brokerButtonEl.appendChild(this._brokerIconWrapEl),
            this._brokerIconWrapEl.classList.add(Lt.brokerButtonIconWrap),
            this._brokerButtonEl.classList.add(Lt.brokerButton),
            this._buttonsWrapperEl.appendChild(this._sellButtonEl),
            this._buttonsWrapperEl.appendChild(this._spreadQtyWrapper),
            this._buttonsWrapperEl.appendChild(this._buyButtonEl),
            this._buttonsWrapperEl.appendChild(this._brokerButtonEl),
            this._buttonsWrapperEl.classList.add(Lt.buttonsWrapper),
            this._buttonsWrapperEl.classList.toggle(
              Lt.touchMode,
              Mt.trackingModeIsAvailable,
            ),
            this._buttonsWrapperEl.classList.toggle(
              Lt.notAvailableOnMobile,
              false,
            ),
            this.element.appendChild(this._buttonsWrapperEl),
            this._initTradingInformer(),
            this.element.classList.add(Lt.container)
        }
        _initTradingInformer() {
          0
        }
        _updateBreakPointsAndSize(e) {
          const t = e[0],
            i = 2 * Wt
          2 === this._mode &&
            (this._cachedBreakPoints[1] = Math.round(t.contentRect.width) + i),
            1 === this._mode &&
              (this._cachedBreakPoints[0] =
                Math.round(t.contentRect.width) + i),
            this.updateModeByWidth(this._parentWidth)
          const r =
            t.contentRect.height > 0 ? Math.round(t.contentRect.height) + i : 0
          this._height.setValue(r)
        }
        _updateBrokerIconImage() {
          const e = this._brokerIconLoading.value(),
            t = !this._brokerIconVisible.value() && !e
          if ((this._brokerButtonEl.classList.toggle(Vt.blockHidden, t), t))
            return
          if (
            (this._toggleLoaderVisibility(
              this._brokerButtonEl,
              this._brokerLoader,
              e,
            ),
            e)
          )
            return void (this._brokerIconWrapEl.innerHTML = '')
          const i = this._brokerIconUrl.value(),
            r = null === i
          ;(this._brokerIconWrapEl.innerHTML = r
            ? Ft
            : `<image src="${i}" alt="Account Manager" />`),
            this._brokerButtonEl.classList.toggle(Lt.brokerButtonDefault, r)
        }
        async _onSellButton() {
          if (null === this._bid.value()) return
          const e = this._highButtonsMode.value()
          this._trackEvent(
            'Sell/Buy Buttons',
            'Sell',
            e ? 'Instant' : 'Not Instant',
          ),
            e &&
              this._canTrade.value() &&
              this._toggleLoaderVisibility(
                this._sellButtonEl,
                this._sellLoader,
                !0,
              ),
            await this._model.tryToPlaceSellOrder(),
            e &&
              this._canTrade.value() &&
              setTimeout(
                () =>
                  this._toggleLoaderVisibility(
                    this._sellButtonEl,
                    this._sellLoader,
                    !1,
                  ),
                300,
              )
        }
        async _onBuyButton() {
          if (null === this._ask.value()) return
          const e = this._highButtonsMode.value()
          this._trackEvent(
            'Sell/Buy Buttons',
            'Buy',
            e ? 'Instant' : 'Not Instant',
          ),
            e &&
              this._canTrade.value() &&
              this._toggleLoaderVisibility(
                this._buyButtonEl,
                this._buyLoader,
                !0,
              ),
            await this._model.tryToPlaceBuyOrder(),
            e &&
              this._canTrade.value() &&
              setTimeout(
                () =>
                  this._toggleLoaderVisibility(
                    this._buyButtonEl,
                    this._buyLoader,
                    !1,
                  ),
                300,
              )
        }
        _onBrokerButton() {
          this._model.canShowMobileTrading()
            ? (async () => {
                ;(await (0, At.waitTradingService)()).tradingPanelPopup.show()
              })()
            : this._toggleMinimizeBottomWidgetBar()
        }
        _toggleLoaderVisibility(e, t, i) {
          e.classList.toggle(Lt.loading, i), t.toggleVisibility(i)
        }
        _updateBuyButton(e) {
          const t = null !== e && this._isLastDigitSup.value()
          qt(this._buyButtonTextEl, `${e || '...'}`, t, Lt.lastCharSup)
        }
        _updateSellButton(e) {
          const t = null !== e && this._isLastDigitSup.value()
          qt(this._sellButtonTextEl, `${e || '...'}`, t, Lt.lastCharSup)
        }
        _updateSpread(e) {
          const t = `${e || ''}`
          ;(0, Nt.updateTextNode)(this._spreadEl, t),
            this._updateVisibilityForSpreadQtyWrapper()
        }
        _updateQty(e) {
          let t = `${e || ''}`
          !this._isCalcOpened &&
            t.length > 0 &&
            (t = (0, F.abbreviatedNumber)(Number(t))),
            (0, Nt.updateTextNode)(this._qtyTextEl, t)
        }
        _updateHighButtonsMode(e) {
          this._buttonsWrapperEl.classList.toggle(Lt.highButtons, e)
        }
        _updateBgButtonsMode(e) {
          var t
          this._buttonsWrapperEl.classList.toggle(Lt.withoutBg, !e),
            null === (t = this._informerWrapperEl) ||
              void 0 === t ||
              t.classList.toggle(Vt.blockHidden, !e)
        }
        _updateVisibilityForSpreadQtyWrapper() {
          const e = !this._isQtyVisible.value() && null === this._spread.value()
          this._spreadQtyWrapper.classList.toggle(Vt.blockHidden, e)
        }
        _updateQtyVisibility(e) {
          this._qtyEl.classList.toggle(Vt.blockHidden, !e),
            this._spreadQtyWrapper.classList.toggle(Lt.withoutQty, !e),
            this._updateVisibilityForSpreadQtyWrapper()
        }
        _updateVisibility() {
          var e
          const t =
            this._isVisible.value() &&
            0 !== this._mode &&
            !this._isHiddenByViewport
          this._buttonsWrapperEl.classList.toggle(Vt.blockHidden, !t),
            null === (e = this._informerWrapperEl) ||
              void 0 === e ||
              e.classList.toggle(Vt.blockHidden, !t || !this._canTrade.value())
        }
        _updateLastDigitSup() {
          this._updateBuyButton(this._ask.value()),
            this._updateSellButton(this._bid.value())
        }
        _updateButtonTooltip(e, t) {
          if ('' === t)
            return (
              (0, Et.setTooltipData)(e, 'text', t),
              void e.removeAttribute('title')
            )
          e.setAttribute('title', t)
        }
        _toggleCalcVisibility() {
          ;(this._isCalcOpened = !this._isCalcOpened), this._renderCalc()
        }
        _closeCalc() {
          ;(this._isCalcOpened = !1),
            this._updateQty(this._qty.value()),
            this._model.applyQty(),
            this._renderCalc()
        }
        _renderCalc() {
          Promise.all([
            i.e(580),
            i.e(8194),
            i.e(7845),
            i.e(4474),
            i.e(17),
            i.e(7125),
            i.e(3809),
          ])
            .then(i.bind(i, 713191))
            .then(async (e) => {
              const t = await this._model.getQtyInfo()
              null !== t &&
                e.render(this._isCalcOpened, this._calcContainer, {
                  ...t,
                  withInput: !0,
                  valueGetter: this._getCurrentQty,
                  position: this._getCalcPosition(),
                  targetEl: this._qtyEl,
                  onClose: this._closeCalc.bind(this),
                  onValueChange: this._model.setQty,
                  trackEventTarget: 'Sell/Buy Buttons',
                  trackEvent: this._trackEvent,
                })
            })
        }
        _getCalcPosition() {
          return (0, Ot.getPopupPositioner)(this._qtyEl, {
            horizontalAttachEdge: Ot.HorizontalAttachEdge.Left,
            horizontalDropDirection: Ot.HorizontalDropDirection.FromLeftToRight,
          })
        }
        _windowResizeHandler() {
          false !== this._isHiddenByViewport &&
            ((this._isHiddenByViewport = false), this._updateVisibility())
        }
      }
      const zt = s.t(null, void 0, i(73953))
      class $t {
        constructor(e, t, i, r, s, o, n, a) {
          const { showSellBuyButtons: l, noConfirmEnabled: c, themeName: d } = o
          ;(this._showSellBuyButtons = l),
            (this._isEconomySymbol = i),
            (this._isInReplay = n),
            (this._trackEvent = s.trackEvent),
            (this._model = new Ct({
              dataEvents: e,
              getSymbolName: t,
              isNonTradableInstrument: i.spawnOwnership(),
              qtySuggester: r,
              tradingCommands: s,
              settings: {
                noConfirmEnabled: c,
                themeName: d,
                showSellBuyButtons: l.spawnOwnership(),
              },
              isInReplay: n.spawnOwnership(),
              hibernated: a,
            })),
            (this._renderer = new Ut({
              model: this._model,
              highButtonsMode: c.spawnOwnership(),
              trackEvent: s.trackEvent,
              toggleMinimizeBottomWidgetBar: s.toggleMinimizeBottomWidgetBar,
            }))
        }
        destroy() {
          this._model.destroy(),
            this._renderer.destroy(),
            this._isEconomySymbol.release(),
            this._isInReplay.release(),
            this._showSellBuyButtons.release()
        }
        renderTo(e, t) {
          this._renderer.renderTo(e, t)
        }
        setGlobalVisibility(e) {
          this._model.setGlobalVisibility(e)
        }
        visibility() {
          return this._model.visible
        }
        updateWidgetModeBySize(e) {
          this._renderer.updateModeByWidth(e.width)
        }
        contextMenuActions() {
          if (this._renderer.isHiddenByViewport()) return []
          return [
            new wt.Action({
              actionId: 'Trading.SellBuyButtonsToggleVisibility',
              options: {
                checkable: !0,
                checked: this._showSellBuyButtons.value(),
                label: zt,
                disabled:
                  this._isInReplay.value() || this._isEconomySymbol.value(),
                onExecute: () => {
                  const e = !this._showSellBuyButtons.value()
                  this._showSellBuyButtons.setValue(e),
                    this._trackEvent(
                      'SellBuyButtonsWidget context menu',
                      'Show Sell/Buy Button',
                      e ? 'Check' : 'Uncheck',
                    )
                },
              },
            }),
          ]
        }
        height() {
          return this._renderer.height()
        }
      }
      var Ht = i(744633)
      function Qt(e) {
        return be.createElement('span', { className: Ht.separator })
      }
      var jt = i(783806),
        Kt = i(112235),
        Gt = i(19406),
        Zt = i(533408),
        Jt = i(640712)
      const Xt = be.forwardRef((e, t) =>
        be.createElement(
          'div',
          { ref: t, className: Jt.popupWrapper },
          e.children,
        ),
      )
      var Yt = i(753327)
      const ei = (() => {
          let e,
            t,
            r,
            s = null,
            o = null
          return async (n, a, l, c) => {
            const u = null == n ? void 0 : n.currentAccount()
            if (null === s || o !== n || e !== u || r !== c) {
              null == t || t.remove()
              const { AccountManager: h } = await Promise.all([
                  i.e(2666),
                  i.e(4015),
                  i.e(3842),
                  i.e(6),
                  i.e(5649),
                  i.e(8056),
                  i.e(5993),
                  i.e(2639),
                  i.e(3502),
                  i.e(9842),
                  i.e(7080),
                  i.e(6747),
                  i.e(6884),
                  i.e(4578),
                  i.e(2486),
                  i.e(2251),
                  i.e(5896),
                  i.e(6874),
                  i.e(2069),
                  i.e(9255),
                  i.e(8210),
                  i.e(5267),
                  i.e(8951),
                  i.e(4811),
                  i.e(8413),
                  i.e(3637),
                  i.e(2874),
                  i.e(5951),
                  i.e(8354),
                ]).then(i.bind(i, 225604)),
                p = { container: a, visible: new d.WatchedValue(!0) }
              ;(s = a),
                (o = n),
                (e = u),
                (r = c),
                (t = await h.create({
                  broker: n,
                  bridge: p,
                  mode: 0,
                  overlapManager: l,
                  summaryFieldsVisibilityManager: c,
                }))
            } else a.appendChild(s)
          }
        })(),
        ti = new d.WatchedValue(null)
      function ii(e) {
        const { broker: t, summaryFieldsVisibilityManager: i } = e,
          r = (0, be.useRef)(null),
          s = (0, be.useContext)(Yt.SlotContext)
        return (
          (0, be.useEffect)(() => {
            ti.setValue(s)
          }, [s]),
          (0, be.useEffect)(() => {
            null !== r.current && ei(t, r.current, ti.readonly(), i)
          }, []),
          be.createElement(Xt, { ref: r })
        )
      }
      var ri = i(132455),
        si = i(407999),
        oi = i(241347),
        ni = i(517516)
      const ai = s.t(null, void 0, i(890801))
      class li extends Gt.DialogRenderer {
        constructor(e) {
          super(),
            (this._title = ai),
            (this._isSubscribed = !1),
            (this._showSeparator = !0),
            (this._handleClose = () => {
              Te.unmountComponentAtNode(this._container),
                this._setVisibility(!1)
            }),
            (this._trading = e)
        }
        visible() {
          return this._visibility.spawn().readonly()
        }
        show() {
          this._isSubscribed ||
            ((this._isSubscribed = !0),
            this._onStatusChange(this._trading.connectStatus()),
            this._trading.onConnectionStatusChange.subscribe(
              this,
              this._onStatusChange,
            )),
            this._setVisibility(!0),
            this._renderComponent()
        }
        hide() {
          this._handleClose()
        }
        _onStatusChange(e, t) {
          var i, r
          null === (i = this._trading.activeBroker()) ||
            void 0 === i ||
            i.currentAccountUpdate.unsubscribe(
              this,
              this._renderAccountManager,
            ),
            this._connectStatus !== e &&
              ((this._connectStatus = e),
              (this._additionalHeaderElement = void 0),
              window.navigator.onLine
                ? 2 !== e &&
                  (null == t ? void 0 : t.disconnectType) !==
                    I.DisconnectType.Offline &&
                  3 !== e &&
                  4 !== e
                  ? 1 === e &&
                    (null === (r = this._trading.activeBroker()) ||
                      void 0 === r ||
                      r.currentAccountUpdate.subscribe(
                        this,
                        this._renderAccountManager,
                      ),
                    this._renderAccountManager())
                  : this._renderSpinner()
                : this._renderOfflineScreen())
        }
        _renderComponent() {
          Te.render(
            be.createElement(Zt.AdaptivePopupDialog, {
              dataName: 'trading-dialog',
              isOpened: this.visible().value(),
              onClose: this._handleClose,
              showSeparator: this._showSeparator,
              fullScreen: !0,
              draggable: !1,
              title: this._title,
              render: () => this._content,
              additionalHeaderElement: this._additionalHeaderElement,
              additionalElementPos: 'after',
              headerClassName: ni.header,
            }),
            this._container,
          )
        }
        _renderSpinner() {
          ;(this._showSeparator = !0),
            (this._title = ai),
            this._changeDialogContent(be.createElement(ri.Spinner, null))
        }
        _renderOfflineScreen() {
          ;(this._title = ai),
            this._changeDialogContent(be.createElement(Kt.OfflineScreen, null))
        }
        async _renderBrokerSelectScreen() {
          0
        }
        async _renderAccountManager() {
          const e = (0, r.ensureNotNull)(
              this._trading.activeBroker(),
            ).accountManagerInfo().summary,
            t = new oi.SummaryFieldsVisibilityManager(
              e,
              this._trading.getBrokerTradingSettingsStorage,
            ),
            s = await (0, si.makeAccountManagerHeaderDropdownsProps)(
              this._trading,
              t,
              0,
            )
          if (((this._showSeparator = !1), (this._title = ai), void 0 !== s)) {
            const { AccountManagerHeaderDropdowns: e } = await Promise.all([
              i.e(2666),
              i.e(4015),
              i.e(3842),
              i.e(6),
              i.e(5649),
              i.e(8056),
              i.e(5993),
              i.e(2639),
              i.e(3502),
              i.e(9842),
              i.e(7080),
              i.e(6747),
              i.e(6884),
              i.e(4578),
              i.e(2486),
              i.e(2251),
              i.e(5896),
              i.e(6874),
              i.e(2069),
              i.e(9255),
              i.e(8210),
              i.e(5267),
              i.e(8951),
              i.e(4811),
              i.e(8413),
              i.e(3637),
              i.e(2874),
              i.e(5951),
              i.e(8354),
            ]).then(i.bind(i, 605899))
            this._title = be.createElement(e, { ...s })
            {
              const e = { ...s.commonDropdownProps, iconSize: 'big' }
              this._additionalHeaderElement = be.createElement(
                'span',
                { className: ni.moreButton },
                be.createElement(jt.TerminalDropdown, { ...e }),
                be.createElement(Qt, null),
              )
            }
          }
          ;(this._content = be.createElement(ii, {
            broker: this._trading.activeBroker(),
            summaryFieldsVisibilityManager: t,
          })),
            this._renderComponent()
        }
        _changeDialogContent(e) {
          ;(this._content = be.createElement(Xt, null, e)),
            this._renderComponent()
        }
      }
      var ci,
        di = i(948776),
        ui = i(601227)
      async function hi(e, t) {
        localStorage.setItem(e, t)
      }
      !((e) => {
        ;(e.get = async () => (
          ui.CheckMobile.any() ||
            (await (async () => {
              const e = o.getValue(j.settingsKeys.ACTIVE_BROKER)
              if (
                (o.remove(j.settingsKeys.ACTIVE_BROKER, { forceFlush: !0 }),
                void 0 === e)
              )
                return
              await hi(j.settingsKeys.ACTIVE_BROKER, e)
            })()),
          (async (e) => localStorage.getItem(e))(j.settingsKeys.ACTIVE_BROKER)
        )),
          (e.set = async (e) => {
            await hi(j.settingsKeys.ACTIVE_BROKER, e)
          }),
          (e.clear = () => {
            o.remove(j.settingsKeys.ACTIVE_BROKER, { forceFlush: !0 }),
              localStorage.removeItem(j.settingsKeys.ACTIVE_BROKER)
          })
      })(ci || (ci = {}))
      var pi = i(960521),
        gi = i.n(pi),
        mi = i(173587),
        _i = i(233064),
        bi = i(218286),
        vi = i(169977),
        yi = i(312694),
        fi = i(749401),
        ki = i(265728),
        Si = i(482165),
        Pi = i(44681),
        Ci = i(99708)
      class wi {
        constructor(e) {
          ;(this._rawAndFilteredQtyMap = new Map()), (this._qtyInfo = new Map())
          const {
            symbolInfoGetter: t,
            onResetNeeded: i,
            qtySettingsStorageGetter: r,
          } = e
          ;(this._getQtySettingsStorage = r),
            (this._getSymbolInfo = t),
            i.subscribe(this, this._reset)
        }
        async getQty(e) {
          return (0, fi.firstValueFrom)(
            this._getRawAndFilteredQty(e).filteredQty$,
          )
        }
        setQty(e, t) {
          this._getRawAndFilteredQty(e).rawQty$.next(t)
        }
        suggestedQtyChanged(e) {
          return this._getRawAndFilteredQty(e).filteredQty$.pipe(
            (0, mi.skip)(1),
          )
        }
        _getRawAndFilteredQty(e) {
          var t
          return null !== (t = this._rawAndFilteredQtyMap.get(e)) &&
            void 0 !== t
            ? t
            : this._makeRawAndFilteredQty(e)
        }
        _makeRawAndFilteredQty(e) {
          const t = new ki.ReplaySubject(1),
            i = this._getInitialQty(e).pipe(
              (0, _i.switchMap)((e) => t.pipe((0, w.startWith)(e))),
              (0, bi.distinctUntilChanged)(),
              (0, vi.filter)((t) => this._isQtyCorrect(e, t)),
              (0, Si.tap)((t) => {
                var i
                return null === (i = this._getQtySettingsStorage()) ||
                  void 0 === i
                  ? void 0
                  : i.setSymbolQty(e, t)
              }),
              (0, yi.share)({
                connector: () => new ki.ReplaySubject(1),
                resetOnRefCountZero: !1,
              }),
            ),
            r = { rawQty$: t, filteredQty$: i }
          return this._rawAndFilteredQtyMap.set(e, r), r
        }
        _isQtyCorrect(e, t) {
          const i = (0, r.ensureDefined)(this._qtyInfo.get(e))
          return !(0, Ci.checkQtyError)(i, t, !0).res
        }
        _getInitialQty(e) {
          return (0, E.from)(this._getSymbolInfo(e)).pipe(
            (0, S.map)(({ qty: t }) => {
              var i
              this._qtyInfo.set(e, t)
              const r =
                  null === (i = this._getQtySettingsStorage()) || void 0 === i
                    ? void 0
                    : i.symbolQty(e),
                s = t.default || t.min
              return void 0 !== r && r > 0
                ? ((o = (0, Pi.clamp)(r, t.min, t.max)),
                  (n = t.min),
                  (a = t.step),
                  gi()(o).minus(n).div(a).round(0, 1).mul(a).plus(n).toNumber())
                : s
              var o, n, a
            }),
          )
        }
        _reset() {
          this._rawAndFilteredQtyMap.forEach(({ rawQty$: e }) => e.complete()),
            this._rawAndFilteredQtyMap.clear(),
            this._qtyInfo.clear()
        }
      }
      var Bi = i(316230)
      class Ti {
        constructor() {
          ;(this._context = null),
            (this._onContextChanged = new q.Delegate()),
            (this._contextChange = () => {
              this._onContextChanged.fire(this.context())
            })
        }
        context() {
          var e, t
          return null !==
            (t =
              null === (e = this._context) || void 0 === e
                ? void 0
                : e.externalContext()) && void 0 !== t
            ? t
            : null
        }
        setContext(e) {
          var t, i
          this._isEqualContexts(e) ||
            (this._clearSubscription(),
            (this._context = e),
            null === (t = this._context) ||
              void 0 === t ||
              t.onStatusChange().subscribe(this, this._contextChange),
            null === (i = this._context) ||
              void 0 === i ||
              i.onDataChange().subscribe(this, this._contextChange),
            this._contextChange())
        }
        onContextChanged() {
          return this._onContextChanged
        }
        clear() {
          this.setContext(null)
        }
        _clearSubscription() {
          var e, t
          null === (e = this._context) ||
            void 0 === e ||
            e.onDataChange().unsubscribeAll(this),
            null === (t = this._context) ||
              void 0 === t ||
              t.onStatusChange().unsubscribeAll(this)
        }
        _isEqualContexts(e) {
          var t
          return null === this._context || null === e
            ? this._context === e
            : (null === (t = this.context()) || void 0 === t
                ? void 0
                : t.type) === (null == e ? void 0 : e.externalContext().type) &&
                this._context.status() === e.status() &&
                  (0, Bi.default)(this._context.errors(), e.errors()) &&
                (0, Bi.default)(this._context.data(), e.data())
        }
      }
      var Ei = i(688401)
      function Oi() {
        var e
        return null !== (e = Ei.linking.ensuredProSymbol.value()) &&
          void 0 !== e
          ? e
          : Ei.linking.proSymbol.value()
      }
      class Di {
        constructor(e) {
          ;(this._onSymbolChange = (e) => {
            this._processSymbol(null, e)
          }),
            (this._processSymbol = async (e, t) => {
              if (void 0 === this._continuousFrontContractExtractor)
                return void this._value.next({ symbol: t })
              const i = this._continuousFrontContractExtractor
                .makeValueObservable(t)
                .subscribe((e) => this._value.next(e))
              null == e ||
                e.addEventListener('abort', () => i.unsubscribe(), { once: !0 })
            }),
            (this._getContinuousFrontContractExtractor = e)
          const t = Oi()
          this._value = new f.BehaviorSubject({ symbol: t })
          void 0 !== (this._continuousFrontContractExtractor = e()) &&
            this._onSymbolChange(t),
            (this._processSymbol = (0, z.respectLatest)(this._processSymbol)),
            Ei.linking.ensuredProSymbol.subscribe(this._onSymbolChange)
        }
        reset() {
          ;(this._continuousFrontContractExtractor =
            this._getContinuousFrontContractExtractor()),
            this._onSymbolChange(Oi())
        }
        value() {
          return this._value.getValue()
        }
        async setSymbol(e) {
          const t = (0, fi.firstValueFrom)(
            this._value.pipe(
              (0, vi.filter)(
                (t) =>
                  t.continuous === e ||
                  (void 0 === t.continuous && t.symbol === e),
              ),
            ),
          )
          Ei.linking.setSymbolAndLogInitiator(e, 'trading linking'), await t
        }
        valueObservable() {
          return this._value.asObservable()
        }
      }
      class Ii {
        constructor() {
          ;(this._title$ = new f.BehaviorSubject('')),
            (this._description$ = new f.BehaviorSubject(void 0)),
            (this._symbol$ = new f.BehaviorSubject('')),
            (this._hasBatsQuotes$ = new f.BehaviorSubject(!1)),
            (this._hasDelayedQuotes$ = new f.BehaviorSubject(!1)),
            (this._isTradable$ = new f.BehaviorSubject(!1)),
            (this._backFunction$ = new f.BehaviorSubject(void 0)),
            (this._closeFunction$ = new f.BehaviorSubject(void 0)),
            (this._cancelFunction$ = new f.BehaviorSubject(void 0)),
            (this._informerMessage$ = new f.BehaviorSubject(void 0)),
            (this._settings$ = new f.BehaviorSubject(void 0)),
            (this.title$ = this._title$.asObservable()),
            (this.description$ = this._description$.asObservable()),
            (this.symbol$ = this._symbol$.asObservable()),
            (this.hasBatsQuotes$ = this._hasBatsQuotes$.asObservable()),
            (this.hasDelayedQuotes$ = this._hasDelayedQuotes$.asObservable()),
            (this.isTradable$ = this._isTradable$.asObservable()),
            (this.backFunction$ = this._backFunction$.asObservable()),
            (this.closeFunction$ = this._closeFunction$.asObservable()),
            (this.cancelFunction$ = this._cancelFunction$.asObservable()),
            (this.informerMessage$ = this._informerMessage$.asObservable()),
            (this.settings$ = this._settings$.asObservable())
        }
        setTitle(e) {
          this._title$.next(e)
        }
        setDescription(e) {
          this._description$.next(e)
        }
        setSymbol(e) {
          this._symbol$.next(e)
        }
        setHasBatsQuotes(e) {
          this._hasBatsQuotes$.next(e)
        }
        setHasDelayedQuotes(e) {
          this._hasDelayedQuotes$.next(e)
        }
        setIsTradable(e) {
          this._isTradable$.next(e)
        }
        setBackFunction(e) {
          this._backFunction$.next(e)
        }
        setCloseFunction(e) {
          this._closeFunction$.next(e)
        }
        setCancelFunction(e) {
          this._cancelFunction$.next(e)
        }
        setInformerMessage(e) {
          this._informerMessage$.next(e)
        }
        setSettings(e) {
          this._settings$.next(e)
        }
      }
      var xi = i(930202),
        Mi = i(725784),
        Ai = i(886495)
      function Ni(e) {
        const { children: t, tooltipText: i, tooltipHotKey: r } = e
        return be.createElement(
          'span',
          {
            className: Oe()('apply-common-tooltip', Ai.content),
            'data-tooltip-hotkey': r,
            title: i,
          },
          be.createElement('span', { className: Ai.contentInner }, t),
        )
      }
      const Li = (0, Mi.hotKeySerialize)({
          keys: [(0, xi.humanReadableModifiers)(xi.Modifiers.Shift, !1), 'T'],
          text: '{0} + {1}',
        }),
        Vi = (0, Mi.hotKeySerialize)({
          keys: [(0, xi.humanReadableModifiers)(xi.Modifiers.Shift, !1), 'D'],
          text: '{0} + {1}',
        })
      class Ri {
        constructor(e) {
          ;(this._transientStorage = {}),
            (this._persistentStorageKey = `trading.${e}`)
          const t = o.getJSON(this._persistentStorageKey, {})
          delete t.orderTicketQuantity, (this._transientStorage = t)
        }
        setTakeProfitPips(e, t, i) {
          this._setPips('takeProfit', e, t, i)
        }
        takeProfitPips(e) {
          return this._getSectionValue('takeProfit', e)
        }
        setStopLossPips(e, t, i) {
          this._setPips('stopLoss', e, t, i)
        }
        stopLossPips(e) {
          return this._getSectionValue('stopLoss', e)
        }
        setDuration(e, t, i) {
          const r = this.duration(e, t)
          ;(null !== i &&
            void 0 !== r &&
            r.type === i.type &&
            r.datetime === i.datetime) ||
            (null === i && void 0 === r) ||
            (this._setDuration(e, t, i), this._syncStorage())
        }
        duration(e, t) {
          var i
          return (
            this._migrateDuration(e, t),
            null === (i = this._getSectionValue('duration', e)) || void 0 === i
              ? void 0
              : i[t]
          )
        }
        setSymbolQty(e, t) {
          ;(this._getOrCreateSection('qty')[e] = t), this._syncStorage()
        }
        symbolQty(e) {
          return this._getSectionValue('qty', e)
        }
        setCustomFields(e, t, i) {
          var r, s, o
          const n = this._getOrCreateSection('customFields')
          ;(null !== (r = n[e]) && void 0 !== r) || (n[e] = {}),
            (null !== (s = (o = n[e])[t]) && void 0 !== s) || (o[t] = {})
          const a = n[e][t]
          for (const [e, t] of Object.entries(i))
            ('string' == typeof t && '' !== t) || 'boolean' == typeof t
              ? (a[e] = t)
              : delete a[e]
          0 === Object.keys(a).length && delete n[e][t],
            0 === Object.keys(n[e]).length && delete n[e],
            this._syncStorage()
        }
        customFields(e, t, i) {
          this._migrateCustomFields(e, t, i)
          const r = {},
            s = this._transientStorage.customFields
          if (void 0 === s || void 0 === s[e]) return r
          const o = s[e][t]
          return (
            void 0 === o ||
              i.forEach((e) => {
                const t = o[e]
                '' !== t && void 0 !== t && (r[e] = t)
              }),
            r
          )
        }
        orderType(e) {
          return this._getSectionValue('orderType', e)
        }
        setOrderType(e, t) {
          ;(this._getOrCreateSection('orderType')[e] = t), this._syncStorage()
        }
        setTableColumnsOrder(e, t) {
          ;(this._getOrCreateSection('tableColumnsOrder')[e] = t),
            this._syncStorage()
        }
        tableColumnsOrder(e) {
          return this._getSectionValue('tableColumnsOrder', e)
        }
        setOrderSizeCalculatorState(e, t) {
          null === t
            ? this._removeValue('orderSizeCalculatorState', e)
            : (this._getOrCreateSection('orderSizeCalculatorState')[e] = {
                ...t,
              }),
            this._syncStorage()
        }
        orderSizeCalculatorState(e) {
          const t = this._getSectionValue('orderSizeCalculatorState', e)
          return void 0 !== t ? { ...t } : void 0
        }
        summaryFieldsVisibilityInfo() {
          const e = new Map(),
            t = this._transientStorage.summaryFields
          if (void 0 === t) return e
          for (const [i, r] of Object.entries(t))
            e.set(i, { id: i, visible: r })
          return e
        }
        setSummaryFieldsVisibilityInfo(e) {
          e.forEach(({ id: e, visible: t }) => {
            this._getOrCreateSection('summaryFields')[e] = t
          }),
            this._syncStorage()
        }
        _getOrCreateSection(e) {
          return (
            e in this._transientStorage || (this._transientStorage[e] = {}),
            this._transientStorage[e]
          )
        }
        _getSectionValue(e, t) {
          const i = this._transientStorage[e]
          return void 0 !== i ? i[t] : void 0
        }
        _removeValue(e, t) {
          const i = this._transientStorage[e]
          void 0 !== i &&
            (delete i[t],
            0 === Object.keys(i).length && delete this._transientStorage[e])
        }
        _setPips(e, t, i, r) {
          const s = this._getSectionValue(e, t)
          if (!((void 0 !== s && s === i) || (void 0 === s && i === r))) {
            if (void 0 !== s && i === r) this._removeValue(e, t)
            else {
              this._getOrCreateSection(e)[t] = i
            }
            this._syncStorage()
          }
        }
        _setDuration(e, t, i) {
          var r
          const s = this._getOrCreateSection('duration')
          if (null === i) {
            if (void 0 === s[e]) return
            return (
              delete s[e][t],
              void (0 === Object.keys(s[e]).length && delete s[e])
            )
          }
          ;(null !== (r = s[e]) && void 0 !== r) || (s[e] = {}), (s[e][t] = i)
        }
        _migrateCustomFields(e, t, i) {
          const r = {},
            s = this._transientStorage.customFields
          void 0 === s ||
            ('object' == typeof s && void 0 !== s[e]) ||
            (i.forEach((t) => {
              const i = s[`${e}.${t}`]
              '' !== i &&
                void 0 !== i &&
                ((r[t] = i), this._removeValue('customFields', `${e}.${t}`))
            }),
            this.setCustomFields(e, t, r))
        }
        _migrateDuration(e, t) {
          const i = this._getSectionValue('duration', e)
          if ('string' != typeof i) return
          const r = { type: i },
            s = this._getSectionValue('durationDatetime', e)
          'number' == typeof s &&
            ((r.datetime = s), this._removeValue('durationDatetime', e)),
            this._removeValue('duration', e),
            this._setDuration(e, t, r),
            this._syncStorage()
        }
        _syncStorage() {
          o.setJSON(this._persistentStorageKey, this._transientStorage)
        }
      }
      const Fi = (0, c.getLogger)('Trading.Core'),
        Wi = { 1: 'Connected', 2: 'Connecting', 3: 'Disconnected', 4: 'Error' },
        qi = 'alert/alarm_clock'
      function Ui(e) {
        return _().some((t) => e === t.path)
      }
      const zi = R.enabled('buy_sell_buttons'),
        $i = !0,
        Hi = (window.TRADING_SERVER_LOGGER_URL, 'Shortcut')
      class Qi {
        constructor(e, t) {
          ;(this.accountType = new d.WatchedValue()),
            (this.onBrokerChange = new q.Delegate()),
            (this.onBrokerLoading = new q.Delegate()),
            (this.onConnectionStatusChange = new q.Delegate()),
            (this.onNewNotification = new q.Delegate()),
            (this.onNeedSelectBroker = new q.Delegate()),
            (this.onNotificationsChanged = new q.Delegate()),
            (this.showTradedSources = new d.WatchedValue(!0)),
            (this.showSellBuyButtons = new d.WatchedValue()),
            (this.noConfirmEnabled = new d.WatchedValue()),
            (this.showOnlyRejectionNotifications = new d.WatchedValue()),
            (this.showPricesWithZeroVolume = new d.WatchedValue()),
            (this.showSpread = new d.WatchedValue()),
            (this.orderExecutedSoundParams = (() => {
              const e = Ui(qi) ? qi : _()[0].path
              return {
                enabled: new d.WatchedValue(!1),
                path: new d.WatchedValue(e),
              }
            })()),
            (this._activeBroker = null),
            (this._orderViewController = null),
            (this._orderControllerPromise = null),
            (this._brokerCommandsUI = null),
            (this._showPricesWithZeroVolume = new d.WatchedValue()),
            (this._showSpread = new d.WatchedValue()),
            (this._closePositionDialogVisibility = new $.DialogVisibility()),
            (this._orderDialogVisibility = new $.DialogVisibility()),
            (this._loginDialogVisibility = new $.DialogVisibility()),
            (this._tradingPanelPopupVisibility = new $.DialogVisibility()),
            (this._tradingSettingsStorage = null),
            (this._offlineListener = this._offlineHandler.bind(this)),
            (this._onlineListener = this._onlineHandler.bind(this)),
            (this._notifications = []),
            (this._account = null),
            (this._domPanelVisibility = new d.WatchedValue(!1)),
            (this._orderPanelVisibility = new d.WatchedValue(!1)),
            (this._pipValueType$ = new f.BehaviorSubject(I.PipValueType.None)),
            (this._switchingBroker = !1),
            (this._isReconnectNeeded = !1),
            (this._accountVerificationPromise = null),
            (this._chartWidgetCollection = null),
            (this._tradedItemsChartCollectionFacadePromise = null),
            (this._tradeNowBrokerId = null),
            (this.getBrokerTradingSettingsStorage = () =>
              this._tradingSettingsStorage),
            (this.trackEvent = (e, t, i) => {
              const r = e ? `[${e}] ${t}` : t
              if (this._gui()) {
                const e = this._activeBroker
                    ? this._activeBroker.metainfo().id + ' Trading'
                    : 'Trading No Broker',
                  t = this._activeBroker
                    ? this._activeBroker.currentAccountType()
                    : void 0
                this._gui().trackEvent(e, r, i || t)
              }
            }),
            (this.showErrorNotification = (e, t, i = 25e3) => {
              this._showNotification(e, t, 'danger', i),
                R.enabled('show_trading_notifications_history') &&
                  this._addNotificationRow(e, t, 'danger', i),
                this._log(e, t)
            }),
            (this.setDOMPanelVisibility = (e, t = !0) => {
              ;(e && t && !this._makeSureCanTrade()) ||
                (e
                  ? this.tradingPanel.openPage(H.TradingPage.DOMPanel)
                  : this.tradingPanel.close())
            }),
            (this.setOrderPanelVisibility = async (e, t = !0) => {
              if (e && t && !this._makeSureCanTrade()) return
              const { openPanel: i, closePanel: r } =
                await this._getOrderViewController()
              e ? await i() : await r()
            }),
            (this.getTradeNowBrokerId = () => this._tradeNowBrokerId),
            (this.clearTradeNowBrokerId = () => {
              this._tradeNowBrokerId = null
            }),
            (this.toggleTradingPanelVisibility = async () => {
              const e = this._orderDialogVisibility.getValue().isVisible,
                t = this.tradingPanel.isOpened.value()
              e
                ? this.setDOMPanelVisibility(!t)
                : this._updateTradingPanelVisibility({ isOpened: !t })
            }),
            (this._handleVisibilityChange = () => {
              null !== this._activeBroker &&
                this._activeBroker.metainfo().configFlags.usesWSConnection &&
                'visible' !== document.visibilityState &&
                ((this._isReconnectNeeded = !0),
                this._selectBrokerInternal({
                  brokerId: null,
                  isUserAction: !1,
                  keepSessionAlive: !1,
                  disconnectInfo: {
                    disconnectType: I.DisconnectType.BrokenConnection,
                  },
                }).then(() => {
                  if (this._isReconnectNeeded)
                    return this._tryReconnectLastBroker()
                }))
            }),
            (this._tryReconnectLastBroker = async () => {
              if (this._isReconnectNeeded) {
                if ('hidden' === document.visibilityState)
                  return window.addEventListener(
                    'visibilitychange',
                    this._tryReconnectLastBroker,
                    { once: !0 },
                  )
                ;(this._isReconnectNeeded = !1), await this._selectLastBroker()
              }
            }),
            (this._onCurrentAccountUpdate = () => {
              const e = (0, r.ensureNotNull)(
                this._activeBroker,
              ).currentAccount()
              this._account !== e &&
                (this._tradedContextLinking.clear(),
                (this._account = e),
                this.onNotificationsChanged.fire(this.getNotifications()))
            }),
            (this._onFullScreenDialogOpen = () => {
              this._guiAccessor.closeAllNotifications()
            }),
            (this._setPipValueType = async () => {
              const { symbol: e } = this._linking.value(),
                { type: t } = await this._realtimeProvider.symbolInfo(e),
                i = 'forex' === t ? I.PipValueType.Pips : I.PipValueType.Ticks
              this._pipValueType$.next(i)
            }),
            (this._trackNonTradableSymbol = async () => {
              var e
              if (
                1 ===
                (null === (e = this._activeBroker) || void 0 === e
                  ? void 0
                  : e.connectionStatus())
              ) {
                const { symbol: e } = this._linking.value()
                if (void 0 === e) return
                const t = await this._activeBroker.isTradable(e)
                t && !t.tradable && this.trackEvent('Symbol is not tradable', e)
              }
            }),
            (this._onBrokerChanged = (e) => {
              if (null === e) return void (this._tradingSettingsStorage = null)
              const t = e.metainfo()
              this._tradingSettingsStorage = new Ri(t.id)
            }),
            (this._tradeNow = async () => {
              if (
                void 0 !== window.TradingView.bottomWidgetBar &&
                null !== this._tradeNowBrokerId
              )
                try {
                  await window.TradingView.bottomWidgetBar.toggleWidget(
                    'paper_trading',
                    !0,
                  )
                } catch (e) {
                  this._tradingWizard.drawAttention()
                }
            }),
            (this._updateTradingPanelVisibility = (e) => {
              const {
                  isOpeningAvailable:
                    t = this.tradingPanel.isOpeningAvailable.value(),
                  isOpened: i = this.tradingPanel.isOpened.value(),
                  activePage: r = this.tradingPanel.activePage.value(),
                  shouldCanTrade: s,
                } = e,
                o = t && i
              r === H.TradingPage.OrderPanel
                ? this.setOrderPanelVisibility(o, s)
                : this.setDOMPanelVisibility(o, s)
            }),
            (this._toggleTradingPanelPage = (e) => {
              e !== this.tradingPanel.activePage.value() &&
                (e === H.TradingPage.OrderPanel &&
                  this.setOrderPanelVisibility(!0),
                e === H.TradingPage.DOMPanel && this.setDOMPanelVisibility(!0))
            }),
            (this._onLinkingSymbolChange = (e) => {
              var t
              e.symbol !==
                (null === (t = this._tradedContextLinking.context()) ||
                void 0 === t
                  ? void 0
                  : t.data().symbol) && this._tradedContextLinking.clear()
            }),
            (this._linking = new Di(
              () => this._continuousFrontContractExtractor,
            )),
            (this._abortController = new AbortController()),
            (this._setPipValueType = (0, V.sequentialize)(
              this._setPipValueType,
            )),
            (this._selectBrokerInternal = (0, V.sequentialize)(
              this._selectBroker,
            )),
            void 0 !== navigator.locks &&
              (this._selectBrokerInternal = (e) =>
                navigator.locks.request(
                  `select-broker-${e.brokerId}`,
                  { ifAvailable: !0 },
                  (t) =>
                    this._selectBroker({
                      ...e,
                      hasConcurrentSession: null === t,
                    }),
                )),
            (this._showSellBuyButtonsKey = this._makeShowSellBuyButtonsKey()),
            (this._resizerBridge = e),
            (this._realtimeProvider = new Y(
              () => this.activeBroker(),
              this.onBrokerChange,
              this.onConnectionStatusChange,
              (e) => this.getActualSymbol(e),
            )),
            (this._positionService = new dt.PositionsService(this)),
            (this._ordersService = new ut.OrdersService(this)),
            (this._tradingStat = new te(this)),
            (this._serverLogger = null),
            (this._tradedContextLinking = new Ti()),
            this.onBrokerChange.subscribe(this, this._onBrokerChanged),
            (this.tradingPanelPopup = new li(this)),
            this.tradingPanelPopup.visible().subscribe((e) => {
              e
                ? (this._tradingPanelPopupVisibility.setValue({
                    isVisible: e,
                    isFullScreen: !0,
                  }),
                  this._onFullScreenDialogOpen())
                : this._tradingPanelPopupVisibility.setValue({ isVisible: e })
            })
          const i = this._makeTradingPanelTabsConfig()
          this.tradingPanel = new Ge(e, i)
          ;(this._qtySuggester = new wi({
            onResetNeeded: this.onConnectionStatusChange,
            symbolInfoGetter: (e) => this._realtimeProvider.symbolInfo(e),
            qtySettingsStorageGetter: () => this._tradingSettingsStorage,
          })),
            (this._qtySuggesterWithOrderSizeCalculatorResetting = {
              getQty: this._qtySuggester.getQty.bind(this._qtySuggester),
              suggestedQtyChanged: this._qtySuggester.suggestedQtyChanged.bind(
                this._qtySuggester,
              ),
              setQty: (e, t) => this._qtySuggester.setQty(e, t),
            })
          const s = new Ce(
            e,
            () => this.tradingPanel.close(),
            this,
            this._qtySuggesterWithOrderSizeCalculatorResetting,
            this._linking,
            new Ii(),
          )
          this.tradingPanel.addPage(H.TradingPage.DOMPanel, s),
            (this._orderPanelHeaderState = new Ii())
          const o = new we(this._orderPanelHeaderState)
          this.tradingPanel.addPage(H.TradingPage.OrderPanel, o),
            this._updateTradingPanelVisibility({ shouldCanTrade: !1 }),
            this.tradingPanel.isOpeningAvailable.subscribe(async (e) => {
              this._updateTradingPanelVisibility({ isOpeningAvailable: e })
            }),
            (0, W.combine)(
              () => ({}),
              this.tradingPanel.activePage.weakReference(),
              this.tradingPanel.isOpened.weakReference(),
            ).subscribe(() => {
              this._domPanelVisibility.setValue(
                this.tradingPanel.isPageOpened(H.TradingPage.DOMPanel),
              ),
                this._orderPanelVisibility.setValue(
                  this.tradingPanel.isPageOpened(H.TradingPage.OrderPanel),
                )
            }),
            (this.closePositionDialogVisibility =
              this._closePositionDialogVisibility.value$),
            (this.orderDialogVisibility = this._orderDialogVisibility.value$),
            (this.loginDialogVisibility = this._loginDialogVisibility.value$),
            (this.possibleFullScreenDialogsVisibility = (0, k.merge)(
              this.closePositionDialogVisibility.pipe(
                (0, S.map)((e) => ({ ...e, name: 'close-position-dialog' })),
              ),
              this.orderDialogVisibility.pipe(
                (0, S.map)((e) => ({ ...e, name: 'order-dialog' })),
              ),
              this.loginDialogVisibility.pipe(
                (0, S.map)((e) => ({ ...e, name: 'login-dialog' })),
              ),
              this._tradingPanelPopupVisibility.value$.pipe(
                (0, S.map)((e) => ({ ...e, name: 'trading-panel-popup' })),
              ),
            )),
            this._linking
              .valueObservable()
              .subscribe(this._onLinkingSymbolChange)
        }
        setChartWidgetCollection(e) {
          ;(0, r.assert)(
            null === this._chartWidgetCollection,
            'ChartWidgetCollection can be set only once',
          ),
            (this._chartWidgetCollection = e),
            (this._guiAccessor = new ne(e)),
            new it(this),
            this._loadState(),
            o.onSync.subscribe(this, this._loadState)
          const t = () => {
            this._save()
          }
          this.showSellBuyButtons.subscribe(t),
            this.noConfirmEnabled.subscribe(t),
            this.showOnlyRejectionNotifications.subscribe(t),
            this._showPricesWithZeroVolume.subscribe(t),
            this._showSpread.subscribe(t),
            this.orderExecutedSoundParams.enabled.subscribe(t),
            this.orderExecutedSoundParams.path.subscribe(t),
            window.addEventListener('offline', this._offlineListener),
            window.addEventListener('online', this._onlineListener),
            this.bindShortcuts(),
            (this._tradedItemsChartCollectionFacadePromise =
              this._createTradedItemsChartCollectionFacade(e)),
            this._registerCustomSources(e),
            this._registerCustomWidgets(e)
        }
        showPricesWith() {
          return {
            zeroVolume: this._showPricesWithZeroVolume,
            spread: this._showSpread,
          }
        }
        domPanelVisibility() {
          return this._domPanelVisibility
        }
        orderPanelVisibility() {
          return this._orderPanelVisibility
        }
        realtimeProvider() {
          return this._realtimeProvider
        }
        toggleTradingPanelPopup() {
          this.tradingPanelPopup.visible().value()
            ? this.tradingPanelPopup.hide()
            : this.tradingPanelPopup.show()
        }
        toggleTradingWidget() {
          return window.TradingView.bottomWidgetBar
            ? window.TradingView.bottomWidgetBar.activateTradingTab()
            : Promise.resolve()
        }
        toggleMinimizeBottomWidgetBar() {
          if (window.TradingView.bottomWidgetBar)
            return window.TradingView.bottomWidgetBar.toggleMinimize()
        }
        bottomWidgetBarMode() {
          if (!window.TradingView.bottomWidgetBar)
            throw new Error(
              'Unable to provide bottom widget mode: bottomWidgetBar undefined',
            )
          return window.TradingView.bottomWidgetBar.mode()
        }
        tradingWizard() {
          return this._tradingWizard
        }
        showTradingProperties() {
          this._gui() && this._gui().showTradingProperties()
        }
        linking() {
          return this._linking
        }
        async brokersMetainfo() {
          return await this._brokersRegistrationPromise, Q.brokersList()
        }
        brokersList() {
          return getBrokersList()
        }
        brokersPlans() {
          return this._getBrokersPlans()
        }
        activeBroker() {
          return this._activeBroker
        }
        brokerCommandsUI() {
          return this._brokerCommandsUI
        }
        async selectBroker(e, t) {
          await this._selectBrokerInternal({
            brokerId: e,
            isUserAction: !0,
            keepSessionAlive: t,
          })
        }
        async pickDefaultBroker() {
          if (this._activeBroker) return
          let e = null
          const t = (await this.brokersMetainfo()).filter(
            (e) => !e.configFlags.isSuspended,
          )
          if (1 === t.length) e = t[0].id
          else {
            const i = await ci.get()
            i && t.some((e) => e.id === i) && (e = i)
          }
          e && this._selectBrokerInternal({ brokerId: e, isUserAction: !1 })
        }
        async makeNewOrderContextMenuAction(e, t, r) {
          const o = await this._qtySuggester.getQty(e)
          return {
            name: 'trade-new-order',
            action: () => {
              const { symbol: i } = this._linking.value()
              i !== e && this._linking.setSymbol(e),
                this.trackEvent(t, 'New Order'),
                this._checkAndOpenOrderDialog({
                  symbol: e,
                  qty: o,
                  limitPrice: r,
                  stopPrice: r,
                })
            },
            text: (0, L.appendEllipsis)(s.t(null, void 0, i(967498))),
            statName: 'NewOrder',
            shortcutHint: (0, a.humanReadableHash)(n.Modifiers.Shift + 84),
          }
        }
        async defaultContextMenuActions(
          e,
          {
            onlyMainActions: t = !1,
            gaOrigin: r = 'Chart Context Menu',
            hideNotExecutableAction: o = !1,
          } = {},
        ) {
          const { symbol: n } = await this.getActualSymbol(e.symbol),
            a = (
              await Promise.all([
                this._makeSubActions(n, e, r, o),
                this.makeNewOrderContextMenuAction(n, r, e.value || void 0),
              ])
            ).flat()
          return (
            !t &&
              R.enabled('property_pages') &&
              (a.push({ separator: !0 }),
              a.push({
                name: 'trade-properties',
                action: () => {
                  this.trackEvent(r, 'Trading Properties'),
                    this.showTradingProperties()
                },
                text: (0, L.appendEllipsis)(s.t(null, void 0, i(873503))),
                iconId: 'Settings',
                statName: 'Properties',
              })),
            a
          )
        }
        defaultDropdownMenuActions(e) {
          const t = 'Bottom Panel Dropdown',
            r = [],
            o = this.activeBroker(),
            n = e || {
              tradingProperties: !0,
              restoreConfirmations:
                o && o.metainfo().configFlags.supportConfirmations,
            }
          return (
            R.enabled('property_pages') || (n.tradingProperties = !1),
            n.tradingProperties &&
              r.push({
                action: () => {
                  this.showTradingProperties(),
                    this.trackEvent(t, 'Trading Properties')
                },
                text: (0, L.appendEllipsis)(s.t(null, void 0, i(873503))),
                iconId: 'Settings',
              }),
            n.restoreConfirmations &&
              r.push({
                action: () => {
                  this._showRestoreConfirmations(),
                    this.trackEvent(t, 'Restore confirmations')
                },
                text: (0, L.appendEllipsis)(s.t(null, void 0, i(102653))),
              }),
            r
          )
        }
        chartContextMenuActions(e, t) {
          return (
            this._activeBroker && 1 === this._activeBroker.connectionStatus()
              ? this._activeBroker.chartContextMenuActions(e, t)
              : this.defaultContextMenuActions(e, t)
          ).then((e) => (0, x.convertActionDescriptionsToActions)(e))
        }
        connectStatus() {
          return this._activeBroker ? this._activeBroker.connectionStatus() : 3
        }
        bindShortcuts() {
          if (this._hotkeys) return
          this._hotkeys = n.createGroup({ desc: 'Trading' })
          const e = async (e) => {
            const { symbol: t } = this._linking.value(),
              i = {
                qty: await this._qtySuggester.getQty(t),
                side: e,
                symbol: t,
                type: 2,
                seenPrice: null,
              }
            this.trackEvent(
              Hi,
              -1 === e ? 'Sell' : 'Buy',
              this._getInstantTradingEventLabel(),
            ),
              this._checkAndPlaceOrder(i)
          }
          this._hotkeys.add({
            desc: 'Buy',
            hotkey: n.Modifiers.Shift + 66,
            handler: () => e(1),
          }),
            this._hotkeys.add({
              desc: 'Sell',
              hotkey: n.Modifiers.Shift + 83,
              handler: () => e(-1),
            })
          const t = R.enabled('order_panel'),
            i = R.enabled('dom_widget')
          t &&
            this._hotkeys.add({
              desc: 'Open/close Order Panel',
              hotkey: n.Modifiers.Shift + 84,
              handler: () => {
                if (!this.tradingPanel.isOpeningAvailable.value()) return
                const e =
                  this.tradingPanel.isOpened.value() &&
                  this.tradingPanel.activePage.value() ===
                    H.TradingPage.OrderPanel
                this.trackEvent(
                  Hi,
                  e ? 'Close OT' : 'Open OT',
                  this._getInstantTradingEventLabel(),
                ),
                  this.setOrderPanelVisibility(!e)
              },
            }),
            i &&
              this._hotkeys.add({
                desc: 'Open/close DOM',
                hotkey: n.Modifiers.Shift + 68,
                handler: () => {
                  if (!this.tradingPanel.isOpeningAvailable.value()) return
                  const e =
                    this.tradingPanel.isOpened.value() &&
                    this.tradingPanel.activePage.value() ===
                      H.TradingPage.DOMPanel
                  this.trackEvent(
                    Hi,
                    e ? 'Close DOM' : 'Open DOM',
                    this._getInstantTradingEventLabel(),
                  ),
                    this.setDOMPanelVisibility(!e)
                },
              })
        }
        formatter(e) {
          return this.realtimeProvider().formatter(e)
        }
        showSuccessNotification(e, t, i = 1e4) {
          this.showOnlyRejectionNotifications.value() ||
            this._showNotification(e, t, 'success', i),
            R.enabled('show_trading_notifications_history') &&
              this._addNotificationRow(e, t, 'success', i),
            this._log(e, t)
        }
        getNotifications() {
          return this._notifications.filter(
            (e) =>
              e.account === this._account &&
              e.broker ===
                (this._activeBroker ? this._activeBroker.metainfo().id : null),
          )
        }
        orderViewController() {
          return (0, r.ensureNotNull)(this._orderViewController)
        }
        tradingStat() {
          return this._tradingStat
        }
        async verifyBrokerLiveAccount() {
          return (
            this._verifyLiveAccount(),
            null !== this._accountVerificationPromise
              ? this._accountVerificationPromise
              : Promise.reject('Account verification is not needed')
          )
        }
        pipValueType() {
          return this._pipValueType$.asObservable()
        }
        tradedItemsChartCollectionFacade() {
          return (0, r.ensureNotNull)(
            this._tradedItemsChartCollectionFacadePromise,
          )
        }
        async checkRealtimeDataPermissions(e) {
          const t = (0, r.ensureNotNull)(this._activeBroker),
            { id: i, altBrokerId: s } = t.metainfo()
          ;(await checkRealtimeDataSubscription(
            i,
            null != e ? e : t.getRealtimeDataCheckParams(),
            s,
          )) && this._guiAccessor.reconnectChartApi(!0)
        }
        async removeRealtimeDataPermissions() {
          ;(await removeRealtimeDataSubscription(
            (0, r.ensureNotNull)(this._activeBroker).metainfo().id,
          )) && this._guiAccessor.reconnectChartApi(!0)
        }
        makeActualSymbolObservable(e) {
          var t, i
          return null !==
            (i =
              null === (t = this._continuousFrontContractExtractor) ||
              void 0 === t
                ? void 0
                : t.makeValueObservable(e)) && void 0 !== i
            ? i
            : (0, P.of)({ symbol: e })
        }
        async getActualSymbol(e) {
          return void 0 === this._continuousFrontContractExtractor
            ? { symbol: e }
            : this._continuousFrontContractExtractor.makeValue(e)
        }
        getQtySuggester() {
          return this._qtySuggester
        }
        _getInstantTradingEventLabel() {
          return this.noConfirmEnabled.value() ? 'Instant' : 'Not Instant'
        }
        async _getOrderViewController() {
          return null !== this._orderViewController
            ? this._orderViewController
            : (await this._createOrderController(),
              this._getOrderViewController())
        }
        async _selectBroker(e) {
          var t, r
          const {
            brokerId: o,
            isUserAction: n,
            keepSessionAlive: a = !1,
            disconnectInfo: l,
            hasConcurrentSession: c,
          } = e
          if (this._switchingBroker)
            return void Fi.logWarn(
              `Broker is already selected, but a new broker id: ${o} was received.`,
            )
          if (
            o !== (this._activeBroker ? this._activeBroker.metainfo().id : null)
          ) {
            if (
              (null === (t = this._linkingSubscription) ||
                void 0 === t ||
                t.unsubscribe(),
              this._destroyContinuousFrontContractTrading(),
              this._activeBroker)
            ) {
              const e =
                  this._activeBroker &&
                  this._activeBroker.disconnectWarningMessage(),
                t = () =>
                  this._showReviewDialogIfNeeded(3, {
                    disconnectType: I.DisconnectType.LogOut,
                  })
              if (null !== e && window.is_authenticated) {
                if (
                  !(await (0, ge.showSimpleConfirmDialog)({
                    title: s.t(null, void 0, i(349391)),
                    text: e,
                    mainButtonText: s.t(null, void 0, i(162058)),
                    mainButtonIntent: 'danger',
                    cancelButtonText: s.t(null, void 0, i(620036)),
                    onConfirm: () => {
                      t(), this._logOut(n, a, l)
                    },
                    onCancel: () => {
                      t()
                    },
                  }))
                )
                  return
              } else t(), this._logOut(n, a, l)
            }
            if (null != o) {
              let e
              ;(this._tradeNowBrokerId = null), (this._switchingBroker = !0)
              try {
                const t = await Q.createBrokerConnection(
                    this,
                    o,
                    this._serverLogger,
                    null,
                    e,
                  ),
                  { isMaintenance: i, message: r } = await t.maintenanceStatus()
                if (i) {
                  if (
                    !(await this._showBrokerSideMaintenanceWarning(
                      t.metainfo().id,
                      r,
                    ))
                  )
                    return (this._switchingBroker = !1), void t.disconnect(!0)
                }
                0, await this._initBroker(t, a)
              } catch (e) {
                ;(this._switchingBroker = !1),
                  Fi.logError((0, N.getLoggerMessage)(e))
              }
            } else
              n &&
                setTimeout(() => {
                  ci.clear()
                }),
                this.onBrokerChange.fire(null),
                null ===
                  (r = this._closePositionDialogVisibilitySubscription) ||
                  void 0 === r ||
                  r.unsubscribe(),
                (this._brokerCommandsUI = null)
          } else Fi.logWarn(`${o} is already selected.`)
        }
        _destroyContinuousFrontContractTrading() {}
        async _initContinuousFrontContractTrading() {}
        _makeTradingPanelTabsConfig() {
          return ((e) => {
            const {
              onSelect: t,
              orderPanelAvailable: r,
              domPanelAvailable: o,
            } = e
            return r && o
              ? {
                  items: [
                    {
                      id: H.TradingPage.OrderPanel,
                      children: be.createElement(
                        Ni,
                        {
                          tooltipText: s.t(null, void 0, i(986869)),
                          tooltipHotKey: Li,
                        },
                        s.t(null, void 0, i(922541)),
                      ),
                    },
                    {
                      id: H.TradingPage.DOMPanel,
                      children: be.createElement(
                        Ni,
                        {
                          tooltipText: s.t(null, void 0, i(763124)),
                          tooltipHotKey: Vi,
                        },
                        s.t(null, void 0, i(763124)),
                      ),
                    },
                  ],
                  onSelect: t,
                }
              : null
          })({
            onSelect: this._toggleTradingPanelPage,
            orderPanelAvailable: R.enabled('order_panel'),
            domPanelAvailable: R.enabled('dom_widget'),
          })
        }
        _makeBrokerDependantWarningMessageObservable(e) {
          let t,
            i = async (t, i) => {
              const { tradable: r } = await (0, z.respectAbort)(
                t,
                e.isTradable(i),
              )
              return r
            }
          i = (0, z.respectLatest)(i)
          try {
            t = e.currentAccount()
          } catch (e) {}
          const r = (0, C.fromEventPattern)(
              (t) => e.currentAccountUpdate.subscribe(null, t),
              (t) => e.currentAccountUpdate.unsubscribe(null, t),
            ).pipe((0, w.startWith)(t)),
            s = (0, C.fromEventPattern)(
              (t) => e.connectionStatusUpdate.subscribe(null, t),
              (t) => e.connectionStatusUpdate.unsubscribe(null, t),
            ).pipe((0, w.startWith)(e.connectionStatus()))
          return (0, B.combineLatest)({
            value: this._linking.valueObservable(),
            currentAccountUpdate: r,
            connectionStatusUpdate: s,
          }).pipe(
            (0, T.mergeMap)(({ value: e }) =>
              (0, B.combineLatest)({
                isTradable: (0, E.from)(i(null, e.symbol)).pipe(
                  (0, w.startWith)(!1),
                  (0, O.catchError)(() => D.EMPTY),
                ),
                value: (0, P.of)(e),
              }),
            ),
            (0, S.map)((e) => (e.isTradable ? e.value.warning : void 0)),
          )
        }
        async _initBroker(e, t) {
          ;(this._activeBroker = e),
            this._activeBroker.connectionStatusUpdate.subscribe(
              this,
              this._connectionListener,
            ),
            this._activeBroker.currentAccountUpdate.subscribe(
              this,
              this._onCurrentAccountUpdate,
            ),
            this._realtimeProvider.onStatusChanged.subscribe(
              null,
              this._setPipValueType,
            ),
            this._realtimeProvider.onStatusChanged.subscribe(
              null,
              this._trackNonTradableSymbol,
            ),
            await this._initContinuousFrontContractTrading(),
            (this._linkingSubscription = this._linking
              .valueObservable()
              .subscribe(() => {
                this._setPipValueType(), this._trackNonTradableSymbol()
              })),
            (this._brokerCommandsUI = new Pe({
              activeBroker: this._activeBroker,
              guiAccessor: this._guiAccessor,
              noConfirmEnabled: this.noConfirmEnabled,
              orderViewController: this._getOrderViewController.bind(this),
              showErrorNotification: this.showErrorNotification.bind(this),
              trackEvent: this.trackEvent,
              tradingLinking: this._linking,
              abortSignalGetter: () => this._abortController.signal,
            })),
            (this._closePositionDialogVisibilitySubscription =
              this._brokerCommandsUI.closePositionDialogVisibility.subscribe(
                this._makeDialogVisibilityHandler(
                  this._closePositionDialogVisibility,
                ),
              )),
            this._activeBroker.tryRestoreSession(),
            await ci.set(this._activeBroker.metainfo().id),
            this.onBrokerChange.fire(this._activeBroker),
            this._getOrderViewController(),
            this._updateConnectionStatus(this.connectStatus()),
            (this._switchingBroker = !1)
        }
        async _showBrokerSideMaintenanceWarning(e, t) {
          return (0, ge.showSimpleConfirmDialog)({
            title: s.t(null, { replace: { brokerId: e } }, i(103718)),
            text: null != t ? t : s.t(null, void 0, i(536263)),
            cancelButtonText: s.t(null, void 0, i(620036)),
            mainButtonIntent: 'primary',
            mainButtonText: s.t(null, void 0, i(891268)),
            showBackdrop: !0,
          })
        }
        _makeDialogVisibilityHandler(e) {
          return (t) => {
            e.setValue(t), t.isFullScreen && this._onFullScreenDialogOpen()
          }
        }
        _gui() {
          return this._guiAccessor
        }
        _addNotificationRow(e, t, i, r) {
          const s = {
            id: this._notifications.length,
            account: this._account,
            broker: this._activeBroker
              ? this._activeBroker.metainfo().id
              : null,
            time: new Date(),
            title: e,
            text: t,
            type: i,
          }
          this._notifications.push(s), this.onNewNotification.fire(s)
        }
        _offlineHandler() {
          this._selectBrokerInternal({
            brokerId: null,
            isUserAction: !1,
            keepSessionAlive: !1,
            disconnectInfo: { disconnectType: I.DisconnectType.Offline },
          }),
            Fi.logNormal('The connection to the Internet was interrupted')
        }
        async _onlineHandler() {
          ;(await this._selectLastBroker()) &&
            Fi.logNormal('The connection to the Internet was restored')
        }
        _showNotification(e, t, i, r) {
          this._gui() && this._gui().showNotification(e, t, i, r)
        }
        _showReviewDialogIfNeeded(e, t) {
          if (null === this._activeBroker) return
          this._activeBroker
        }
        _connectionListener(e, t) {
          const i = this.connectStatus()
          this._showReviewDialogIfNeeded(e, t)
          const r = (this._isReconnectNeeded =
            (null == t ? void 0 : t.disconnectType) ===
            I.DisconnectType.BrokenConnection)
          3 !== e ||
            ((null == t ? void 0 : t.disconnectType) !==
              I.DisconnectType.LogOut &&
              !this._isReconnectNeeded) ||
            this._selectBrokerInternal({
              brokerId: null,
              isUserAction: !1,
              keepSessionAlive: !1,
              disconnectInfo: t,
            }).then(() => {
              if (this._isReconnectNeeded) return this._tryReconnectLastBroker()
            }),
            (null == t ? void 0 : t.disconnectType) ===
              I.DisconnectType.CancelAuthorization &&
              this.trackEvent('Signin', 'OAuth popup closed', 'By user'),
            (null == t ? void 0 : t.disconnectType) ===
              I.DisconnectType.TimeOutForAuthorization &&
              this.trackEvent('Signin', 'OAuth popup closed', 'By timeout'),
            this._updateConnectionStatus(i, !r, t)
        }
        async _selectLastBroker() {
          const e = await ci.get()
          return (
            null !== e &&
            (await this._selectBrokerInternal({
              brokerId: e,
              isUserAction: !1,
            }),
            !0)
          )
        }
        _updateOrderPanelSpinnerState() {
          const e = this._orderViewController,
            t = 2 === this.connectStatus(),
            i = null !== e && e.stateChanging.value()
          this.tradingPanel.isLoading.setValue(t || i)
        }
        async _updateConnectionStatus(e, t = !0, i) {
          var r
          this._updateOrderPanelSpinnerState(),
            this.onConnectionStatusChange.fire(e, i),
            this._log('Connection status', Wi[e])
          this._activeBroker
          if (
            (this._abortController.abort(),
            (this._abortController = new AbortController()),
            t)
          ) {
            const e =
              null === (r = this._activeBroker) || void 0 === r
                ? void 0
                : r.metainfo().id
            void 0 !== e ? await ci.set(e) : ci.clear()
          }
          null !== this._activeBroker
            ? ((3 !== e && 4 !== e) ||
                this._updateTradingPanelVisibility({ isOpened: !1 }),
              1 === e
                ? ((this._account = this._activeBroker.currentAccount()),
                  this._guiAccessor.setBroker(this._activeBroker))
                : this._tradedContextLinking.clear())
            : ((this._accountVerificationPromise = null),
              this._updateTradingPanelVisibility({ isOpened: !1 }),
              this._guiAccessor.setBroker(null),
              this._tradedContextLinking.clear())
        }
        async _checkOrRemoveRealtimeDataIfNeeded(e) {
          if (!e.configFlags.supportRealtimeDataCheck) return
          const { realtimeDataPermissionsToggleConfig: t } = e
          if (void 0 === t) return void this.checkRealtimeDataPermissions()
          const r = `${j.settingsKeys.REALTIME_DATA_ACCEPTED}.${e.id}`
          switch (o.getValue(r)) {
            case 'true':
              return void this.checkRealtimeDataPermissions()
            case 'false':
              return void this.removeRealtimeDataPermissions()
            default:
              const e = await showSimpleConfirmDialogWithSolutionLink({
                title: t.enableRealtimeDataPermissionsTitleText,
                text: t.enableRealtimeDataPermissionsToggleText,
                mainButtonText: s.t(null, void 0, i(83453)),
                cancelButtonText: s.t(null, void 0, i(546472)),
                showCloseButton: !1,
                closeOnOutsideClick: !1,
                mainButtonIntent: 'primary',
                closeOnEscapePress: !1,
                solutionId: t.solutionId,
                showBackdrop: !0,
                closeOnBackDropClick: !1,
              })
              e
                ? await this.checkRealtimeDataPermissions()
                : await this.removeRealtimeDataPermissions(),
                o.setValue(r, e)
          }
        }
        _verifyLiveAccount() {
          ;(0, r.ensureNotNull)(this._activeBroker)
        }
        _save() {
          const e = o.getJSON(j.settingsKeys.PROPERTIES, {})
          o.setJSON(j.settingsKeys.PROPERTIES, {
            ...e,
            [this._showSellBuyButtonsKey]: +!!this.showSellBuyButtons.value(),
            noConfirmEnabled: +!!this.noConfirmEnabled.value(),
            qweqrq: +!!this.showOnlyRejectionNotifications.value(),
            showPricesWithZeroVolume: +!!this._showPricesWithZeroVolume.value(),
            showSpread: +!!this._showSpread.value(),
            orderExecutedSoundParams: JSON.stringify({
              enabled: +!!this.orderExecutedSoundParams.enabled.value(),
              name: this.orderExecutedSoundParams.path.value(),
            }),
          })
        }
        _loadState() {
          const e = o.getJSON(j.settingsKeys.PROPERTIES, {}),
            t = e[this._showSellBuyButtonsKey]
          if (
            (this.showSellBuyButtons.setValue(void 0 !== t ? !!t : $i),
            this.noConfirmEnabled.setValue(!!e.noConfirmEnabled),
            this.showOnlyRejectionNotifications.setValue(!!e.qweqrq),
            this._showPricesWithZeroVolume.setValue(
              !Object.hasOwn(e, 'showPricesWithZeroVolume') ||
                Boolean(e.showPricesWithZeroVolume),
            ),
            this._showSpread.setValue(
              !Object.hasOwn(e, 'showSpread') || Boolean(e.showSpread),
            ),
            Object.hasOwn(e, 'orderExecutedSoundParams'))
          ) {
            const t = JSON.parse(e.orderExecutedSoundParams)
            this.orderExecutedSoundParams.enabled.setValue(!!t.enabled),
              this.orderExecutedSoundParams.path.setValue(
                Ui(t.name)
                  ? t.name
                  : this.orderExecutedSoundParams.path.value(),
              )
          }
        }
        _makeShowSellBuyButtonsKey() {
          return 'showSellBuyButtons'
        }
        _log(e, t) {
          Fi.logNormal(
            `${this._activeBroker ? this._activeBroker.metainfo().id + ' Trading: ' : ''}${e} - ${t}`,
          )
        }
        _makeSureCanTrade() {
          const e = this.activeBroker(),
            t = this.brokerCommandsUI()
          return e && t
            ? 1 === e.connectionStatus() || (this.toggleTradingWidget(), !1)
            : (this.toggleTradingWidget().then(() =>
                this.onNeedSelectBroker.fire(),
              ),
              !1)
        }
        _checkAndPlaceOrder(e, t = !0) {
          this._makeSureCanTrade() &&
            (0, r.ensureNotNull)(this.brokerCommandsUI()).placeOrder(e, t)
        }
        _checkAndOpenOrderDialog(e) {
          this._makeSureCanTrade() &&
            (0, r.ensureNotNull)(this.brokerCommandsUI()).placeOrder(e)
        }
        _makeSubAction({
          symbol: e,
          side: t,
          orderType: r,
          orderPrices: o,
          currentQuotes: n,
          qty: a,
          gaOrigin: l,
        }) {
          const c = 1 === t ? 'Trading.Buy' : 'Trading.Sell',
            d = 1 === t ? 'Buy' : 'Sell',
            u = 1 === r ? 'Limit' : 3 === r ? 'Stop' : 'StopLimit',
            h = ((e) => 'altPrice' in e && 'formattedAltPrice' in e)(o),
            p = e.split(':')[1],
            g = d + u,
            m = {
              BuyLimit: s
                .t(null, void 0, i(302122))
                .format({
                  symbol: p,
                  qty: (0, F.abbreviatedNumber)(a),
                  value: o.formattedPrice,
                }),
              SellStop: s
                .t(null, void 0, i(627392))
                .format({
                  symbol: p,
                  qty: (0, F.abbreviatedNumber)(a),
                  value: o.formattedPrice,
                }),
              SellLimit: s
                .t(null, void 0, i(476678))
                .format({
                  symbol: p,
                  qty: (0, F.abbreviatedNumber)(a),
                  value: o.formattedPrice,
                }),
              BuyStop: s
                .t(null, void 0, i(255481))
                .format({
                  symbol: p,
                  qty: (0, F.abbreviatedNumber)(a),
                  value: o.formattedPrice,
                }),
            }
          return (
            h &&
              ((m.SellStopLimit = s
                .t(null, void 0, i(194240))
                .format({
                  symbol: p,
                  qty: (0, F.abbreviatedNumber)(a),
                  value: o.formattedPrice,
                  altValue: o.formattedAltPrice,
                })),
              (m.BuyStopLimit = s
                .t(null, void 0, i(353343))
                .format({
                  symbol: p,
                  qty: (0, F.abbreviatedNumber)(a),
                  value: o.formattedPrice,
                  altValue: o.formattedAltPrice,
                }))),
            {
              name: `trade-${d}-${u}`.toLowerCase(),
              action: () => {
                this.trackEvent(l, `${d} ${u}`)
                const i = 1 === r ? 'limitPrice' : 'stopPrice',
                  s =
                    1 === t
                      ? null == n
                        ? void 0
                        : n.ask
                      : null == n
                        ? void 0
                        : n.bid,
                  c = {
                    qty: a,
                    side: t,
                    symbol: e,
                    type: r,
                    seenPrice: null != s ? s : null,
                    currentQuotes: n,
                  }
                null !== o.price && (c[i] = o.price),
                  4 === r && h && (c.limitPrice = o.altPrice),
                  this._checkAndPlaceOrder(c)
              },
              iconId: c,
              text: m[g],
              statName: g,
            }
          )
        }
        _createOrderController() {
          return (
            null === this._orderControllerPromise &&
              (this._orderControllerPromise = Promise.all([i.e(4689), i.e(660)])
                .then(i.bind(i, 721678))
                .then(
                  ({ OrderViewController: e }) =>
                    new e({
                      tradingCommands: {
                        resizerBridge: this._resizerBridge,
                        onNeedSelectBroker: this.onNeedSelectBroker,
                        realtimeProvider: this.realtimeProvider(),
                        pipValueType$: this.pipValueType(),
                        trackEvent: this.trackEvent,
                        toggleTradingWidget:
                          this.toggleTradingWidget.bind(this),
                        toggleTradingPanelPopup:
                          this.toggleTradingPanelPopup.bind(this),
                        showErrorNotification:
                          this.showErrorNotification.bind(this),
                        getTradingSettingsStorage: () =>
                          this._tradingSettingsStorage,
                      },
                      tradingPanelCommands: {
                        container: this.tradingPanel.container,
                        isOpened: this.tradingPanel.isOpened,
                        isOpeningAvailable:
                          this.tradingPanel.isOpeningAvailable,
                        activePage: this.tradingPanel.activePage,
                        close: this.tradingPanel.close.bind(this.tradingPanel),
                        openPage: this.tradingPanel.openPage.bind(
                          this.tradingPanel,
                        ),
                      },
                      qtySuggester: this._qtySuggester,
                      tradingLinking: this._linking,
                      orderViewHeaderState: this._orderPanelHeaderState,
                      tradedContextLinking: void 0,
                    }),
                )
                .then((e) => {
                  ;(this._orderControllerPromise = null),
                    (this._orderViewController = e),
                    this._orderViewController.stateChanging.subscribe(() =>
                      this._updateOrderPanelSpinnerState(),
                    ),
                    this._orderViewController.dialogVisibility.subscribe(
                      this._makeDialogVisibilityHandler(
                        this._orderDialogVisibility,
                      ),
                    )
                })),
            this._orderControllerPromise
          )
        }
        async _registerCustomSources(e) {
          !(async (e, t) => {
            const r = await Promise.all([i.e(1033), i.e(1969), i.e(2650)]).then(
              i.bind(i, 13042),
            )
            e.addCustomSource(
              'bidask',
              (i, s) =>
                new r.BidAsk(i, s, t.realtimeProvider(), () => {
                  e.activeChartWidget
                    .value()
                    .showGeneralChartProperties(U.TabNames.symbol)
                }),
            )
          })(e, this),
            ct(e, this, this.showTradedSources)
          ;new (
            await Promise.all([i.e(1033), i.e(1969), i.e(1652)]).then(
              i.bind(i, 16951),
            )
          ).TradedSourcesManager(
            this._ordersService,
            this._positionService,
            e,
            {
              activeTradedLinking: this._tradedContextLinking,
              showTradedSources: this.showTradedSources,
              realtimeProvider: this._realtimeProvider,
              qtySuggester: this._qtySuggesterWithOrderSizeCalculatorResetting,
              brokerCommandsUI: this.brokerCommandsUI.bind(this),
              trackEvent: this.trackEvent,
              pipValueType$: this.pipValueType(),
              makeActualSymbolObservable:
                this.makeActualSymbolObservable.bind(this),
              getSymbolSpecificTradingOptions: (e) =>
                (0, r.ensureNotNull)(
                  this._activeBroker,
                ).getSymbolSpecificTradingOptions(e),
            },
          )
        }
        _registerCustomWidgets(e) {
          zi &&
            ((e, t, i) => {
              e.addCustomWidgetToLegend(
                (e, r) => {
                  const s = e.mainSeries(),
                    o = (0, at.createWVFromGetterAndSubscription)(
                      e.isInReplay.bind(e),
                      e.onInReplayStateChanged(),
                    ),
                    n = (0, at.createWVFromGetterAndSubscriptions)(() => {
                      var e
                      return (
                        'economic' ===
                        (null === (e = s.symbolInfo()) || void 0 === e
                          ? void 0
                          : e.type)
                      )
                    }, [
                      s.dataEvents().symbolResolved(),
                      s.dataEvents().symbolError(),
                    ])
                  return new $t(
                    s.dataEvents(),
                    ((e) => () => {
                      const t = e.symbolInfo()
                      return null !== t
                        ? t.pro_name || t.full_name || t.name || ''
                        : e.proSymbol()
                    })(s),
                    n.ownership(),
                    i,
                    {
                      onNeedSelectBroker: t.onNeedSelectBroker,
                      realtimeProvider: t.realtimeProvider(),
                      onBrokerConnectionStatusChange:
                        t.onConnectionStatusChange,
                      brokerConnectionStatus: t.connectStatus.bind(t),
                      trackEvent: t.trackEvent,
                      toggleTradingWidget: t.toggleTradingWidget.bind(t),
                      toggleTradingPanelPopup:
                        t.toggleTradingPanelPopup.bind(t),
                      brokerCommandsUI: t.brokerCommandsUI.bind(t),
                      toggleMinimizeBottomWidgetBar: () =>
                        t.toggleMinimizeBottomWidgetBar(),
                      makeActualSymbolObservable:
                        t.makeActualSymbolObservable.bind(t),
                    },
                    {
                      showSellBuyButtons: t.showSellBuyButtons.spawnOwnership(),
                      noConfirmEnabled: t.noConfirmEnabled.spawnOwnership(),
                      themeName: r.ownership(),
                    },
                    o.ownership(),
                    e.collapsed().spawnOwnership(),
                  )
                },
                { block: 0, position: 0 },
              )
            })(e, this, this._qtySuggesterWithOrderSizeCalculatorResetting)
        }
        async _makeSubActions(e, t, i, r = !1) {
          if (null === t.value || (0, y.isNaN)(t.value)) return []
          const s = this.activeBroker()
          let o,
            n,
            a,
            l,
            c,
            d,
            u,
            h,
            p,
            g,
            m,
            _,
            b,
            v = null === s,
            f = null === s,
            k = !r && null === s,
            S = !r && null !== s,
            P = !r && null === s
          null !== s &&
            1 === s.connectionStatus() &&
            (b = await s.isTradable(e))
          const [C, w, B, { ask: T, bid: E }, O] = await Promise.all([
            this._qtySuggester.getQty(e),
            this._realtimeProvider.symbolInfo(e),
            this._realtimeProvider.formatter(e),
            this._realtimeProvider.quotesSnapshot(e),
            null == s ? void 0 : s.getSymbolSpecificTradingOptions(e),
          ])
          if (void 0 === T || void 0 === E || (t.value < T && t.value > E))
            return []
          const D = w.variableMinTick
              ? (0, A.makeVariableMinTickData)(w.minTick, w.variableMinTick)
              : void 0,
            I = (e) =>
              (0, A.getMinTick)({
                minTick: w.minTick,
                price: e,
                variableMinTickData: D,
              })
          if (null !== s && b && b.tradable) {
            const e = s.metainfo().configFlags,
              i = (0, M.alignToStep)(t.value, I(t.value))
            ;(o = i),
              (a = i),
              (l = i),
              (n = i),
              (c = l + I(l)),
              (d = n - I(n)),
              (v = Boolean(
                e.supportLimitOrders &&
                  (0, x.isOrderTypeAllowed)(
                    1,
                    null == O ? void 0 : O.allowedOrderTypes,
                  ),
              )),
              (f = Boolean(
                e.supportStopOrders &&
                  (0, x.isOrderTypeAllowed)(
                    3,
                    null == O ? void 0 : O.allowedOrderTypes,
                  ),
              )),
              (P = Boolean(
                e.supportStopLimitOrders &&
                  (0, x.isOrderTypeAllowed)(
                    4,
                    null == O ? void 0 : O.allowedOrderTypes,
                  ),
              )),
              (k = Boolean(e.supportStopOrdersInBothDirectionsInUI)),
              (S = Boolean(e.supportStopLimitOrdersInBothDirections)),
              void 0 !== w.limitPriceStep &&
                ((o = (0, N.roundToStepByPriceTypeAndSide)(
                  t.value,
                  w.limitPriceStep,
                  1,
                  1,
                )),
                (a = (0, N.roundToStepByPriceTypeAndSide)(
                  t.value,
                  w.limitPriceStep,
                  1,
                  -1,
                )),
                (c = (0, N.roundToStepByPriceTypeAndSide)(
                  t.value + I(t.value),
                  w.limitPriceStep,
                  1,
                  1,
                )),
                (d = (0, N.roundToStepByPriceTypeAndSide)(
                  t.value - I(t.value),
                  w.limitPriceStep,
                  1,
                  -1,
                ))),
              void 0 !== w.stopPriceStep &&
                ((l = (0, N.roundToStepByPriceTypeAndSide)(
                  t.value,
                  w.stopPriceStep,
                  2,
                  1,
                )),
                (n = (0, N.roundToStepByPriceTypeAndSide)(
                  t.value,
                  w.stopPriceStep,
                  2,
                  -1,
                ))),
              (u = B.format(o)),
              (h = B.format(n)),
              (p = B.format(a)),
              (g = B.format(l)),
              (m = B.format(c)),
              (_ = B.format(d))
          } else
            (o = a = l = n = t.value),
              (u = h = p = g = t.formattedValue),
              (c = l + I(l)),
              (d = n - I(n)),
              (m = B.format(c)),
              (_ = B.format(d))
          const L = { ask: T, bid: E },
            V = (E + T) / 2,
            R = []
          if (t.value <= V) {
            if (v) {
              const t = { price: o, formattedPrice: u }
              R.push(
                this._makeSubAction({
                  symbol: e,
                  side: 1,
                  orderType: 1,
                  orderPrices: t,
                  qty: C,
                  gaOrigin: i,
                  currentQuotes: L,
                }),
              )
            }
            if (k) {
              const t = { price: l, formattedPrice: g }
              R.push(
                this._makeSubAction({
                  symbol: e,
                  side: 1,
                  orderType: 3,
                  orderPrices: t,
                  qty: C,
                  gaOrigin: i,
                  currentQuotes: L,
                }),
              )
            }
            if (f || k) {
              const t = { price: n, formattedPrice: h }
              R.push(
                this._makeSubAction({
                  symbol: e,
                  side: -1,
                  orderType: 3,
                  orderPrices: t,
                  qty: C,
                  gaOrigin: i,
                  currentQuotes: L,
                }),
              )
            }
            if (P) {
              const t = {
                symbol: e,
                side: -1,
                orderType: 4,
                orderPrices: {
                  price: n,
                  formattedPrice: h,
                  altPrice: d,
                  formattedAltPrice: _,
                },
                qty: C,
                gaOrigin: i,
                currentQuotes: L,
              }
              R.push(this._makeSubAction(t)),
                S && R.push(this._makeSubAction({ ...t, side: 1 }))
            }
          } else {
            if (v) {
              const t = { price: a, formattedPrice: p }
              R.push(
                this._makeSubAction({
                  symbol: e,
                  side: -1,
                  orderType: 1,
                  orderPrices: t,
                  qty: C,
                  gaOrigin: i,
                  currentQuotes: L,
                }),
              )
            }
            if (k) {
              const t = { price: n, formattedPrice: h }
              R.push(
                this._makeSubAction({
                  symbol: e,
                  side: -1,
                  orderType: 3,
                  orderPrices: t,
                  qty: C,
                  gaOrigin: i,
                  currentQuotes: L,
                }),
              )
            }
            if (f || k) {
              const t = { price: l, formattedPrice: g }
              R.push(
                this._makeSubAction({
                  symbol: e,
                  side: 1,
                  orderType: 3,
                  orderPrices: t,
                  qty: C,
                  gaOrigin: i,
                  currentQuotes: L,
                }),
              )
            }
            if (P) {
              const t = {
                symbol: e,
                side: 1,
                orderType: 4,
                orderPrices: {
                  price: l,
                  formattedPrice: g,
                  altPrice: c,
                  formattedAltPrice: m,
                },
                qty: C,
                gaOrigin: i,
                currentQuotes: L,
              }
              R.push(this._makeSubAction(t)),
                S && R.push(this._makeSubAction({ ...t, side: -1 }))
            }
          }
          return R
        }
        _initPaidBrokersByUserRegion() {
          this._brokersPlansPromise = Promise.resolve([])
        }
        async _getBrokersPlans() {
          let e = []
          try {
            if (((e = await this._brokersPlansPromise), !Array.isArray(e)))
              throw new Error('Request result is not valid')
          } catch (e) {
            Fi.logError(
              `Failed to fetch broker list by user region: ${e.message}`,
            )
          }
          return e
        }
        async _showRestoreConfirmations() {
          const e = await (0, ge.showSimpleConfirmDialog)({
            title: s.t(null, void 0, i(102653)),
            text: s.t(null, void 0, i(526227)),
            mainButtonIntent: 'primary',
          })
          null !== this._activeBroker &&
            e &&
            new di.DisabledConfirmations().clear()
        }
        _logOut(e, t, i) {
          const s = (0, r.ensureNotNull)(this._activeBroker)
          s.connectionStatusUpdate.unsubscribe(this, this._connectionListener),
            s.currentAccountUpdate.unsubscribe(
              this,
              this._onCurrentAccountUpdate,
            ),
            this._realtimeProvider.onStatusChanged.unsubscribe(
              null,
              this._setPipValueType,
            ),
            this._realtimeProvider.onStatusChanged.unsubscribe(
              null,
              this._trackNonTradableSymbol,
            ),
            s.disconnect(t || !e),
            s.destroy(),
            (this._activeBroker = null),
            this._updateConnectionStatus(3, e, i)
        }
        async _createTradedItemsChartCollectionFacade(e) {
          return new (
            await Promise.all([i.e(1033), i.e(1969), i.e(2650)]).then(
              i.bind(i, 132193),
            )
          ).TradedItemsChartCollectionFacade(e)
        }
        _tradeNowInit() {
          const e = new URL(decodeURIComponent(window.location.href)),
            t = e.searchParams.get('trade-now')
          e.searchParams.delete('trade-now'),
            window.history.replaceState(null, document.title, e.toString()),
            null === t ||
              isMobileTradingAvailable() ||
              ((this._tradeNowBrokerId = t), ci.clear())
        }
      }
    },
    481330: (e, t, i) => {
      i.d(t, {
        addAsciiDotIfTextDoesNotEndWithSentenceEndingMark: () => Y,
        adjustSavedCustomFieldsValues: () => V,
        alignToMinTick: () => te,
        bottomTradingTabClassName: () => g,
        brokersListFromPlans: () => m,
        checkIsExistingPosition: () => j,
        convertActionDescriptionsToActions: () => v,
        executionText: () => b,
        filterDurationsByOrderType: () => N,
        filterDurationsBySymbolDurations: () => A,
        findDurationMetaInfo: () => D,
        formatValue: () => G,
        getAsk: () => W,
        getBid: () => q,
        getCryptoBalanceValue: () => Z,
        getCurrency: () => S,
        getDefaultOrderType: () => R,
        getLast: () => U,
        getOrderDuration: () => I,
        getOrderPrice: () => J,
        getPlatform: () => K,
        getPriceStep: () => H,
        getQuotePrice: () => $,
        getTimestamp: () => L,
        isBatsQuotes: () => T,
        isBrokerSupportOrderModification: () => C,
        isDefined: () => E,
        isMintickMultiple: () => F,
        isModifyOrderSupported: () => w,
        isMoveOrderSupported: () => B,
        isNoQuotes: () => z,
        isOAuthAuthType: () => _,
        isOrderActive: () => y,
        isOrderTypeAllowed: () => ee,
        makeBrokerSideMaintananceFeatureToggleName: () => f,
        makeDatePlus24UTCHours: () => O,
        makeInitialOrderDuration: () => x,
        makeMaintananceFeatureToggleName: () => k,
        makeOrderDuration: () => M,
        orderStatusToText: () => h.orderStatusToText,
        roundToStepRequired: () => Q,
      })
      var r = i(960521),
        s = i(650151),
        o = i(372605),
        n = i(601227),
        a = i(69111),
        l = i(282729),
        c = i(758265),
        d = i(973602),
        u = i(807107),
        h = i(637401)
      const p = 'Paper',
        g = 'js-bottom-trading-tab'
      function m(e, t) {
        const i = new Map(e.map((e) => [e.id, e])),
          r = new Map(t.map((e) => [e.slug_name, e])),
          o = [{ metainfo: (0, s.ensureDefined)(i.get(p)) }]
        return (
          t.forEach((e) => {
            i.has(e.slug_name) &&
              o.push({
                metainfo: (0, s.ensureDefined)(i.get(e.slug_name)),
                brokerPlan: e,
              })
          }),
          e.forEach((e) => {
            r.has(e.id) || e.id === p || o.push({ metainfo: e })
          }),
          o
        )
      }
      function _(e) {
        return (
          void 0 !== e &&
          ['oauth', 'oauth2-implicit-flow', 'oauth2-code-flow'].includes(e)
        )
      }
      function b(e, t) {
        const i =
          (0, h.sideToText)(e.side) + ' ' + e.qty + ' @ ' + t.format(e.price)
        return i.substring(0, 1).toUpperCase() + i.substring(1).toLowerCase()
      }
      function v(e) {
        return e
          ? e.map((e) =>
              '-' === e.text || e.separator
                ? new d.Separator()
                : new c.ActionWithStandardIcon({
                    actionId: 'Trading.CustomActionId',
                    options: {
                      name: e.name,
                      checkable: e.checkable,
                      checked: e.checked,
                      disabled: void 0 !== e.enabled && !e.enabled,
                      label: e.text,
                      statName: e.statName,
                      icon: e.icon,
                      iconId: e.iconId,
                      shortcutHint: e.shortcutHint,
                      onExecute: (t) => {
                        const i = t.getState()
                        e.action({
                          checkable: i.checkable,
                          checked: i.checked,
                          enabled: !i.disabled,
                          text: i.label,
                        })
                      },
                    },
                  }),
            )
          : []
      }
      function y(e) {
        return 6 === e || 3 === e
      }
      function f(e) {
        return `${e}-brokers-side-maintenance`.toLowerCase()
      }
      function k(e) {
        return `${e}-maintenance`.toLowerCase()
      }
      function S(e, t) {
        return (!t && e.currencySign) || e.currency || ''
      }
      function P(e, t) {
        return Boolean(
          void 0 !== e.parentId &&
            t.supportModifyBrackets &&
            ((t.supportTrailingStop && t.supportModifyTrailingStop) ||
              e.stopType !== l.StopType.TrailingStop),
        )
      }
      function C(e) {
        return (
          e.supportModifyOrderPrice ||
          e.supportEditAmount ||
          e.supportModifyBrackets ||
          !1
        )
      }
      function w(e, t) {
        const i = 2 !== e.type && void 0 === e.parentId && C(t),
          r = P(e, t)
        return i || r
      }
      function B(e, t) {
        const i = void 0 === e.parentId && t.supportModifyOrderPrice,
          r = P(e, t)
        return Boolean(i || r)
      }
      function T(e) {
        var t
        return (
          'BATS' ===
          (null === (t = e.originalName) || void 0 === t
            ? void 0
            : t.split(':')[0])
        )
      }
      function E(e) {
        return null != e
      }
      function O() {
        const e = new Date()
        return e.setUTCHours(e.getUTCHours() + 24), e
      }
      function D(e, t) {
        return e.find((e) => e.value === t)
      }
      function I(e) {
        const {
          orderDuration: t,
          orderType: i,
          savedDuration: r,
          orderDurations: s,
          symbolDurations: o,
        } = e
        if (void 0 !== t) return t
        const n = ((e) => {
          const {
            duration: t,
            orderDurations: i,
            orderType: r,
            symbolDurations: s,
          } = e
          if (null === t || void 0 === i) return null
          const o = A(i, s),
            n = D(N(o, null != r ? r : null), t.type)
          if (void 0 === n) return null
          if (void 0 !== t.datetime && (n.hasDatePicker || n.hasTimePicker)) {
            const e = 864e5,
              i = n.hasTimePicker
                ? t.datetime < Date.now()
                : Math.floor((t.datetime - Date.now()) / e) < 0
            t.datetime = i ? O().getTime() : t.datetime
          }
          return t
        })({ duration: r, orderType: i, orderDurations: s, symbolDurations: o })
        return null !== n ? { ...n } : x(i, s, o)
      }
      function x(e, t, i) {
        var r
        if (void 0 === t) return null
        const s = N(A(t, i), e)
        if (0 === s.length) return null
        return M(
          null !== (r = s.find((e) => e.default)) && void 0 !== r ? r : s[0],
        )
      }
      function M(e) {
        const t = { type: e.value }
        return (
          Boolean(e.hasTimePicker || e.hasDatePicker) && (t.datetime = L(O())),
          t
        )
      }
      function A(e, t) {
        return 0 === e.length || void 0 === t || 0 === t.length
          ? e
          : e.filter(({ value: e }) => t.includes(e))
      }
      function N(e, t) {
        const i = [1, 3, 4]
        return e.filter((e) => {
          var r
          const s = null !== (r = e.supportedOrderTypes) && void 0 !== r ? r : i
          return null === t || s.includes(t)
        })
      }
      function L(e) {
        return e.valueOf()
      }
      function V(e, t) {
        if (void 0 === t.customFields) return {}
        const i = {}
        return (
          t.customFields.forEach((t) => {
            var r
            const s = 'ComboBox' === t.inputType
            if (s && t.forceUserEnterInitialValue) return
            const o = s ? t.items[0].value : t.value,
              n = null !== (r = e[t.id]) && void 0 !== r ? r : o
            void 0 !== n && (i[t.id] = n)
          }),
          i
        )
      }
      function R(e) {
        return e.supportLimitOrders
          ? 1
          : e.supportMarketOrders
            ? 2
            : e.supportStopLimitOrders
              ? 4
              : e.supportStopOrders
                ? 3
                : void 0
      }
      function F(e, t) {
        if (0 === t) return !1
        const i = Math.round(1e15 * t) / 1e15,
          s = new r.Big(e),
          o = new r.Big(i)
        return s.mod(o).eq(0)
      }
      function W(e) {
        return (0, o.isNumber)(e.ask)
          ? e.ask
          : (0, o.isNumber)(e.trade)
            ? e.trade
            : 0
      }
      function q(e) {
        return (0, o.isNumber)(e.bid)
          ? e.bid
          : (0, o.isNumber)(e.trade)
            ? e.trade
            : 0
      }
      function U(e) {
        return (0, o.isNumber)(e.trade) ? e.trade : 0
      }
      function z(e) {
        return null === e || void 0 === e.ask || void 0 === e.bid
      }
      function $(e, t) {
        return 1 === t ? W(e) : q(e)
      }
      function H(e) {
        const {
          priceType: t,
          minTick: i,
          price: r,
          variableMinTickData: s,
          limitPriceStep: o,
          stopPriceStep: n,
        } = e
        return 1 === t && void 0 !== o
          ? o
          : 2 === t && void 0 !== n
            ? n
            : void 0 !== s && void 0 !== r
              ? (0, u.getMinTick)({
                  minTick: i,
                  price: r,
                  variableMinTickData: s,
                })
              : i
      }
      function Q(e) {
        const {
          priceType: t,
          minTick: i,
          limitPriceStep: r,
          stopPriceStep: s,
        } = e
        return 1 === t && void 0 !== r
          ? r !== i
          : 2 === t && void 0 !== s && s !== i
      }
      function j(e) {
        return (
          void 0 !== e && (0 !== e.qty || 0 !== e.longQty || 0 !== e.shortQty)
        )
      }
      function K() {
        if ((0, n.isDesktopApp)()) return 'Desktop App'
        const e = (0, a.isOnMobileAppPage)('old')
        return n.CheckMobile.isIPad()
          ? e
            ? 'iPad App'
            : 'iPad Web'
          : n.CheckMobile.any()
            ? n.CheckMobile.Android()
              ? (0, a.isOnMobileAppPage)('new')
                ? 'Android App'
                : 'Android Web'
              : n.CheckMobile.iOS()
                ? e
                  ? 'iPhone App'
                  : 'iPhone Web'
                : 'Unknown Mobile Web'
            : 'Desktop Web'
      }
      function G(e, t) {
        if (null === e) return null
        const i = t.format(e)
        if (t.parse) {
          const e = t.parse(i)
          if (e.res) return e.value
        }
        return Number.parseFloat(i)
      }
      function Z({ balance: e, ...t }) {
        return null === e
          ? null
          : ((e) => {
              const { side: t, isExistingOrder: i, qty: s, orderPrice: o } = e
              return i && s && o
                ? -1 === t
                  ? new r.Big(s)
                  : new r.Big(s).mul(o)
                : new r.Big(0)
            })({ ...t })
              .plus(e.available)
              .toNumber()
      }
      function J(e, t) {
        switch (e.type) {
          case 1:
          case 4:
            return e.limitPrice
          case 3:
            return e.stopPrice
          default:
            return $(t, e.side)
        }
      }
      const X = {
        visible: ['.', '', '', '!', '?', '', ''],
        invisible: ['', ''],
      }
      function Y(e) {
        const t = e.trim(),
          i = t.slice(-1),
          r = X.invisible.includes(i) ? t.charAt(t.length - 2) : i
        return X.visible.includes(r) ? t : t + '.'
      }
      function ee(e, t) {
        return void 0 === t || 0 === t.length || t.includes(e)
      }
      function te(e, t) {
        return t > 1 ? e : (0, r.Big)(e).div(t).round(0, 1).mul(t).toNumber()
      }
    },
    99708: (e, t, i) => {
      i.d(t, { checkQtyError: () => l, qtyErrors: () => n })
      var r = i(609838),
        s = i(960521),
        o = i.n(s)
      const n = {
          min: r.t(null, void 0, i(430999)),
          max: r.t(null, void 0, i(734266)),
          step: r.t(null, void 0, i(136443)),
          balance: r.t(null, void 0, i(409232)),
        },
        a = (r.t(null, void 0, i(611835)), r.t(null, void 0, i(706035)))
      function l(e, t, i = !1) {
        if (null === t) return { res: !0, msg: a }
        const r = e.step,
          s = e.min,
          l = e.max
        if (t < s) return { res: !0, msg: n.min.format({ min: s.toString() }) }
        if (t > l) return { res: !0, msg: n.max.format({ max: l.toString() }) }
        const c = new (o())(t).minus(s).mod(r)
        return i && !c.eq(0)
          ? { res: !0, msg: n.step.format({ step: r.toString() }) }
          : { res: !1 }
      }
    },
    798165: (e, t, i) => {
      i.d(t, { validateBalance: () => o })
      var r = i(99708)
      function s(e, t) {
        return null !== e && null !== t && e > t
          ? { res: !0, msg: r.qtyErrors.balance }
          : { res: !1 }
      }
      function o(e) {
        const {
          side: t,
          baseValue: i,
          baseBalanceValue: r,
          quoteValue: o,
          quoteBalanceValue: n,
        } = e
        return -1 === t ? s(i, r) : s(o, n)
      }
    },
    346849: (e, t, i) => {
      i.d(t, {
        checkBracketError: () => h,
        makeBracketPercentPriceRuleChecker: () => d,
      })
      var r = i(609838),
        s = i(960521),
        o = i.n(s),
        n = i(656846),
        a = i(481330),
        l = i(637401)
      const c = {
        orderStopLoss: {
          long: r.t(null, void 0, i(995717)),
          short: r.t(null, void 0, i(685017)),
        },
        orderTakeProfit: {
          long: r.t(null, void 0, i(429871)),
          short: r.t(null, void 0, i(37475)),
        },
        positionStopLoss: {
          long: (e) => r.t(null, { replace: { value: e } }, i(216502)),
          short: (e) => r.t(null, { replace: { value: e } }, i(874337)),
        },
        positionTakeProfit: {
          long: (e) => r.t(null, { replace: { value: e } }, i(829997)),
          short: (e) => r.t(null, { replace: { value: e } }, i(751300)),
        },
      }
      function d(e, t) {
        let s, a, c
        const d = (e, t, i, r) => {
          const s = new (o())(t),
            n = s.mul(e).div(100)
          return s.minus(n.mul(i).mul(r)).toNumber()
        }
        return (o, u, h, p, g, m, _, b) => {
          const v = -1 === h ? -1 : 1,
            y = p === n.BracketType.TakeProfit ? -1 : 1,
            f = d(e, u, v, y),
            k = d(t, u, v, y),
            S = (0, l.roundToStepByPriceTypeAndSide)(f, m, g, h),
            P = (0, l.roundToStepByPriceTypeAndSide)(k, m, g, h)
          let C = Math.min(S, P),
            w = Math.max(S, P)
          _ &&
            (void 0 !== s && void 0 !== a && c
              ? ((C = s), (w = a))
              : void 0 === s &&
                void 0 === a &&
                ((C = Math.min(C, o)),
                (w = Math.max(w, o)),
                (s = C),
                (a = w),
                (c = b)))
          if (!(o >= C && o <= w))
            return {
              res: !0,
              msg: r
                .t(null, void 0, i(783100))
                .replace('{min}', C.toString())
                .replace('{max}', w.toString()),
            }
          return (v * y == -1 ? S >= u && P >= u : S <= u && P <= u)
            ? { res: !1 }
            : { res: !0, msg: r.t(null, void 0, i(298353)) }
        }
      }
      function u(e) {
        const {
          side: t,
          price: i,
          priceType: r,
          priceStep: s,
          parentPrice: o,
          bracketType: n,
          isStatusEditing: a,
          isEnabled: l,
          bracketPercentPriceRuleCheckers: c,
        } = e
        for (const e of c) {
          const c = e(i, o, t, n, r, s, a, l)
          if (c.res) return c
        }
        return { res: !1 }
      }
      function h(e) {
        const {
          quotes: t,
          side: s,
          price: o,
          pips: l,
          priceType: d,
          priceStep: h,
          parentPrice: p,
          parentType: g,
          bracketType: m,
          isStatusEditing: _,
          isEnabled: b,
          bracketPercentPriceRuleCheckers: v,
          priceFormatter: y,
          isRoundToPriceStep: f,
        } = e
        if (null === o || null === l)
          return { res: !0, msg: r.t(null, void 0, i(900205)) }
        let k = { res: !1 }
        return (
          (k =
            2 === g
              ? ((e) => {
                  const {
                    quotes: t,
                    side: s,
                    price: o,
                    priceType: l,
                    priceStep: d,
                    parentPrice: h,
                    bracketType: p,
                    isStatusEditing: g,
                    isEnabled: m,
                    bracketPercentPriceRuleCheckers: _,
                  } = e
                  let b = { res: !1 }
                  _.length > 0 &&
                    (b = u({
                      side: s,
                      price: o,
                      priceType: l,
                      priceStep: d,
                      parentPrice: h,
                      bracketType: p,
                      isStatusEditing: g,
                      isEnabled: m,
                      bracketPercentPriceRuleCheckers: _,
                    }))
                  const v = (p === n.BracketType.TakeProfit ? -1 : 1) * s,
                    y = -1 === s ? (0, a.getAsk)(t) : (0, a.getBid)(t)
                  if (y && Math.sign(o - y) === v) {
                    const e =
                        p === n.BracketType.TakeProfit
                          ? c.positionTakeProfit
                          : c.positionStopLoss,
                      t =
                        -1 === s
                          ? r.t(null, void 0, i(26338))
                          : r.t(null, void 0, i(5595))
                    b = { res: !0, msg: -1 === s ? e.short(t) : e.long(t) }
                  }
                  return b
                })({
                  quotes: t,
                  side: s,
                  price: o,
                  priceType: d,
                  priceStep: h,
                  parentPrice: p,
                  bracketType: m,
                  isStatusEditing: _,
                  isEnabled: b,
                  bracketPercentPriceRuleCheckers: v,
                })
              : ((e) => {
                  const {
                    side: t,
                    pips: i,
                    price: r,
                    priceType: s,
                    priceStep: o,
                    parentPrice: a,
                    bracketType: l,
                    isStatusEditing: d,
                    isEnabled: h,
                    bracketPercentPriceRuleCheckers: p,
                  } = e
                  let g = { res: !1 }
                  if (
                    (p.length > 0 &&
                      (g = u({
                        side: t,
                        price: r,
                        priceType: s,
                        priceStep: o,
                        parentPrice: a,
                        bracketType: l,
                        isStatusEditing: d,
                        isEnabled: h,
                        bracketPercentPriceRuleCheckers: p,
                      })),
                    i <= 0 || r <= 0)
                  ) {
                    const e =
                      l === n.BracketType.TakeProfit
                        ? c.orderTakeProfit
                        : c.orderStopLoss
                    g = { res: !0, msg: 1 === t ? e.long : e.short }
                  }
                  return g
                })({
                  side: s,
                  pips: l,
                  price: o,
                  priceType: d,
                  priceStep: h,
                  parentPrice: p,
                  bracketType: m,
                  isStatusEditing: _,
                  isEnabled: b,
                  bracketPercentPriceRuleCheckers: v,
                })),
          !k.res &&
            f &&
            (k = ((e, t, s) =>
              (0, a.isMintickMultiple)(e, t)
                ? { res: !1 }
                : {
                    res: !0,
                    msg: r
                      .t(null, void 0, i(753596))
                      .format({ minTick: s.format(t) }),
                  })(o, h, y)),
          k
        )
      }
    },
    957877: (e, t, i) => {
      i.d(t, { validatePrice: () => c })
      var r = i(609838),
        s = i(960521),
        o = i.n(s),
        n = i(481330)
      const a = r.t(null, void 0, i(134986))
      function l(e, t) {
        return o()(e).minus(t).abs().gt(o()(e).div(2))
      }
      function c(e) {
        const {
          price: t,
          askOrBid: s,
          orderType: c,
          side: d,
          isStopPrice: u,
          isForex: h,
          formatter: p,
          supportStopOrdersInBothDirections: g,
          supportStopLimitOrdersInBothDirections: m,
          supportStrictCheckingLimitOrderPrice: _,
          step: b,
          roundedToStep: v,
        } = e
        if ((!h || v) && !1 === (0, n.isMintickMultiple)(t, b))
          return {
            res: !0,
            severity: 'error',
            msg: r.t(null, void 0, i(130927)).format({ minTick: p.format(b) }),
          }
        const y =
          t < 0 ||
          o()(s).mul(100).lt(t) ||
          ((e) => {
            const {
              price: t,
              askOrBid: i,
              orderType: r,
              side: s,
              isStopPrice: o,
              supportStopOrdersInBothDirections: n,
              supportStopLimitOrdersInBothDirections: a,
              supportStrictCheckingLimitOrderPrice: c,
            } = e
            return 1 === r
              ? 1 === s
                ? t > i && (l(i, t) || c)
                : t < i && (l(i, t) || c)
              : !!((3 === r && !n) || (4 === r && o && !a)) &&
                  (1 === s ? t < i : t > i)
          })({
            price: t,
            askOrBid: s,
            orderType: c,
            side: d,
            isStopPrice: u,
            supportStopOrdersInBothDirections: g,
            supportStopLimitOrdersInBothDirections: m,
            supportStrictCheckingLimitOrderPrice: _,
          })
        return y ? { res: !0, severity: 'error', msg: a } : { res: !1 }
      }
    },
    232192: (e, t, i) => {
      i.d(t, {
        extractLimitValidationRules: () => g,
        extractStopLossValidationRules: () => h,
        extractStopValidationRules: () => p,
        extractTakeProfitValidationRules: () => u,
        isLimitPercentValidationRule: () => l,
        isStopLimitPercentValidationRule: () => a,
        isStopPercentValidationRule: () => c,
      })
      const r = ['tpPercent'],
        s = ['slPercent'],
        o = ['stopPercent'],
        n = ['limitPercent']
      function a(e) {
        return l(e) || c(e)
      }
      function l(e) {
        return n.includes(e.id)
      }
      function c(e) {
        return o.includes(e.id)
      }
      function d(e, t, i) {
        var r
        return null === (r = e.getValidationRules(t)) || void 0 === r
          ? void 0
          : r.filter((e) => i.includes(e.id))
      }
      function u(e, t) {
        return d(e, t, r)
      }
      function h(e, t) {
        return d(e, t, s)
      }
      function p(e, t) {
        return d(e, t, o)
      }
      function g(e, t) {
        return d(e, t, n)
      }
    },
    330012: (e, t, i) => {
      i.d(t, { abbreviatedNumber: () => n })
      i(960521)
      var r = i(424030)
      const s = ['', 'K', 'M', 'G', 'T', 'P']
      function o(e) {
        return e < s.length ? s[e] : 'e' + 3 * e
      }
      function n(e) {
        if (e < 1) return r.NumericFormatter.formatNoE(e)
        let t = 0,
          i = +e
        if (isFinite(i)) while (i >= 1e3 && i % 100 == 0) t++, (i /= 1e3)
        return i + o(t)
      }
    },
    660538: (e, t, i) => {
      i.d(t, {
        mediaQueryAddEventListener: () => r,
        mediaQueryRemoveEventListener: () => s,
      })
      const r = (e, t) => {
          ;(null == e ? void 0 : e.addEventListener)
            ? e.addEventListener('change', t)
            : e.addListener(t)
        },
        s = (e, t) => {
          ;(null == e ? void 0 : e.removeEventListener)
            ? e.removeEventListener('change', t)
            : e.removeListener(t)
        }
    },
    340794: (e, t, i) => {
      function r(e) {
        let t = Promise.resolve()
        return function (...i) {
          const r = t.then(() => e.apply(this, i))
          return (t = r.catch(() => {})), r
        }
      }
      i.d(t, { sequentialize: () => r })
    },
    48008: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" fill-rule="evenodd" d="M3 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 1a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm6-1a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm0 1a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm7-2a1 1 0 1 1-2 0 1 1 0 0 1 2 0zm1 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0z"/></svg>'
    },
    117105: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path stroke="currentColor" stroke-width="1.2" d="m1.5 1.5 21 21m0-21-21 21"/></svg>'
    },
    315130: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path stroke="currentColor" stroke-width="1.2" d="m1.5 1.5 15 15m0-15-15 15"/></svg>'
    },
    238822: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" width="14" height="14"><path stroke="currentColor" stroke-width="1.2" d="m1.5 1.5 11 11m0-11-11 11"/></svg>'
    },
    663346: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 12" width="12" height="12"><path stroke="currentColor" stroke-width="1.2" d="m1.5 1.5 9 9m0-9-9 9"/></svg>'
    },
    534983: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10" width="10" height="10"><path stroke="currentColor" stroke-width="1.2" d="m1.5 1.5 7 7m0-7-7 7"/></svg>'
    },
    512646: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M7.84 13.7H5.78V4.4l2.48-.06c1.35 0 2.42.4 3.22 1.2.8.78 1.19 1.83 1.19 3.15 0 3.34-1.61 5.01-4.83 5.01zm-.41-7.85v6.35c.26.02.55.03.86.03.83 0 1.48-.3 1.95-.9.48-.6.72-1.46.72-2.54 0-2-.93-2.99-2.78-2.99-.18 0-.43.02-.75.05z"/></svg>'
    },
    552828: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18"><path fill="currentColor" d="M13.4 5.9c-.41 1.62-1.16 2.43-2.25 2.43-.52 0-1.25-.15-2.2-.45-.93-.3-1.58-.45-1.96-.45-.55 0-.98.3-1.27.9H4.66c.1-.67.36-1.24.76-1.71.4-.48.86-.72 1.4-.72.56 0 1.31.16 2.27.46.95.3 1.62.45 2.01.45.64 0 1.06-.3 1.27-.9h1.03zm0 3.87c-.41 1.62-1.16 2.43-2.25 2.43-.52 0-1.25-.15-2.2-.45-.93-.3-1.58-.46-1.96-.46-.55 0-.98.3-1.27.9H4.66c.1-.67.36-1.24.76-1.7.4-.48.86-.72 1.4-.72.56 0 1.31.15 2.27.46.95.3 1.62.44 2.01.44.64 0 1.06-.3 1.27-.9h1.03z"/></svg>'
    },
    379978: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18" fill="none"><path stroke="currentColor" d="M8 5l3.5 3.5L8 12"/></svg>'
    },
    643959: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path stroke="currentcolor" stroke-width="1.2" d="M17 21l-7.5-7.5L17 6"/></svg>'
    },
    966883: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" fill="none" stroke="currentcolor"><path d="M3.5 10A6.5 6.5 0 1 0 10 3.5H5.233M7.5 6.5l-3-3 3-3"/></svg>'
    },
    513729: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28" fill="none"><path stroke="currentColor" stroke-width="1.2" d="M7 6l15 15m0-15L7 21"/></svg>'
    },
    29834: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" width="28" height="28"><path fill="currentColor" d="M7.5 13a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM5 14.5a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0zm9.5-1.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM12 14.5a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0zm9.5-1.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM19 14.5a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0z"/></svg>'
    },
    816105: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 72" width="72" height="72" fill="none"><g clip-path="url(#clip0)"><path fill="#363A45" fill-rule="evenodd" clip-rule="evenodd" d="M62.1259 28.2153C61.4066 28.8157 61.0001 29.7273 61.0858 30.6604C61.6716 37.0347 59.7763 44.3291 55.3181 50.8221C46.9016 63.0797 32.5383 67.839 23.2366 61.4522C13.935 55.0654 13.2174 39.9512 21.6339 27.6935C26.4984 20.6088 33.3496 16.029 40.0619 14.6585C40.9752 14.472 41.731 13.8291 42.1024 12.9741C42.485 12.0934 42.9606 11.2346 43.5313 10.4123C47.906 4.1093 56.2129 2.33004 62.0853 6.4382C67.9578 10.5464 69.172 18.9863 64.7974 25.2892C64.0194 26.4103 63.1169 27.3882 62.1259 28.2153Z"/><rect width="47.2" height="34" fill="#1E222D" stroke="#B2B5BE" stroke-width="2" rx="3.8" x="12.4004" y="16"/><path stroke="#B2B5BE" stroke-linecap="round" stroke-width="2" d="M3.59961 54H67.1996"/><path fill="#B2B5BE" fill-rule="evenodd" clip-rule="evenodd" d="M29.1178 31.1324L30.8107 32.8253L32.225 31.4111L30.5321 29.7182L32.225 28.0253L30.8107 26.6111L29.1178 28.304L27.425 26.6111L26.0107 28.0253L27.7036 29.7182L26.0107 31.4111L27.425 32.8253L29.1178 31.1324Z"/><path fill="#B2B5BE" fill-rule="evenodd" clip-rule="evenodd" d="M43.5182 31.1324L45.2111 32.8253L46.6253 31.4111L44.9325 29.7182L46.6253 28.0253L45.2111 26.6111L43.5182 28.304L41.8253 26.6111L40.4111 28.0253L42.104 29.7182L40.4111 31.4111L41.8253 32.8253L43.5182 31.1324Z"/><path stroke="#B2B5BE" stroke-width="2" d="M30.5996 38.7H40.7996"/></g></svg>'
    },
    627687: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 72" width="72" height="72" fill="none"><g clip-path="url(#clip0)"><path fill="#F0F3FA" fill-rule="evenodd" clip-rule="evenodd" d="M62.1259 28.2153C61.4066 28.8157 61.0001 29.7273 61.0858 30.6604C61.6716 37.0347 59.7763 44.3291 55.3181 50.8221C46.9016 63.0797 32.5383 67.839 23.2366 61.4522C13.935 55.0654 13.2174 39.9512 21.6339 27.6935C26.4984 20.6088 33.3496 16.029 40.0619 14.6585C40.9752 14.472 41.731 13.8291 42.1024 12.9741C42.485 12.0934 42.9606 11.2346 43.5313 10.4123C47.906 4.1093 56.2129 2.33004 62.0853 6.4382C67.9578 10.5464 69.172 18.9863 64.7974 25.2892C64.0194 26.4103 63.1169 27.3882 62.1259 28.2153Z"/><rect width="47.2" height="34" fill="#fff" stroke="#1E222D" stroke-width="2" rx="3.8" x="12.4004" y="16"/><path stroke="#1E222D" stroke-linecap="round" stroke-width="2" d="M3.59961 54H67.1996"/><path fill="#000" fill-rule="evenodd" clip-rule="evenodd" d="M29.1178 31.1324L30.8107 32.8253L32.225 31.4111L30.5321 29.7182L32.225 28.0253L30.8107 26.6111L29.1178 28.304L27.425 26.6111L26.0107 28.0253L27.7036 29.7182L26.0107 31.4111L27.425 32.8253L29.1178 31.1324Z"/><path fill="#000" fill-rule="evenodd" clip-rule="evenodd" d="M43.5182 31.1324L45.2111 32.8253L46.6253 31.4111L44.9325 29.7182L46.6253 28.0253L45.2111 26.6111L43.5182 28.304L41.8253 26.6111L40.4111 28.0253L42.104 29.7182L40.4111 31.4111L41.8253 32.8253L43.5182 31.1324Z"/><path stroke="#000" stroke-width="2" d="M30.5996 38.7H40.7996"/></g></svg>'
    },
    829883: (e) => {
      e.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 16" width="20" height="16"><path fill="currentColor" fill-rule="evenodd" d="M7.5 2.5C7.5 1.67 8.17 1 9 1h2c.83 0 1.5.67 1.5 1.5v.15h-5V2.5zm6 0v.15H17a2.5 2.5 0 0 1 2.5 2.5v8.35A2.5 2.5 0 0 1 17 16H3a2.5 2.5 0 0 1-2.5-2.5V5.15A2.5 2.5 0 0 1 3 2.65h3.5V2.5A2.5 2.5 0 0 1 9 0h2a2.5 2.5 0 0 1 2.5 2.5zm-12 2.65c0-.83.67-1.5 1.5-1.5h14c.83 0 1.5.67 1.5 1.5v8.35c0 .83-.67 1.5-1.5 1.5H3a1.5 1.5 0 0 1-1.5-1.5V5.15zM9.25 6.5a1.75 1.75 0 1 0 0 3.5h1.5a.75.75 0 0 1 0 1.5h-1.5a.75.75 0 0 1-.75-.75h-1c0 .97.78 1.75 1.75 1.75h.25v1h1v-1h.25a1.75 1.75 0 1 0 0-3.5h-1.5a.75.75 0 0 1 0-1.5h1.5c.41 0 .75.34.75.75h1c0-.97-.78-1.75-1.75-1.75h-.25v-1h-1v1h-.25z"/></svg>'
    },
    586240: (e) => {
      e.exports = JSON.parse(
        '{"size-header-height":"64px","media-phone-vertical":"screen and (max-width: 479px)","media-mf-phone-landscape":"screen and (min-width: 568px)"}',
      )
    },
  },
])
