;(self.webpackChunktradingview = self.webpackChunktradingview || []).push([
  [4627],
  {
    85214: (t) => {
      t.exports = {}
    },
    309268: (t) => {
      t.exports = { container: 'container-l6FVmx3S' }
    },
    515099: (t) => {
      t.exports = {
        wrapper: 'wrapper-j3GOYMat',
        button: 'button-j3GOYMat',
        position: 'position-j3GOYMat',
        buy: 'buy-j3GOYMat',
        sell: 'sell-j3GOYMat',
        pl: 'pl-j3GOYMat',
        profit: 'profit-j3GOYMat',
        loss: 'loss-j3GOYMat',
      }
    },
    236128: (t) => {
      t.exports = {
        headerWrapper: 'headerWrapper-tEyqHGm0',
        header: 'header-tEyqHGm0',
        customField: 'customField-tEyqHGm0',
        duration: 'duration-tEyqHGm0',
        arrow: 'arrow-tEyqHGm0',
        upperCase: 'upperCase-tEyqHGm0',
        textBlock: 'textBlock-tEyqHGm0',
        summaryLine: 'summaryLine-tEyqHGm0',
      }
    },
    216258: (t) => {
      t.exports = {
        widgetcolumnwidthbuysell: '62px',
        widgetcolumnwidthmiddle: '70px',
        widgetcolumnwidthorders: '56px',
        widgetborderwidth: '1px',
        'tv-dom-panel': 'tv-dom-panel-WJ5VG8Pz',
        'tv-dom-panel__header': 'tv-dom-panel__header-WJ5VG8Pz',
        'tv-dom-panel__header-title': 'tv-dom-panel__header-title-WJ5VG8Pz',
        'tv-dom-panel__header-symbol': 'tv-dom-panel__header-symbol-WJ5VG8Pz',
        'tv-dom-panel__header-exchange':
          'tv-dom-panel__header-exchange-WJ5VG8Pz',
        'tv-dom-panel__header-close': 'tv-dom-panel__header-close-WJ5VG8Pz',
        'tv-dom-panel__header-warning': 'tv-dom-panel__header-warning-WJ5VG8Pz',
        'tv-dom-panel__header-warning--active':
          'tv-dom-panel__header-warning--active-WJ5VG8Pz',
        'tv-dom-panel__content': 'tv-dom-panel__content-WJ5VG8Pz',
        'tv-dom-panel__warning': 'tv-dom-panel__warning-WJ5VG8Pz',
        'tv-dom-panel__disabled': 'tv-dom-panel__disabled-WJ5VG8Pz',
        'tv-dom-panel__disabled-warning':
          'tv-dom-panel__disabled-warning-WJ5VG8Pz',
        mainblock: 'mainblock-WJ5VG8Pz',
        emptyStateImage: 'emptyStateImage-WJ5VG8Pz',
        header: 'header-WJ5VG8Pz',
      }
    },
    663237: (t) => {
      t.exports = { wrapper: 'wrapper-BpNh_MLZ', title: 'title-BpNh_MLZ' }
    },
    41142: (t) => {
      t.exports = {
        upperBlock: 'upperBlock-pOOE9kBn',
        bottomBlock: 'bottomBlock-pOOE9kBn',
      }
    },
    392285: (t) => {
      t.exports = {
        widgetcolumnwidthbuysell: '62px',
        widgetcolumnwidthmiddle: '70px',
        widgetcolumnwidthorders: '56px',
        widgetordertypeheight: '10px',
        widgetborderwidth: '1px',
        widgetrowheight: '20px',
        'tv-dom-widget-main': 'tv-dom-widget-main-S1ZrBpKB',
        'tv-dom-widget-main__anchor': 'tv-dom-widget-main__anchor-S1ZrBpKB',
        'tv-dom-widget-main__row': 'tv-dom-widget-main__row-S1ZrBpKB',
        'tv-dom-widget-main__value': 'tv-dom-widget-main__value-S1ZrBpKB',
        'tv-dom-widget-main__value--price':
          'tv-dom-widget-main__value--price-S1ZrBpKB',
        'tv-dom-widget-main__value--highlighted':
          'tv-dom-widget-main__value--highlighted-S1ZrBpKB',
        'tv-dom-widget-main__value--long-position':
          'tv-dom-widget-main__value--long-position-S1ZrBpKB',
        'tv-dom-widget-main__value--short-position':
          'tv-dom-widget-main__value--short-position-S1ZrBpKB',
        'tv-dom-widget-main__value--buy':
          'tv-dom-widget-main__value--buy-S1ZrBpKB',
        'tv-dom-widget-main__value--sell':
          'tv-dom-widget-main__value--sell-S1ZrBpKB',
        'tv-dom-widget-main__value--orders-buy':
          'tv-dom-widget-main__value--orders-buy-S1ZrBpKB',
        'tv-dom-widget-main__value--orders-sell':
          'tv-dom-widget-main__value--orders-sell-S1ZrBpKB',
        'tv-dom-widget-main__value--color-bid':
          'tv-dom-widget-main__value--color-bid-S1ZrBpKB',
        'tv-dom-widget-main__value--color-ask':
          'tv-dom-widget-main__value--color-ask-S1ZrBpKB',
        'tv-dom-widget-main__label': 'tv-dom-widget-main__label-S1ZrBpKB',
        'tv-dom-widget-main__label--active':
          'tv-dom-widget-main__label--active-S1ZrBpKB',
        'tv-dom-widget-main__meter': 'tv-dom-widget-main__meter-S1ZrBpKB',
        'tv-dom-widget-main__meter--buy':
          'tv-dom-widget-main__meter--buy-S1ZrBpKB',
        'tv-dom-widget-main__meter--buy-active':
          'tv-dom-widget-main__meter--buy-active-S1ZrBpKB',
        'tv-dom-widget-main__meter--sell':
          'tv-dom-widget-main__meter--sell-S1ZrBpKB',
        'tv-dom-widget-main__meter--sell-active':
          'tv-dom-widget-main__meter--sell-active-S1ZrBpKB',
        'tv-dom-widget-main__value-readout':
          'tv-dom-widget-main__value-readout-S1ZrBpKB',
        'tv-dom-widget-main__offscreen-arrow':
          'tv-dom-widget-main__offscreen-arrow-S1ZrBpKB',
        'tv-dom-widget-main__offscreen-arrow--higher':
          'tv-dom-widget-main__offscreen-arrow--higher-S1ZrBpKB',
        'tv-dom-widget-main__offscreen-arrow--lower':
          'tv-dom-widget-main__offscreen-arrow--lower-S1ZrBpKB',
        'tv-dom-widget-main__order': 'tv-dom-widget-main__order-S1ZrBpKB',
        'tv-dom-widget-main__order--collapsed':
          'tv-dom-widget-main__order--collapsed-S1ZrBpKB',
        'tv-dom-widget-main__drag-shield':
          'tv-dom-widget-main__drag-shield-S1ZrBpKB',
        'tv-dom-widget-main__drag-shield--order':
          'tv-dom-widget-main__drag-shield--order-S1ZrBpKB',
        'tv-dom-widget-main__hidden': 'tv-dom-widget-main__hidden-S1ZrBpKB',
      }
    },
    717408: (t) => {
      t.exports = {
        widgetcolumnwidthbuysell: '62px',
        widgetcolumnwidthmiddle: '70px',
        widgetborderwidth: '1px',
        widgetyellow: '#ffc84a',
        'tv-dom-widget-nav': 'tv-dom-widget-nav-yruos59d',
        'tv-dom-widget-nav__button-block':
          'tv-dom-widget-nav__button-block-yruos59d',
        'tv-dom-widget-nav__button-block--price':
          'tv-dom-widget-nav__button-block--price-yruos59d',
        'tv-dom-widget-nav__button-block--orders':
          'tv-dom-widget-nav__button-block--orders-yruos59d',
        'tv-dom-widget-nav__button': 'tv-dom-widget-nav__button-yruos59d',
        'tv-dom-widget-nav__button--clear-ask':
          'tv-dom-widget-nav__button--clear-ask-yruos59d',
        'tv-dom-widget-nav__button--clear-bid':
          'tv-dom-widget-nav__button--clear-bid-yruos59d',
        'tv-dom-widget-nav__button--disabled':
          'tv-dom-widget-nav__button--disabled-yruos59d',
        'tv-dom-widget-nav__button--center':
          'tv-dom-widget-nav__button--center-yruos59d',
        'tv-dom-widget-nav_center': 'tv-dom-widget-nav_center-yruos59d',
        'tv-dom-widget-nav_overall-volume':
          'tv-dom-widget-nav_overall-volume-yruos59d',
        'tv-dom-widget-nav_overall-volume--ask':
          'tv-dom-widget-nav_overall-volume--ask-yruos59d',
        'tv-dom-widget-nav_overall-volume--bid':
          'tv-dom-widget-nav_overall-volume--bid-yruos59d',
        'tv-dom-widget-nav_count-volume':
          'tv-dom-widget-nav_count-volume-yruos59d',
        'tv-dom-widget-nav__timer': 'tv-dom-widget-nav__timer-yruos59d',
      }
    },
    280231: (t) => {
      t.exports = {
        widgetordertypeheight: '10px',
        widgetrowheight: '20px',
        widgetborderwidth: '1px',
        widgetyellow: '#ffc84a',
        'tv-dom-widget-order': 'tv-dom-widget-order-YzgGdJzq',
        'tv-dom-widget-order--ghost': 'tv-dom-widget-order--ghost-YzgGdJzq',
        'tv-dom-widget-order--inactive':
          'tv-dom-widget-order--inactive-YzgGdJzq',
        'tv-dom-widget-order--type-stop':
          'tv-dom-widget-order--type-stop-YzgGdJzq',
        'tv-dom-widget-order__close': 'tv-dom-widget-order__close-YzgGdJzq',
        'tv-dom-widget-order--type-stoplimit':
          'tv-dom-widget-order--type-stoplimit-YzgGdJzq',
        'tv-dom-widget-order--highlighted':
          'tv-dom-widget-order--highlighted-YzgGdJzq',
        'tv-dom-widget-order--buy': 'tv-dom-widget-order--buy-YzgGdJzq',
        'tv-dom-widget-order--notcanceled':
          'tv-dom-widget-order--notcanceled-YzgGdJzq',
        'tv-dom-widget-order__qty': 'tv-dom-widget-order__qty-YzgGdJzq',
        'tv-dom-widget-order--immovable':
          'tv-dom-widget-order--immovable-YzgGdJzq',
        'tv-dom-widget-order--unmodified':
          'tv-dom-widget-order--unmodified-YzgGdJzq',
        'tv-dom-widget-order__type': 'tv-dom-widget-order__type-YzgGdJzq',
      }
    },
    509959: (t) => {
      t.exports = {
        wrapper: 'wrapper-btWtGFgr',
        marketBlock: 'marketBlock-btWtGFgr',
        tradingActionBlock: 'tradingActionBlock-btWtGFgr',
        container: 'container-btWtGFgr',
        row: 'row-btWtGFgr',
        button: 'button-btWtGFgr',
        buttonOrdinary: 'buttonOrdinary-btWtGFgr button-btWtGFgr',
        buttonBuy: 'buttonBuy-btWtGFgr button-btWtGFgr',
        buttonSell: 'buttonSell-btWtGFgr button-btWtGFgr',
      }
    },
    73245: (t, e, i) => {
      i.r(e), i.d(e, { DOMPanel: () => jt })
      var s,
        o = i(609838),
        r = i(500962),
        n = i(50959),
        a = i(662941),
        l = i(650802),
        d = i(650151),
        h = i(870122),
        u = i(180185),
        c = i(960521),
        _ = i.n(c),
        m = i(159255),
        p = i(947488),
        v = i(997345),
        g = i(481330),
        b = i(181436),
        w = i(44681),
        y = i(322625),
        f = i(918114),
        k = i(357407),
        x = i(330012),
        S = i(973602),
        P = i(462056),
        I = i(98454),
        T = i(807107)
      !((t) => {
        ;(t[(t.Inside = 0)] = 'Inside'),
          (t[(t.Lower = 1)] = 'Lower'),
          (t[(t.Higher = 2)] = 'Higher')
      })(s || (s = {}))
      var O = i(737538),
        B = i(424030),
        V = i(804395),
        C = i(280231),
        N = i(392285)
      const L = {
        limitOrder: o.t(null, void 0, i(398157)),
        stopOrder: o.t(null, void 0, i(905023)),
      }
      class M {
        constructor(t) {
          ;(this._pool = []),
            (this._handlers = t || {}),
            (this._ordersPool = new E(this._handlers)),
            (this._useCssTransform =
              'transform' in document.createElement('span').style)
        }
        allocate() {
          return (
            this._pool.pop() ||
            new D(this._ordersPool, this._handlers, this._useCssTransform)
          )
        }
        free(t) {
          t.destroy(), this._pool.push(t)
        }
      }
      class D {
        constructor(t, e, i) {
          ;(this._isStopOrderModeEnabled = !1),
            (this._price = 0),
            (this._useCssTransform = i),
            (this._ordersPool = t),
            (this._handlers = e),
            (this._allocatedOrderViews = [])
          const s = document.createElement('div')
          s.setAttribute('class', N['tv-dom-widget-main__row'])
          const o = document.createElement('span')
          o.setAttribute(
            'class',
            `${N['tv-dom-widget-main__value']} ${N['tv-dom-widget-main__value--price']}`,
          )
          const r = document.createElement('span')
          r.setAttribute(
            'class',
            `${N['tv-dom-widget-main__value']} ${N['tv-dom-widget-main__value--sell']}`,
          )
          const n = document.createElement('span')
          n.setAttribute(
            'class',
            `${N['tv-dom-widget-main__value']} ${N['tv-dom-widget-main__value--buy']}`,
          )
          const a = document.createElement('span')
          a.setAttribute(
            'class',
            `${N['tv-dom-widget-main__meter']} ${N['tv-dom-widget-main__meter--sell']}`,
          )
          const l = document.createElement('span')
          l.setAttribute(
            'class',
            `${N['tv-dom-widget-main__meter']} ${N['tv-dom-widget-main__meter--buy']}`,
          )
          const d = document.createElement('span')
          d.setAttribute('class', N['tv-dom-widget-main__value-readout'])
          const h = document.createElement('span')
          h.setAttribute('class', N['tv-dom-widget-main__value-readout'])
          const u = document.createTextNode(''),
            c = document.createTextNode(''),
            _ = document.createTextNode('')
          this._useCssTransform &&
            ((a.style.width = l.style.width = '100%'),
            (a.style.transform = l.style.transform = 'scale(0, 1)'))
          const m = document.createElement('span')
          m.setAttribute(
            'class',
            `${N['tv-dom-widget-main__value']} ${N['tv-dom-widget-main__value--orders-buy']}`,
          )
          const p = document.createElement('span')
          ;(p.textContent = L.limitOrder),
            p.setAttribute('class', N['tv-dom-widget-main__label']),
            m.appendChild(p)
          const v = document.createElement('span')
          v.setAttribute(
            'class',
            `${N['tv-dom-widget-main__value']} ${N['tv-dom-widget-main__value--orders-sell']}`,
          )
          const g = document.createElement('span')
          ;(g.textContent = L.limitOrder),
            g.setAttribute('class', N['tv-dom-widget-main__label']),
            v.appendChild(g),
            s.appendChild(r),
            s.appendChild(n),
            s.appendChild(o),
            s.appendChild(m),
            s.appendChild(v),
            o.appendChild(_),
            r.appendChild(a),
            n.appendChild(l),
            r.appendChild(d),
            n.appendChild(h),
            d.appendChild(u),
            h.appendChild(c),
            (this._priceCell = o),
            (this._priceText = _),
            (this._askText = u),
            (this._bidText = c),
            (this._askMeter = a),
            (this._bidMeter = l),
            (this._ordersBuy = m),
            (this._ordersSell = v),
            (this._orderBuyLabel = p),
            (this._orderSellLabel = g),
            (this._isHigherThanBestBid = !1),
            (this._isLowerThanBestAsk = !1),
            (this._orderType = 1),
            e &&
              e.bidAskClick &&
              (r.addEventListener(
                'click',
                (t) => this._handlerCellClick(-1, t),
                !1,
              ),
              n.addEventListener(
                'click',
                (t) => this._handlerCellClick(1, t),
                !1,
              )),
            e &&
              e.bidAskContextMenu &&
              (r.addEventListener(
                'contextmenu',
                (t) => {
                  e.bidAskContextMenu.call(null, t, {
                    price: this._price,
                    side: -1,
                  })
                },
                !1,
              ),
              n.addEventListener(
                'contextmenu',
                (t) => {
                  e.bidAskContextMenu.call(null, t, {
                    price: this._price,
                    side: 1,
                  })
                },
                !1,
              )),
            r.addEventListener(
              V.mobiletouch ? 'touchstart' : 'mouseover',
              (t) => {
                ;(g.textContent = this._isStopOrderModeEnabled
                  ? L.stopOrder
                  : L.limitOrder),
                  (g.style.visibility = 'visible')
              },
              !1,
            ),
            r.addEventListener(
              V.mobiletouch ? 'touchend' : 'mouseout',
              () => {
                g.style.visibility = 'hidden'
              },
              !1,
            ),
            n.addEventListener(
              V.mobiletouch ? 'touchstart' : 'mouseover',
              (t) => {
                ;(p.textContent = this._isStopOrderModeEnabled
                  ? L.stopOrder
                  : L.limitOrder),
                  (p.style.visibility = 'visible')
              },
              !1,
            ),
            n.addEventListener(
              V.mobiletouch ? 'touchend' : 'mouseout',
              () => {
                p.style.visibility = 'hidden'
              },
              !1,
            ),
            (this.element = s)
        }
        updatePriceText(t) {
          this._priceText.nodeValue = t
        }
        updateBidVolume(t) {
          this._bidText.nodeValue !== t && (this._bidText.nodeValue = t)
        }
        updateAskVolume(t) {
          this._askText.nodeValue !== t && (this._askText.nodeValue = t)
        }
        updateBidMeter(t) {
          const e = Math.min(Math.max(t, 0), 1) || 0
          this._useCssTransform
            ? (this._bidMeter.style.transform = `scale(${e}, 1)`)
            : (this._bidMeter.style.width = 100 * e + '%')
        }
        updateAskMeter(t) {
          const e = Math.min(Math.max(t, 0), 1) || 0
          this._useCssTransform
            ? (this._askMeter.style.transform = `scale(${e}, 1)`)
            : (this._askMeter.style.width = 100 * e + '%')
        }
        updatePriceHighlight(t, e) {
          const i = this._priceCell.classList
          if (i)
            i.toggle(N['tv-dom-widget-main__value--highlighted'], t),
              i.toggle(N['tv-dom-widget-main__value--long-position'], e > 0),
              i.toggle(N['tv-dom-widget-main__value--short-position'], e < 0)
          else {
            let i = `${N['tv-dom-widget-main__value']} ${N['tv-dom-widget-main__value--price']}`
            t && (i += ` ${N['tv-dom-widget-main__value--highlighted']}`),
              e > 0
                ? (i += ` ${N['tv-dom-widget-main__value--long-position']}`)
                : e < 0 &&
                  (i += ` ${N['tv-dom-widget-main__value--short-position']}`),
              this._priceCell.setAttribute('class', i)
          }
        }
        setHigherThanBid(t) {
          ;(this._isHigherThanBestBid = t),
            this._updateLabelColor(this._orderBuyLabel, this._isActive(t))
        }
        updateAskLabels(t) {
          ;(this._isLowerThanBestAsk = t),
            this._updateLabelColor(this._orderSellLabel, this._isActive(t))
        }
        setStopOrderMode(t) {
          ;(this._isStopOrderModeEnabled = t),
            (this._orderType = t ? 3 : 1),
            (this._orderSellLabel.textContent = t ? L.stopOrder : L.limitOrder),
            (this._orderBuyLabel.textContent = t ? L.stopOrder : L.limitOrder),
            this._updateLabelColor(
              this._orderBuyLabel,
              this._isActive(this._isHigherThanBestBid),
            ),
            this._updateLabelColor(
              this._orderSellLabel,
              this._isActive(this._isLowerThanBestAsk),
            )
        }
        updatePrice(t) {
          this._price = t
        }
        updateOrders(t) {
          for (var e; this._allocatedOrderViews.length > t.length; ) {
            const t = this._allocatedOrderViews.pop()
            t && this._ordersPool.free(t)
          }
          while (this._allocatedOrderViews.length < t.length)
            this._allocatedOrderViews.push(this._ordersPool.allocate())
          const i = {}
          for (let s = 0; s < t.length; s++) {
            const o = t[s],
              r = this._allocatedOrderViews[s],
              n = Boolean(o.buy),
              a = n ? 1 : -1
            null === (e = i[a]) || void 0 === e || e.collapse(),
              (i[a] = o.noCollapse ? void 0 : r),
              o.order !== r.order() &&
                (r.updateOrderData(o.order, o.pricePropertyName),
                r.updateQty(o.qty),
                r.updateTypeText(o.typeText),
                n
                  ? this._ordersBuy.prepend(r.element)
                  : this._ordersSell.append(r.element)),
              r.updateClassName({
                isBuy: n,
                type: o.type,
                inactive: o.inactive,
                ghost: o.ghost,
                highlighted: o.highlighted,
                isModifiable: o.isModifiable,
                isMovable: o.isMovable,
                isCancellable: o.isCancellable,
              })
          }
        }
        destroy() {
          const t = this._allocatedOrderViews.length
          if (t > 0) {
            for (let e = 0; e < t; e++)
              this._ordersPool.free(this._allocatedOrderViews[e])
            this._allocatedOrderViews.length = 0
          }
        }
        paintPrice(t) {
          const e = this.element.classList
          e.toggle(N['tv-dom-widget-main__value--color-ask'], 'ask' === t),
            e.toggle(N['tv-dom-widget-main__value--color-bid'], 'bid' === t)
        }
        _handlerCellClick(t, e) {
          const i = (0, u.modifiersFromEvent)(e)
          if (![u.Modifiers.None, u.Modifiers.Mod].includes(i)) return
          const s = 1 === t ? this._bidMeter : this._askMeter,
            o = 1 === t ? 'buy' : 'sell'
          clearTimeout(this._activeStateTimerId),
            s.classList.add(`${N[`tv-dom-widget-main__meter--${o}-active`]}`),
            (this._activeStateTimerId = setTimeout(() => {
              s.classList.remove(
                `${N[`tv-dom-widget-main__meter--${o}-active`]}`,
              )
            }, 500)),
            this._handlers.bidAskClick.call(null, e, {
              price: this._price,
              side: t,
              type: i === u.Modifiers.Mod ? 3 : 1,
            })
        }
        _updateLabelColor(t, e) {
          const i = t.classList
          if (i) i.toggle(N['tv-dom-widget-main__label--active'], e)
          else {
            let i = N['tv-dom-widget-main__label']
            e && (i += ` ${N['tv-dom-widget-main__label--active']}`),
              t.setAttribute('class', i)
          }
        }
        _isActive(t) {
          const e = 3 === this._orderType
          return (e && !t) || (!e && t)
        }
      }
      class E {
        constructor(t) {
          ;(this._pool = []), (this._handlers = t)
        }
        allocate() {
          return this._pool.pop() || new F(this._handlers)
        }
        free(t) {
          t.destroy(), this._pool.push(t)
        }
      }
      class F {
        constructor(t) {
          ;(this._order = null), (this._pricePropertyName = null)
          const e = document.createElement('div')
          e.setAttribute(
            'class',
            `${N['tv-dom-widget-main__order']} ${C['tv-dom-widget-order']}`,
          )
          const s = document.createElement('div')
          ;(s.innerHTML = i(548927)),
            s.setAttribute('class', C['tv-dom-widget-order__close'])
          const o = document.createElement('span')
          o.setAttribute('class', C['tv-dom-widget-order__qty'])
          const r = document.createTextNode(''),
            n = document.createElement('span')
          n.setAttribute('class', C['tv-dom-widget-order__type'])
          const a = document.createTextNode('')
          e.appendChild(s),
            e.appendChild(o),
            o.appendChild(r),
            e.appendChild(n),
            n.appendChild(a),
            t &&
              t.closeButtonClick &&
              s.addEventListener(
                'click',
                (e) => {
                  t.closeButtonClick.call(null, e, this._order)
                },
                !1,
              ),
            t &&
              t.qtyClick &&
              o.addEventListener(
                'click',
                (e) => {
                  t.qtyClick.call(null, e, this._order)
                },
                !1,
              ),
            t &&
              t.orderMousedown &&
              o.addEventListener(
                'mousedown',
                (e) => {
                  null !== this._order &&
                    null !== this._pricePropertyName &&
                    t.orderMousedown.call(null, e, {
                      order: this._order,
                      pricePropertyName: this._pricePropertyName,
                    })
                },
                !1,
              ),
            (this.element = e),
            (this._qtyText = r),
            (this._typeText = a)
        }
        order() {
          return this._order
        }
        updateQty(t) {
          this._qtyText.nodeValue = t || ''
        }
        updateTypeText(t) {
          this._typeText.nodeValue = t || ''
        }
        updateClassName(t) {
          const {
              isBuy: e,
              type: i,
              inactive: s,
              ghost: o,
              highlighted: r,
              isModifiable: n,
              isMovable: a,
              isCancellable: l,
            } = t,
            d = this.element
          ;(d.className = `${N['tv-dom-widget-main__order']} ${C['tv-dom-widget-order']}`),
            d.classList.toggle(C['tv-dom-widget-order--buy'], !!e),
            d.classList.toggle(C[`tv-dom-widget-order--type-${i}`], !!i),
            d.classList.toggle(C['tv-dom-widget-order--inactive'], !!s),
            d.classList.toggle(C['tv-dom-widget-order--ghost'], !!o),
            d.classList.toggle(C['tv-dom-widget-order--highlighted'], !!r),
            d.classList.toggle(C['tv-dom-widget-order--unmodified'], !1 === n),
            d.classList.toggle(C['tv-dom-widget-order--immovable'], !1 === a),
            d.classList.toggle(C['tv-dom-widget-order--notcanceled'], !1 === l)
        }
        collapse() {
          this.element.classList.add(N['tv-dom-widget-main__order--collapsed'])
        }
        updateOrderData(t, e) {
          ;(this._order = t), (this._pricePropertyName = e)
        }
        destroy() {
          this.element.parentNode &&
            this.element.parentNode.removeChild(this.element),
            (this._order = null)
        }
      }
      function A(t, e) {
        const i = []
        if (0 === t.length || 0 === e.length) return [...t, ...e]
        let s = 0,
          o = 0
        while (s <= t.length && o <= e.length) {
          const r = t[s],
            n = e[o]
          r >= n ? (s++, i.push(r)) : (o++, i.push(n))
        }
        return (
          s === t.length && i.push(...e.slice(o + 1)),
          o === e.length && i.push(...t.slice(s + 1)),
          i
        )
      }
      function $(t, e) {
        let i = 0
        for (const s of t) {
          const t = s.filter(isFinite)
          if (0 === t.length) continue
          const o = t[0] - (e - i)
          if (o < 0) return e - i
          if (o < t.length) return t[o]
          const r = t.length - 1
          i += t[0] - t[r] - r
        }
        return e - i
      }
      function q(t, e) {
        return e - t
      }
      function W(t, e, i, s) {
        return e === s[i - 1] || t.push(Number(e)), t
      }
      class H {
        constructor(t, e, i) {
          ;(this._container = null),
            (this._listContainer = null),
            (this._dragShield = null),
            (this._viewsList = []),
            (this._bids = {}),
            (this._asks = {}),
            (this._indexes = []),
            (this._repaintScheduled = !1),
            (this._currentVolumeMax = 0),
            (this._orders = {}),
            (this._positionIndex = Number.NaN),
            (this._positionQty = 0),
            (this._orderGhost = null),
            (this._totalVolumeBid = 0),
            (this._totalVolumeAsk = 0),
            (this._buyOrdersValue = 0),
            (this._sellOrdersValue = 0),
            (this._buyOrdersValueInactive = 0),
            (this._sellOrdersValueInactive = 0),
            (this._buyOrdersQuantity = 0),
            (this._sellOrdersQuantity = 0),
            (this._offscreenIndexLocation$ = new O.Subject()),
            (this._cellIndexesInAskZone = []),
            (this._cellIndexesInBidZone = []),
            (this._bestAskIndex = Number.POSITIVE_INFINITY),
            (this._bestBidIndex = Number.NEGATIVE_INFINITY),
            (this._worstBidIndex = Number.POSITIVE_INFINITY),
            (this._worstAskIndex = Number.NEGATIVE_INFINITY),
            (this._handlers = t || {}),
            (this._realtimeProvider = i),
            (this._showPricesWith = e),
            (this.autoCenterRequired = new l.WatchedValue(!1)),
            (this.height = 0),
            (this.topIndex = Number.NaN),
            (this._symbolData = null),
            (this.indexToPrice = () => Number.NaN),
            (this.priceToIndex = () => Number.NaN),
            (this._lastPriceIndex = Number.NaN),
            (this._viewAllocated = new Map()),
            (this._viewPool = null),
            (this._invalidatedAsk = {}),
            (this._invalidatedBid = {}),
            (this._invalidatedPriceHighlight = {}),
            (this._invalidatedOrders = {}),
            (this._dynamicModeState = !1),
            (this._numericFormatter = new B.NumericFormatter()),
            this._showPricesWith.zeroVolume.subscribe(
              this.centerOnLast.bind(this),
            ),
            this._showPricesWith.spread.subscribe(this.centerOnLast.bind(this)),
            this.reset()
        }
        reset() {
          ;(this.topIndex = Number.NaN),
            (this._symbolData = null),
            (this.indexToPrice = () => Number.NaN),
            (this.priceToIndex = () => Number.NaN),
            (this._lastPriceIndex = Number.NaN),
            this.resetData(),
            this.resetView(),
            this.resetOrders(),
            this.resetOrderGhost(),
            this.resetPosition(),
            this.autoCenterRequired.setValue(!1)
        }
        resetData() {
          if (
            ((this._bids = {}),
            (this._asks = {}),
            (this._totalVolumeBid = 0),
            (this._totalVolumeAsk = 0),
            this._recalcMaxVolume(),
            this._recalcBestWorstBid(),
            this._recalcBestWorstAsk(),
            this._viewAllocated)
          )
            for (const [t] of this._viewAllocated)
              (this._invalidatedAsk[t] = !0), (this._invalidatedBid[t] = !0)
          this._offscreenIndexLocation$.next(s.Inside), this.scheduleRepaint()
        }
        resetOrders() {
          if (this._orders)
            for (const t in this._orders)
              Object.hasOwn(this._orders, t) &&
                (this._invalidatedOrders[t] = !0)
          ;(this._orders = {}),
            (this._buyOrdersValue = 0),
            (this._sellOrdersValue = 0),
            (this._buyOrdersValueInactive = 0),
            (this._sellOrdersValueInactive = 0),
            (this._buyOrdersQuantity = 0),
            (this._sellOrdersQuantity = 0),
            this.scheduleRepaint()
        }
        resetPosition() {
          ;(this._invalidatedPriceHighlight[this._positionIndex] = !0),
            (this._positionIndex = Number.NaN),
            (this._positionQty = 0),
            this.scheduleRepaint()
        }
        resetView() {
          if (this._viewAllocated && this._viewPool)
            for (const [t] of this._viewAllocated) {
              const e = this._viewAllocated.get(t)
              e &&
                (e.element.remove(),
                this._viewPool.free(e),
                this._viewAllocated.delete(t))
            }
          this._listContainer &&
            ((this._viewsList.length = 0),
            (this._listContainer.innerHTML = '')),
            this.setDragShield(!1, !1),
            this.scheduleRepaint()
        }
        setSymbolInfo(t) {
          ;(this._symbolData = { ...t }),
            (this.indexToPrice = (0, T.makePriceIndexToPriceConverter)(
              t.minTick,
              t.variableMinTickData,
            )),
            (this.priceToIndex = (0, T.makePriceToPriceIndexConverter)(
              t.minTick,
              t.variableMinTickData,
            ))
        }
        setContainer(t) {
          if (this._container === t) return
          this._container &&
            (this.resetView(), (this._container.innerHTML = '')),
            (this._container = t),
            (this._viewPool = new M(this._handlers)),
            (this._viewAllocated = new Map())
          const e = (this._listContainer = document.createElement('div'))
          ;(e.className = N['tv-dom-widget-main__anchor']), t.append(e)
          const i = (this._dragShield = document.createElement('div'))
          ;(i.className = `${N['tv-dom-widget-main__drag-shield']} js-hidden`),
            t.append(i),
            (this._repaintScheduled = !1),
            this.scheduleRepaint()
        }
        setHeight(t) {
          t !== this.height &&
            ((this.height = t), this.checkAutoCenter(), this.scheduleRepaint())
        }
        shiftTopIndexRelativeToIndex(t, e) {
          this._setTopIndex(t + e)
        }
        setStopOrderMode(t) {
          let e = this.topIndex
          this._canIndexBeDisplayed(e) || (e = this.correctIndex(e, -1))
          const i = this.correctIndex(e, 1 - this.height)
          if (!isFinite(i)) return
          const s = this._viewAllocated
          for (const [, e] of s) e && e.setStopOrderMode(t)
        }
        correctIndex(t, e = 0) {
          const i = t + e
          if (!this._hasQuotes()) return i
          const s = this._showPricesWith.zeroVolume.value(),
            o = this._showPricesWith.spread.value()
          return s && o
            ? i
            : s && !o
              ? $([[this._bestAskIndex, this._bestBidIndex]], i)
              : !s && o
                ? $([this._cellIndexesInAskZone, this._cellIndexesInBidZone], i)
                : s || o
                  ? i
                  : $(
                      [
                        new Array().concat(
                          this._cellIndexesInAskZone,
                          this._cellIndexesInBidZone,
                        ),
                      ],
                      i,
                    )
        }
        centerOnLast() {
          this.autoCenterRequired.setValue(!1)
          const t = this._autoCenterTargetTopIndex()
          isFinite(t) && this._setTopIndex(t)
        }
        guessOrderType(t, e) {
          const i = this.priceToIndex(t)
          if (!isFinite(t)) return null
          if (1 !== e && -1 !== e) return null
          let s = this._bestAskIndex,
            o = this._bestBidIndex
          return (
            isFinite(s) || (s = o + 1),
            isFinite(o) || (o = s - 1),
            isFinite(s) || isFinite(o) || (s = o = this._lastPriceIndex),
            1 === e ? (i && i < s ? 1 : 3) : i && i > o ? 1 : 3
          )
        }
        updateData(t) {
          this._indexes.forEach((t) => {
            isFinite(this._asks[t]) || delete this._asks[t],
              isFinite(this._bids[t]) || delete this._bids[t]
          })
          let e = !1
          if (t.snapshot) {
            const t =
              0 === Object.keys(this._asks).length &&
              0 === Object.keys(this._bids).length
            ;(e =
              !this._showPricesWith.zeroVolume.value() &&
              !this._showPricesWith.spread.value() &&
              t),
              this.resetData()
          }
          let i = !1
          if (t.bids)
            for (let e = 0; e < t.bids.length; e++) {
              const s = (0, d.ensureDefined)(t.bids[e]),
                o = this.priceToIndex(s.price),
                r = s.volume,
                n = this._bids[o] || null
              n !== r &&
                ((i = !0),
                r > 0
                  ? ((this._totalVolumeBid += r - Number(n)),
                    (this._bids[o] = r))
                  : ((this._totalVolumeBid -= Number(n)), delete this._bids[o]),
                (this._invalidatedBid[o] = !0))
            }
          if (t.asks)
            for (let e = 0; e < t.asks.length; e++) {
              const s = (0, d.ensureDefined)(t.asks[e]),
                o = this.priceToIndex(s.price),
                r = s.volume,
                n = this._asks[o] || null
              n !== r &&
                ((i = !0),
                r > 0
                  ? ((this._totalVolumeAsk += r - Number(n)),
                    (this._asks[o] = r))
                  : ((this._totalVolumeAsk -= Number(n)), delete this._asks[o]),
                (this._invalidatedAsk[o] = !0))
            }
          if ((this._collectIndexes(), !this._hasDataInDOM())) {
            if (((i = !0), 0 !== t.bids.length)) {
              const e = this.priceToIndex(t.bids[0].price)
              this._bids[e] = Number.POSITIVE_INFINITY
            }
            if (0 !== t.asks.length) {
              const e = this.priceToIndex(t.asks[0].price)
              this._asks[e] = Number.POSITIVE_INFINITY
            }
            this._collectIndexes()
          }
          i && this._recalcDepthInfo(),
            this._recalcMaxVolume(),
            e ? this.centerOnLast() : this.checkAutoCenter(),
            this._dynamicModeState && this.centerOnLast(),
            this.scheduleRepaint()
        }
        totalVolumeBid() {
          return this._totalVolumeBid
        }
        totalVolumeAsk() {
          return this._totalVolumeAsk
        }
        buyOrdersValue() {
          return this._buyOrdersValue
        }
        sellOrdersValue() {
          return this._sellOrdersValue
        }
        buyInactiveOrdersValue() {
          return this._buyOrdersValueInactive
        }
        sellInactiveOrdersValue() {
          return this._sellOrdersValueInactive
        }
        buyOrdersQuantity() {
          return this._numericFormatter.format(this._buyOrdersQuantity)
        }
        sellOrdersQuantity() {
          return this._numericFormatter.format(this._sellOrdersQuantity)
        }
        updateOrders(t) {
          this.resetOrders()
          for (let e = 0; e < t.length; e++) {
            const i = t[e],
              s = 6 === i.status
            if (
              (1 === i.side
                ? ((this._buyOrdersValue += Number(s)),
                  (this._buyOrdersValueInactive += Number(!s)),
                  (this._buyOrdersQuantity += s ? i.qty : 0))
                : ((this._sellOrdersValue += Number(s)),
                  (this._sellOrdersValueInactive += Number(!s)),
                  (this._sellOrdersQuantity += s ? i.qty : 0)),
              i.stopPrice)
            ) {
              const t = this.priceToIndex(i.stopPrice)
              this._orders[t] || (this._orders[t] = []),
                this._orders[t].push({
                  order: i,
                  pricePropertyName: 'stopPrice',
                }),
                (this._invalidatedOrders[t] = !0)
            }
            if (void 0 !== i.limitPrice) {
              const t = this.priceToIndex(i.limitPrice)
              this._orders[t] || (this._orders[t] = []),
                this._orders[t].push({
                  order: i,
                  pricePropertyName: 'limitPrice',
                }),
                (this._invalidatedOrders[t] = !0)
            }
          }
          this._recalcDepthInfo(), this.scheduleRepaint()
        }
        updateLast(t) {
          const e = this.priceToIndex(t)
          e !== this._lastPriceIndex &&
            ((this._invalidatedPriceHighlight[this._lastPriceIndex] = !0),
            (this._invalidatedPriceHighlight[e] = !0),
            (this._lastPriceIndex = e),
            this.checkAutoCenter(),
            this.scheduleRepaint())
        }
        updatePosition(t) {
          if (void 0 === t || 0 === t.qty) return void this.resetPosition()
          const e = this.priceToIndex(t.avgPrice),
            i = Math.abs(t.qty) * (1 === t.side ? 1 : -1)
          ;(this._positionIndex === e && this._positionQty === i) ||
            ((this._invalidatedPriceHighlight[this._positionIndex] = !0),
            (this._invalidatedPriceHighlight[e] = !0),
            (this._positionIndex = e),
            (this._positionQty = i),
            this.scheduleRepaint())
        }
        resetOrderGhost() {
          this._orderGhost &&
            ((this._invalidatedOrders[this._orderGhost.index] = !0),
            (this._invalidatedOrders[this._orderGhost.originIndex] = !0),
            (this._orderGhost = null),
            this.scheduleRepaint())
        }
        setOrderGhost(t) {
          const { order: e, pricePropertyName: i, price: s } = t
          this.resetOrderGhost()
          const o = this.priceToIndex(s)
          isFinite(o) &&
            ((this._orderGhost = {
              ghost: !0,
              order: e,
              pricePropertyName: i,
              price: s,
              index: o,
              originIndex: this.priceToIndex(e[i]),
            }),
            (this._invalidatedOrders[o] = !0),
            this.scheduleRepaint())
        }
        setDragShield(t, e) {
          this._dragShield &&
            (this._dragShield.classList.toggle('js-hidden', !t),
            this._dragShield.classList.toggle(
              N['tv-dom-widget-main__drag-shield--order'],
              e,
            ))
        }
        scheduleRepaint() {
          this._repaintScheduled ||
            (this._symbolData &&
              (requestAnimationFrame(() => this.repaint()),
              (this._repaintScheduled = !0)))
        }
        formatVolume(t) {
          return null === this._symbolData
            ? String(t)
            : this._symbolData.volumeFormatter.format(t)
        }
        repaint() {
          if (((this._repaintScheduled = !1), !this._listContainer)) return
          if (null === this._viewPool) return
          const t = this.topIndex,
            e = this.correctIndex(t, 1 - this.height)
          if (isFinite(e)) {
            while (this._viewsList.length < this.height) {
              const t = this._viewPool.allocate()
              this._listContainer.append(t.element), this._viewsList.push(t)
            }
            while (this._viewsList.length > this.height) {
              const t = (0, d.ensureDefined)(this._viewsList.pop())
              t.element.remove(), this._viewPool.free(t)
            }
            ;(this._oldViewAllocated = this._viewAllocated),
              (this._viewAllocated = new Map())
            for (let e = 0; e < this._viewsList.length; e++) {
              const i = this.correctIndex(t, -e),
                s = this._viewsList[e]
              this._viewAllocated.set(i, s), this._updateRow(i)
            }
            this._updateOffscreenIndexLocation(this._lastPriceIndex, t, e)
            for (const t in this._invalidatedBid)
              Object.hasOwn(this._invalidatedBid, t) &&
                delete this._invalidatedBid[t]
            for (const t in this._invalidatedAsk)
              Object.hasOwn(this._invalidatedAsk, t) &&
                delete this._invalidatedAsk[t]
            for (const t in this._invalidatedPriceHighlight)
              Object.hasOwn(this._invalidatedPriceHighlight, t) &&
                delete this._invalidatedPriceHighlight[t]
            for (const t in this._invalidatedOrders)
              Object.hasOwn(this._invalidatedOrders, t) &&
                delete this._invalidatedOrders[t]
          }
        }
        typePrice(t) {
          return t >= this._bestAskIndex
            ? 'ask'
            : t <= this._bestBidIndex
              ? 'bid'
              : void 0
        }
        toggleDynamicModeState() {
          return (
            (this._dynamicModeState = !this._dynamicModeState),
            this._dynamicModeState
          )
        }
        getDynamicModeState() {
          return this._dynamicModeState
        }
        checkAutoCenter() {
          isFinite(this.topIndex) || this.centerOnLast()
          const t = this.topIndex,
            e = this.correctIndex(this.topIndex, 1 - this.height)
          let i
          i = isFinite(this._bestBidIndex)
            ? this._bestBidIndex
            : isFinite(this._bestAskIndex)
              ? this._bestAskIndex
              : isFinite(this._lastPriceIndex)
                ? this._lastPriceIndex
                : Number.NaN
          let s = Number.NaN
          isFinite(this._bestAskIndex)
            ? (s = this._bestAskIndex)
            : isFinite(this._bestBidIndex)
              ? (s = this._bestBidIndex)
              : isFinite(this._lastPriceIndex) && (i = this._lastPriceIndex)
          let o = !1
          ;(s + 3 > t || i - 3 < e) &&
            this.topIndex !== this._autoCenterTargetTopIndex() &&
            (o = !0),
            this.autoCenterRequired.setValue(o)
        }
        isSpread(t) {
          return this._bestAskIndex > t && t > this._bestBidIndex
        }
        getOffscreenIndexLocationObservable() {
          return this._offscreenIndexLocation$.asObservable()
        }
        _hasDataInDOM() {
          return 0 !== this._indexes.length
        }
        _updateOffscreenIndexLocation(t, e, i) {
          isFinite(this._lastPriceIndex) &&
            (t > e
              ? this._offscreenIndexLocation$.next(s.Higher)
              : t < i
                ? this._offscreenIndexLocation$.next(s.Lower)
                : this._offscreenIndexLocation$.next(s.Inside))
        }
        _hasQuotes() {
          return this._indexes.length > 1
        }
        _collectIndexes() {
          this._indexes = Object.keys(Object.assign({}, this._asks, this._bids))
        }
        _recalcDepthInfo() {
          const t = Object.keys(this._asks).reduce(W, []).sort(q),
            e = Object.keys(this._bids).reduce(W, []).sort(q),
            i = Object.keys(this._orders).reduce(W, []).sort(q)
          ;(this._worstAskIndex = t[0]),
            (this._bestAskIndex = t[t.length - 1]),
            (this._bestBidIndex = e[0]),
            (this._worstBidIndex = e[e.length - 1])
          const s = [],
            o = []
          for (const t of i)
            t <= this._worstAskIndex &&
              t >= this._bestAskIndex &&
              void 0 === this._asks[t] &&
              s.push(t),
              t <= this._bestBidIndex &&
                t >= this._worstBidIndex &&
                void 0 === this._bids[t] &&
                o.push(t)
          ;(this._cellIndexesInAskZone = A(t, s)),
            (this._cellIndexesInBidZone = A(e, o))
        }
        _updateRow(t) {
          var e
          if (!this._symbolData) return
          const s = this._oldViewAllocated,
            r = this._viewAllocated
          let n = r.get(t)
          this._viewPool && !n && ((n = this._viewPool.allocate()), r.set(t, n))
          const a = this._orderGhost
          if (s && s.get(t) !== r.get(t)) {
            const e = this.indexToPrice(t)
            n.updatePrice(e),
              n.updatePriceText(this._symbolData.priceFormatter.format(e))
          }
          n.paintPrice(this.typePrice(t)),
            this._asks[t] && this._asks[t] !== Number.POSITIVE_INFINITY
              ? n.updateAskVolume(this.formatVolume(this._asks[t]))
              : n.updateAskVolume(''),
            n.updateAskLabels(t < this._bestAskIndex),
            this._bids[t] && this._bids[t] !== Number.POSITIVE_INFINITY
              ? n.updateBidVolume(this.formatVolume(this._bids[t]))
              : n.updateBidVolume(''),
            n.setHigherThanBid(t > this._bestBidIndex),
            n.updateAskMeter(
              this._asks[t] === Number.POSITIVE_INFINITY
                ? 100
                : this._asks[t] / this._currentVolumeMax || 0,
            ),
            n.updateBidMeter(
              this._bids[t] === Number.POSITIVE_INFINITY
                ? 100
                : this._bids[t] / this._currentVolumeMax || 0,
            )
          const l = t === this._lastPriceIndex,
            d = t === this._positionIndex ? this._positionQty : 0
          n.updatePriceHighlight(l, d)
          let h,
            u,
            c = this._orders[t] || []
          null !== a &&
            (a.index === t &&
              (a.originIndex !== t ? (c = c.concat(a)) : (u = a.order.id)),
            (a.index !== t && a.originIndex !== t) || (h = a.order.side))
          const _ =
            null === (e = this._realtimeProvider.activeBroker()) || void 0 === e
              ? void 0
              : e.metainfo().configFlags
          for (let t = 0; t < c.length; t++) {
            const e = c[t],
              s = e.order,
              r = s.filledQty || 0
            switch (
              ((e.inactive =
                6 !== s.status ||
                (4 === s.type && 'limitPrice' === e.pricePropertyName)),
              (e.isModifiable =
                void 0 !== _ && (0, g.isModifyOrderSupported)(s, _)),
              (e.isMovable = void 0 !== _ && (0, g.isMoveOrderSupported)(s, _)),
              (e.isCancellable = !0),
              s.type)
            ) {
              case 2:
                ;(e.typeText = o.t(null, void 0, i(359758))),
                  (e.type = 'market')
                break
              case 1:
                ;(e.typeText = s.parentId
                  ? o.t(null, void 0, i(885242))
                  : o.t(null, void 0, i(398157))),
                  (e.type = 'limit')
                break
              case 3:
                ;(e.typeText = s.parentId
                  ? o.t(null, void 0, i(154852))
                  : o.t(null, { context: 'order' }, i(7122))),
                  (e.type = 'stop')
                break
              case 4:
                ;(e.typeText = o.t(null, void 0, i(900853))),
                  (e.type = 'stoplimit')
                break
              default:
                e.typeText = ''
            }
            ;(e.qty = this._symbolData.quantityFormatter.format(s.qty - r)),
              (e.buy = 1 === s.side),
              (e.noCollapse = s.side === h),
              (e.highlighted =
                null !== a &&
                void 0 !== u &&
                s.id === u &&
                a.pricePropertyName === e.pricePropertyName)
          }
          n.updateOrders(c)
        }
        _setTopIndex(t) {
          t !== this.topIndex && ((this.topIndex = t), this.checkAutoCenter()),
            this.scheduleRepaint()
        }
        _canIndexBeDisplayed(t) {
          const e = this._showPricesWith.zeroVolume.value(),
            i = this._showPricesWith.spread.value()
          if (e && !this.isSpread(t)) return !0
          if (i && this.isSpread(t)) return !0
          const s = t === this._lastPriceIndex,
            o = t === this._positionIndex,
            r = Object.hasOwn(this._bids, t) || Object.hasOwn(this._asks, t),
            n = t <= this._worstBidIndex || this._worstAskIndex <= t,
            a = this._orders[t] || [],
            l = this._orderGhost && this._orderGhost.index === t
          return o || s || l || n || r || 0 !== a.length
        }
        _getGapMiddleIndex() {
          let t = this._bestAskIndex,
            e = this._bestBidIndex
          return (
            isFinite(t) || (t = e),
            isFinite(e) || (e = t),
            Math.floor((e + t) / 2)
          )
        }
        _autoCenterTargetTopIndex() {
          const t = Math.floor(this.height / 2)
          return this._showPricesWith.zeroVolume.value() &&
            this._showPricesWith.spread.value()
            ? this._getCenterIndex() + t
            : this._getCorrectCenterIndex() + t
        }
        _getCorrectCenterIndex() {
          var t, e
          const i = this._getCenterIndex(),
            s = null !== (t = this._bestAskIndex) && void 0 !== t ? t : i,
            o = null !== (e = this._worstAskIndex) && void 0 !== e ? e : i
          let r = i
          if (!this._showPricesWith.zeroVolume.value()) {
            r =
              i +
              o -
              s -
              1 -
              (this._cellIndexesInAskZone.length - 1 >= 0
                ? this._cellIndexesInAskZone.length - 1
                : 0) +
              1
          }
          return this._showPricesWith.spread.value() || (r += s - i), r
        }
        _getCenterIndex() {
          const t = this._getGapMiddleIndex()
          return isFinite(t)
            ? t
            : isFinite(this._bestBidIndex)
              ? this._bestBidIndex
              : isFinite(this._bestAskIndex)
                ? this._bestAskIndex
                : isFinite(this._lastPriceIndex)
                  ? this._lastPriceIndex
                  : Number.NaN
        }
        _recalcMaxVolume() {
          let t = 0
          for (const e in this._asks)
            Object.hasOwn(this._asks, e) && (t = Math.max(this._asks[e], t))
          for (const e in this._bids)
            Object.hasOwn(this._bids, e) && (t = Math.max(this._bids[e], t))
          t !== this._currentVolumeMax && (this._currentVolumeMax = t)
        }
        _recalcBestWorstBid() {
          let t = Number.NEGATIVE_INFINITY,
            e = Number.POSITIVE_INFINITY
          for (const i in this._bids)
            Object.hasOwn(this._bids, i) &&
              (+i > t && (t = +i), +i < e && (e = +i))
          ;(this._bestBidIndex = t), (this._worstBidIndex = e)
        }
        _recalcBestWorstAsk() {
          let t = Number.POSITIVE_INFINITY,
            e = Number.NEGATIVE_INFINITY
          for (const i in this._asks)
            Object.hasOwn(this._asks, i) &&
              (+i < t && (t = +i), +i > e && (e = +i))
          ;(this._bestAskIndex = t), (this._worstAskIndex = e)
        }
      }
      var z = i(656846)
      class G {
        constructor(t, e) {
          ;(this._symbolData = null),
            (this._calculatePLUsingLast = !1),
            (this._hasLotSize = new l.WatchedValue(!1)),
            (this._plState = new O.Subject()),
            (this._positionState = new O.Subject()),
            (this._pipValueType = null),
            (this.changePLViewType = () => {
              switch (this._displayProfitState) {
                case 2:
                  this._displayProfitState = 1
                  break
                case 0:
                  this._displayProfitState = 2
                  break
                case 1:
                  this._displayProfitState = 0
              }
              h.setValue(
                y.settingsKeys.PROFIT_VIEW_TYPE,
                this._displayProfitState,
              ),
                this.updatePL()
            }),
            (this.compareQty = () => {
              var t
              const e = Math.abs(
                Number(
                  null === (t = this._position) || void 0 === t
                    ? void 0
                    : t.qty,
                ),
              )
              e > 0 && isFinite(e) && this.qty.setValue(e)
            }),
            (this._updatePipValueType = (t) => {
              this._pipValueType = t
            }),
            (this.plState$ = this._plState.asObservable()),
            (this.positionState$ = this._positionState.asObservable()),
            (this._handlers = t || {}),
            e.subscribe(this._updatePipValueType),
            (this._numericFormatter = new B.NumericFormatter()),
            (this._displayProfitState = h.getJSON(
              y.settingsKeys.PROFIT_VIEW_TYPE,
              2,
            )),
            this.reset(),
            (this._integerFormatter = new B.NumericFormatter(0)),
            (this._oneDecimalFormatter = new B.NumericFormatter(1)),
            (this.qty = new l.WatchedValue(1)),
            this.qty.subscribe((t) => this._handlers.qtyChange.call(null, t)),
            (this._qtyProperties = new l.WatchedValue({
              min: 1,
              step: 1,
              max: 1,
              format: null,
            }))
        }
        reset() {
          ;(this._position = void 0),
            (this._pl = void 0),
            (this._lastPrice = void 0),
            (this._bid = void 0),
            (this._ask = void 0),
            (this._symbolData = null),
            this._updatePositionState(null, null),
            this._updatePLState(null, null)
        }
        setBrokerConfigFlags(t) {
          this._calculatePLUsingLast = t.calculatePLUsingLast
        }
        setSymbolInfo(t) {
          const { qtyProperties: e } = t
          ;(this._symbolData = t),
            this._qtyProperties.setValue({
              min: e.min,
              step: e.step,
              uiStep: e.uiStep,
              max: e.max,
              format: this._numericFormatter,
            })
        }
        getQtyProperties() {
          return this._qtyProperties
        }
        updatePosition(t) {
          if (
            ((this._position = t),
            void 0 === this._position ||
              0 === this._position.qty ||
              null === this._symbolData)
          )
            return void this._updatePositionState(null, null)
          const { qty: e, avgPrice: i, side: s } = this._position,
            o = this._symbolData.priceFormatter.format(i),
            r = Math.abs(e),
            n = this._symbolData.volumeFormatter.format(r)
          this._updatePositionState(`${n} @ ${o}`, s)
        }
        updatePL(t) {
          if ((void 0 !== t && (this._pl = t), void 0 === this._position))
            return void this._updatePLState(null, null)
          const { side: e, avgPrice: i } = this._position,
            s = -1 === e,
            o = this._calculatePLUsingLast
              ? this._lastPrice
              : s
                ? this._ask
                : this._bid
          if (void 0 === o) {
            if (void 0 === this._pl || 2 !== this._displayProfitState)
              this._updatePLState(null, null)
            else {
              const t = this._pl >= 0 ? 1 : 2
              this._updatePLState(this._makePlText(), t)
            }
            return
          }
          const r = (o - i) * (s ? -1 : 1),
            n = r > 0 ? 1 : 2
          switch (this._displayProfitState) {
            case 0:
              const t = this._calculatePLPercentage(i, r)
              this._updatePLState(t, n)
              break
            case 1:
              const e = this._makePipsText(r)
              this._updatePLState(e, n)
              break
            case 2:
              this._updatePLState(this._makePlText(), n)
          }
        }
        updateLast(t, e, i) {
          ;(this._lastPrice = t),
            (this._bid = e),
            (this._ask = i),
            this.updatePL()
        }
        bid() {
          return this._bid
        }
        ask() {
          return this._ask
        }
        setHasLotSize(t) {
          this._hasLotSize.setValue(t)
        }
        hasLotSize() {
          return this._hasLotSize.readonly()
        }
        _calculatePLPercentage(t, e) {
          const i = e / t
          return isFinite(i) ? (100 * i).toFixed(2) + '%' : null
        }
        _makePipsText(t) {
          if (null === this._symbolData) return null
          const { pipSize: e, minTick: s } = this._symbolData,
            r =
              isFinite(e) && e !== s
                ? this._oneDecimalFormatter
                : this._integerFormatter,
            n = Number.parseFloat(r.format(t / (e || s)))
          if (!isFinite(n)) return null
          switch (this._pipValueType) {
            case z.PipValueType.Pips:
              return o.t(
                null,
                {
                  plural: '{pips} pips',
                  count: Math.abs(n),
                  replace: { pips: String(n) },
                },
                i(777772),
              )
            case z.PipValueType.Ticks:
              return o.t(
                null,
                {
                  plural: '{ticks} ticks',
                  count: Math.abs(n),
                  replace: { ticks: String(n) },
                },
                i(564225),
              )
            default:
              return null
          }
        }
        _makePlText() {
          var t
          if (void 0 === this._pl) return null
          const e = this._pl.toFixed(2)
          return void 0 !==
            (null === (t = this._symbolData) || void 0 === t
              ? void 0
              : t.positionCurrency)
            ? `${e} ${this._symbolData.positionCurrency}`
            : e
        }
        _updatePositionState(t, e) {
          this._positionState.next({ positionText: t, side: e })
        }
        _updatePLState(t, e) {
          this._plState.next({ plText: t, tradeDirection: e })
        }
      }
      class R {
        constructor(t, e, i) {
          ;(this._expiresAt = 0),
            (this._delay = t),
            (this._doneCb = e),
            (this._progressCb = i)
        }
        run() {
          if (this._timeoutId) return
          const t = Date.now ? Date.now() : +new Date()
          ;(this._expiresAt = t + this._delay),
            (this._timeoutId = window.setTimeout(() => {
              this.abort(), this._doneCb()
            }, this._delay)),
            this._trackProgressScheduled || this._trackProgress()
        }
        revert() {
          this._timeoutId &&
            (window.clearTimeout(this._timeoutId),
            (this._timeoutId = void 0),
            this.run())
        }
        abort() {
          this._timeoutId &&
            (window.clearTimeout(this._timeoutId),
            (this._timeoutId = void 0),
            (this._expiresAt = 0),
            this._progressCb && this._progressCb(0))
        }
        setWindow(t) {
          this._wnd = t
        }
        _trackProgress() {
          if (
            ((this._trackProgressScheduled = !1),
            !this._progressCb || !this._timeoutId)
          )
            return
          const t = Date.now ? Date.now() : +new Date()
          let e = 1 - (this._expiresAt - t) / this._delay
          ;(e = Math.max(Math.min(e, 1), 0)),
            this._progressCb(e),
            this._wnd && this._wnd.requestAnimationFrame
              ? this._wnd.requestAnimationFrame(() => {
                  this._trackProgress()
                })
              : window.setTimeout(() => {
                  this._trackProgress()
                }, 40),
            (this._trackProgressScheduled = !0)
        }
      }
      var U = i(466052)
      class j {
        constructor() {
          ;(this._customFieldsCount = new l.WatchedValue(0)),
            (this._currentValuesSummaryLine = new l.WatchedValue('')),
            (this._onCustomFieldsUpdate = new U.Delegate()),
            (this._selectedComboBoxValues = new Map()),
            (this._safeSelectedComboBoxValues = new Map()),
            (this._checkboxFieldsStates = new Map()),
            (this._safeCheckboxFieldsStates = new Map()),
            (this._comboBoxItems = new l.WatchedValue([])),
            (this._checkboxFields = new l.WatchedValue([])),
            (this._rewriteDisplayedSelectedItems = () => {
              const t = [
                  ...this._getSelectedComboBoxItemsNames(),
                  ...this._getCheckedCheckboxFieldsTitles(),
                ],
                e = this._getCurrentDurationName()
              void 0 !== e && t.push(e)
              const i = t.join(', ')
              this._currentValuesSummaryLine.setValue(i)
            }),
            (this._getSelectedComboBoxItemsNames = () => {
              const t = []
              for (const e of this._comboBoxItems.value()) {
                const i = this._selectedComboBoxValues.get(e.id)
                if (void 0 === i) continue
                const s = i.getValue(),
                  o = e.items.find((t) => t.value === s)
                t.push((0, d.ensureDefined)(o).text)
              }
              return t
            }),
            (this._recountCustomFields = () => {
              var t
              let e = void 0 !== this._currentDuration ? 1 : 0
              void 0 !==
                (null === (t = this._currentDuration) || void 0 === t
                  ? void 0
                  : t.datetime) && e++,
                this._customFieldsCount.setValue(
                  this._comboBoxItems.value().length +
                    this._checkboxFields.value().length +
                    e,
                )
            }),
            this._recountCustomFields()
        }
        setCustomFields(t) {
          const e = [],
            i = [],
            s = new Map(),
            o = new Map()
          t.forEach((t) => {
            if ('ComboBox' === t.inputType) {
              const i = this._selectedComboBoxValues.get(t.id)
              if (void 0 !== i)
                this._selectedComboBoxValues.delete(t.id),
                  s.set(t.id, i),
                  i.next(t.items[0].value)
              else {
                const e = new p.BehaviorSubject(t.items[0].value)
                s.set(t.id, e), e.subscribe(this._rewriteDisplayedSelectedItems)
              }
              e.push(t)
            }
            if ('Checkbox' === t.inputType) {
              const e = this._checkboxFieldsStates.get(t.id)
              if (void 0 !== e)
                this._checkboxFieldsStates.delete(t.id),
                  o.set(t.id, e),
                  e.next(t.value)
              else {
                const e = new p.BehaviorSubject(t.value)
                o.set(t.id, e), e.subscribe(this._rewriteDisplayedSelectedItems)
              }
              i.push(t)
            }
          }),
            this._selectedComboBoxValues.forEach((t) =>
              null == t ? void 0 : t.unsubscribe(),
            ),
            (this._selectedComboBoxValues = s),
            this._safeSelectedComboBoxValues.clear(),
            this._selectedComboBoxValues.forEach((t, e) => {
              this._safeSelectedComboBoxValues.set(e, {
                value$: t.asObservable(),
                getValue: t.getValue.bind(t),
                setValue: t.next.bind(t),
              })
            }),
            this._checkboxFieldsStates.forEach((t) => t.unsubscribe()),
            (this._checkboxFieldsStates = o),
            this._safeCheckboxFieldsStates.clear(),
            this._checkboxFieldsStates.forEach((t, e) => {
              this._safeCheckboxFieldsStates.set(e, {
                value$: t.asObservable(),
                getValue: t.getValue.bind(t),
                setValue: t.next.bind(t),
              })
            }),
            this._comboBoxItems.setValue(e),
            this._checkboxFields.setValue(i),
            this._rewriteDisplayedSelectedItems(),
            this._recountCustomFields(),
            this._onCustomFieldsUpdate.fire()
        }
        comboBoxItems() {
          return this._comboBoxItems.readonly()
        }
        getSelectedComboBoxValues() {
          return this._safeSelectedComboBoxValues
        }
        checkboxFields() {
          return this._checkboxFields.readonly()
        }
        getCheckboxFieldsStates() {
          return this._safeCheckboxFieldsStates
        }
        getCustomFieldsCount() {
          return this._customFieldsCount.value()
        }
        currentValuesSummaryLine() {
          return this._currentValuesSummaryLine.readonly()
        }
        setDurationsInfo(t, e) {
          void 0 !== e && (this._durationsMetaInfo = e),
            (this._currentDuration = t),
            this._rewriteDisplayedSelectedItems(),
            this._recountCustomFields()
        }
        _getCheckedCheckboxFieldsTitles() {
          const t = []
          for (const e of this._checkboxFields.value()) {
            const i = this._checkboxFieldsStates.get(e.id)
            if (void 0 === i) continue
            i.getValue() && t.push(e.title)
          }
          return t
        }
        _getCurrentDurationName() {
          var t, e
          const i =
              null === (t = this._currentDuration) || void 0 === t
                ? void 0
                : t.type,
            s =
              null === (e = this._durationsMetaInfo) || void 0 === e
                ? void 0
                : e.find((t) => t.value === i)
          return null == s ? void 0 : s.name
        }
      }
      var Q = i(661851),
        Z = i(853177),
        K = i(586639),
        Y = i(72571),
        J = i(497754),
        X = i(901317),
        tt = i(297265),
        et = i(587374),
        it = i(165962),
        st = i(657947)
      function ot(t) {
        const {
          currentDuration: e,
          durationMetaInfoList: i,
          onDurationChanged: s,
          showErrorMessages: o,
          revertInvalidData: r,
        } = t
        return n.createElement(st.DurationControl, {
          currentDuration: e,
          durationMetaInfoList: i,
          onDurationChanged: s,
          showErrorMessages: o,
          revertInvalidData: r,
        })
      }
      var rt = i(236128),
        nt = i(488263),
        at = i(611902)
      function lt(t) {
        const e = t.domDetails,
          [s, r] = (0, X.useWatchedValue)(t.openState),
          a = (0, tt.useWatchedValueReadonly)({
            watchedValue: t.currentDuration,
          }),
          l = (0, tt.useWatchedValueReadonly)({
            watchedValue: t.durationMetaInfoList,
          }),
          h = (0, tt.useWatchedValueReadonly)({
            watchedValue: e.currentValuesSummaryLine(),
          }),
          u = (0, tt.useWatchedValueReadonly)({
            watchedValue: e.comboBoxItems(),
          }),
          c = (0, tt.useWatchedValueReadonly)({
            watchedValue: e.checkboxFields(),
          }),
          _ = t.onDurationChanged,
          m = e.getSelectedComboBoxValues(),
          p = e.getCheckboxFieldsStates()
        return n.createElement(
          n.Fragment,
          null,
          n.createElement(
            'div',
            { className: rt.headerWrapper },
            n.createElement(
              'div',
              { className: rt.header, onClick: () => r(!s) },
              n.createElement(
                'div',
                { className: J(rt.textBlock, rt.summaryLine) },
                n.createElement(
                  'span',
                  { className: rt.upperCase },
                  o.t(null, void 0, i(557027)) + ': ',
                ),
                h,
              ),
              n.createElement(
                'div',
                { className: rt.arrow },
                n.createElement(Y.Icon, { icon: s ? nt : at }),
              ),
            ),
          ),
          s &&
            n.createElement(
              n.Fragment,
              null,
              n.createElement(
                'div',
                null,
                u.length > 0 &&
                  m.size > 0 &&
                  n.createElement(
                    n.Fragment,
                    null,
                    u.map((t) => {
                      const e = (0, d.ensureDefined)(m.get(t.id))
                      return n.createElement(
                        'div',
                        { key: t.id, className: rt.customField },
                        n.createElement(et.CustomComboboxContainer, {
                          title: t.title,
                          items: t.items,
                          selectedItem$: e.value$,
                          getSelectedItem: e.getValue,
                          setSelectedItem: e.setValue,
                          forceUserToSelectValue: !1,
                          alwaysShowAttachedErrors$: (0, K.of)(!1),
                        }),
                      )
                    }),
                  ),
                c.length > 0 &&
                  p.size > 0 &&
                  n.createElement(
                    n.Fragment,
                    null,
                    c.map((t) => {
                      const e = (0, d.ensureDefined)(p.get(t.id))
                      return n.createElement(
                        'div',
                        { key: t.id, className: rt.customField },
                        n.createElement(it.CheckboxCustomField, {
                          title: t.title,
                          help: t.help,
                          checked$: e.value$,
                          getChecked: e.getValue,
                          setChecked: e.setValue,
                        }),
                      )
                    }),
                  ),
                n.createElement(
                  'div',
                  { className: rt.duration },
                  void 0 !== a &&
                    void 0 !== l &&
                    n.createElement(ot, {
                      currentDuration: a,
                      durationMetaInfoList: l,
                      onDurationChanged: _,
                      showErrorMessages: !0,
                      revertInvalidData: !0,
                    }),
                ),
              ),
            ),
        )
      }
      var dt = i(587125),
        ht = i(99708),
        ut = i(663237)
      function ct(t) {
        const { calcData: e } = t,
          [s, r] = (0, n.useState)(!1),
          [a, l] = (0, n.useState)(),
          [d, h] = (0, n.useState)(e.qty.value()),
          [u, c] = (0, X.useWatchedValue)(e.qty),
          _ = (0, tt.useWatchedValueReadonly)({
            watchedValue: e.getQtyProperties(),
          }),
          m = (0, tt.useWatchedValueReadonly)({ watchedValue: e.hasLotSize() })
            ? o.t(null, void 0, i(357653))
            : o.t(null, void 0, i(125933))
        return (
          (0, n.useEffect)(() => {
            if (u === d) return
            const { res: t, msg: e } = (0, ht.checkQtyError)(_, u, !0)
            t || h(u), r(t), l(e)
          }, [u, _, d]),
          n.createElement(
            'div',
            { className: ut.wrapper },
            n.createElement('span', { className: ut.title }, m),
            n.createElement(dt.NumberInput, {
              alwaysUpdateValueFromProps: !0,
              mode: 'float',
              value: u,
              onValueChange: (t) => c(t),
              errorHandler: (t) => r(t),
              errorMessage: a,
              error: s,
              onBlur: () => {
                if (d === u) return
                c(d)
              },
              min: _.min,
              max: _.max,
              step: _.step,
              uiStep: _.uiStep,
            }),
          )
        )
      }
      var _t = i(725784),
        mt = i(509959)
      const pt = (0, _t.hotKeySerialize)({
          keys: ['Shift', 'B'],
          text: '{0} + {1}',
        }),
        vt = (0, _t.hotKeySerialize)({
          keys: ['Shift', 'S'],
          text: '{0} + {1}',
        }),
        gt = o.t(null, void 0, i(102846)),
        bt = o.t(null, void 0, i(545322))
      function wt(t) {
        const { uiPlaceOrder: e } = t
        return n.createElement(
          'div',
          { className: J(mt.row, mt.wrapper, mt.marketBlock) },
          n.createElement(
            'button',
            {
              className: J(mt.buttonBuy, 'apply-common-tooltip'),
              'data-tooltip-hotkey': pt,
              onClick: (t) => {
                t.preventDefault(), e({ type: 2, side: 1 })
              },
            },
            gt,
          ),
          n.createElement(
            'button',
            {
              className: J(mt.buttonSell, 'apply-common-tooltip'),
              'data-tooltip-hotkey': vt,
              onClick: (t) => {
                t.preventDefault(), e({ type: 2, side: -1 })
              },
            },
            bt,
          ),
        )
      }
      function yt(t, e) {
        return e ? { title: t } : { 'data-tooltip': t }
      }
      var ft = i(515099)
      const kt = { plText: null, tradeDirection: 1 },
        xt = { positionText: null, side: 1 },
        St = o.t(null, void 0, i(381617)),
        Pt = o.t(null, void 0, i(110649))
      function It(t) {
        const { plText: e, tradeDirection: i } = (0, Q.useObservable)(
            t.plState,
            kt,
          ),
          { positionText: s, side: o } = (0, Q.useObservable)(
            t.positionState,
            xt,
          ),
          r = null !== s,
          a = J(
            ft.button,
            ft.pl,
            r && (1 === i ? ft.profit : ft.loss),
            'apply-common-tooltip',
          ),
          l = J(
            ft.button,
            ft.position,
            r && (1 === o ? ft.buy : ft.sell),
            'apply-common-tooltip',
          )
        return n.createElement(
          'div',
          { className: ft.wrapper },
          n.createElement(
            'button',
            {
              className: l,
              disabled: !r,
              onClick: t.compareQty,
              ...yt(St, !r),
            },
            null != s ? s : '',
          ),
          n.createElement(
            'button',
            {
              className: a,
              disabled: !r,
              onClick: t.changePLViewType,
              ...yt(Pt, !r),
            },
            null != e ? e : '',
          ),
        )
      }
      const Tt = o.t(null, void 0, i(323288)),
        Ot = o.t(null, void 0, i(963867)),
        Bt = o.t(null, void 0, i(224186)),
        Vt = o.t(null, void 0, i(975336)),
        Ct = o.t(null, void 0, i(987411)),
        Nt = o.t(null, void 0, i(843065))
      function Lt(t) {
        const e =
            t.isPositionBlocked ||
            !t.isTradable ||
            !t.hasPosition ||
            !t.hasFlatten,
          i = !t.isTradable || !(t.hasBuyOrders || t.hasSellOrders),
          s =
            t.isPositionBlocked ||
            !t.isTradable ||
            !t.hasPosition ||
            !t.hasReverse
        return n.createElement(
          'div',
          { className: J(mt.row, mt.wrapper, mt.tradingActionBlock) },
          n.createElement(
            'button',
            {
              className: J(mt.buttonOrdinary, 'apply-common-tooltip'),
              disabled: e,
              onClick: (e) => {
                e.preventDefault(), t.uiClosePosition()
              },
              ...yt(Ct, e),
            },
            Ot,
          ),
          n.createElement(
            'button',
            {
              className: J(mt.buttonOrdinary, 'apply-common-tooltip'),
              title: Vt,
              disabled: i,
              onClick: (e) => {
                e.preventDefault(), t.uiCancelAllOrders()
              },
              ...yt(Vt, i),
            },
            Tt,
          ),
          n.createElement(
            'button',
            {
              className: J(mt.buttonOrdinary, 'apply-common-tooltip'),
              title: Nt,
              disabled: s,
              onClick: (e) => {
                e.preventDefault(), t.uiReversePosition()
              },
              ...yt(Nt, s),
            },
            Bt,
          ),
        )
      }
      var Mt = i(309268)
      function Dt(t) {
        const {
            uiState$: e,
            warningMessage$: i,
            domDetailsDropdownProps: s,
            domNumberContainerProps: o,
            domMarketActionBlockProps: r,
            tradingActionBlockControllers: a,
            domCalcBlockProps: l,
          } = t,
          d = (0, Q.useObservable)(e, {
            isTradable: !1,
            isPositionBlocked: !1,
            hasPosition: !1,
            hasBuyOrders: !1,
            hasSellOrders: !1,
            qty: 1,
            gtcOrder: !1,
            hasFlatten: !1,
            hasReverse: !1,
          }),
          h = s.domDetails.getCustomFieldsCount(),
          u = []
        return (
          d.isTradable &&
            u.push({
              id: 'symbol-specific-warning',
              warningMessageSource: d.symbolSpecificWarningMessage,
            }),
          n.createElement(
            'div',
            { className: Mt.container },
            n.createElement(It, { ...l }),
            n.createElement(Lt, { ...a, ...d }),
            n.createElement(ct, { ...o }),
            n.createElement(wt, { ...r }),
            d.isTradable && 0 !== h && n.createElement(lt, { ...s }),
            n.createElement(Z.TradingPanelWarningInformersContainer, {
              warningInformersItems: u,
            }),
          )
        )
      }
      var Et = i(216258),
        Ft = i(717408),
        At = (i(85214), i(41142)),
        $t = i(11728),
        qt = i(781957),
        Wt = i(943145)
      function Ht(t, e) {
        return `${y.settingsKeys.DOM_DURATION}${t}.${e}`
      }
      const zt = { 1: 'LIMIT', 2: 'MARKET', 3: 'STOP', 4: 'STOPLIMIT' }
      function Gt(t) {
        var e, i
        return t instanceof MouseEvent
          ? t.pageY
          : null !==
                (i =
                  null === (e = t.touches[0]) || void 0 === e
                    ? void 0
                    : e.pageY) && void 0 !== i
            ? i
            : 0
      }
      class Rt {
        constructor(t, e, s, r, n, a) {
          var d
          ;(this.delayedData = new l.WatchedValue(!1)),
            (this.isBats = new l.WatchedValue(!1)),
            (this._container = null),
            (this._warning = null),
            (this._mainBlock = null),
            (this._svgTimerPath = null),
            (this._totalVolumeBidTextNode = null),
            (this._totalVolumeAskTextNode = null),
            (this._countVolumeBuyTextNode = null),
            (this._countVolumeSellTextNode = null),
            (this._countVolumeBid = null),
            (this._countVolumeAsk = null),
            (this._subscription = null),
            (this._noDataTimeout = null),
            (this._actionMarketButtons = null),
            (this._actionPositionButtons = null),
            (this._navButtons = null),
            (this._currentDuration = new l.WatchedValue()),
            (this._durationMetaInfoList = new l.WatchedValue()),
            (this._viewTotalVolumeScheduled = !1),
            (this._detailsOpenState = new l.WatchedValue(!1)),
            (this._csxAllTitle = o.t(null, void 0, i(975336))),
            (this._flattenTitle = o.t(null, void 0, i(987411))),
            (this._reverseTitle = o.t(null, void 0, i(843065))),
            (this._handleModKeyStateChange = (t) => {
              const e = (0, u.modifiersFromEvent)(t) === u.Modifiers.Mod
              this._content.setStopOrderMode(e)
            }),
            (this._onDurationChanged = (t) => {
              this._currentDuration.setValue(t),
                this._domDetails.setDurationsInfo(t)
              const e = this._realtimeProvider.activeBroker()
              if (null === e) return
              const i = Ht(e.metainfo().id, this._tradingLinking.value().symbol)
              h.setValue(i, t.type)
            }),
            (this._onSuggestedQtyChange = (t) => {
              this._calcData.qty.setValue(t), this._mergeUiState({ qty: t })
            }),
            (this._headerState = a),
            (this._visible = e),
            (this._symbolData = null),
            (this._supportedOrderTypes = [2]),
            (this._domDetails = new j()),
            (this._trading = s),
            (this._qtySuggester = r),
            (this._tradingLinking = n),
            (this._realtimeProvider = this._trading.realtimeProvider())
          const c = this._handlers(),
            _ = {
              zeroVolume: this._trading.showPricesWith().zeroVolume.readonly(),
              spread: this._trading.showPricesWith().spread.readonly(),
            }
          ;(this._content = new H(c, _, this._realtimeProvider)),
            (this._calcData = new G(c, s.pipValueType())),
            (this._uiState = {
              isTradable: !1,
              isPositionBlocked: !1,
              hasPosition: !1,
              hasBuyOrders: !1,
              hasSellOrders: !1,
              qty: 1,
              gtcOrder: !1,
              hasFlatten: !1,
              hasReverse: !1,
            }),
            (this._upperBlockResizeObserver = new m.default((t) => {
              for (const e of t) {
                const t = Math.ceil(e.target.clientHeight / 20)
                this._content.setHeight(t)
              }
            })),
            (this._uiState$ = new p.BehaviorSubject(this._uiState)),
            (this._domSymbolInfo$ = new p.BehaviorSubject({
              symbol: n.value().symbol,
              brokerName:
                null === (d = this._realtimeProvider.activeBroker()) ||
                void 0 === d
                  ? void 0
                  : d.metainfo().title,
            })),
            (this.domSymbolInfo$ = this._domSymbolInfo$.asObservable()),
            (this.isTradable$ = this._uiState$.pipe(
              (0, v.map)(({ isTradable: t }) => t),
            )),
            (this._timerLockState = {}),
            (this._timer = new R(
              2e3,
              () => {
                this._content.centerOnLast()
              },
              (t) => {
                this._updateTimerUi(t)
              },
            )),
            this._content.autoCenterRequired.subscribe((t) => {
              this._mergeTimerLockState({ autoCenterRequired: t })
            }),
            t.subscribe((t) => this._recreateLayout(t), { callWithLast: !0 }),
            this._tradingLinking
              .valueObservable()
              .subscribe(({ warning: t }) => {
                var e
                this._onStateChange(),
                  this._updateDetails(),
                  null === (e = this._warningMessage$) ||
                    void 0 === e ||
                    e.next(t)
              }),
            this._realtimeProvider.onStatusChanged.subscribe(null, () => {
              this._onStateChange(), this._updateDetails()
            }),
            e.subscribe(() => {
              var t
              this._onStateChange(),
                null === (t = this._warningMessage$) ||
                  void 0 === t ||
                  t.next(this._warningMessage$.getValue())
            }),
            this._onStateChange(),
            this._updateDetails()
        }
        uiScroll(t) {
          this._content.getDynamicModeState() ||
            (this._content.shiftTopIndexRelativeToIndex(
              this._content.topIndex,
              0 | t,
            ),
            this._timer.revert())
        }
        uiCenter() {
          this._content.centerOnLast(), this._trackEvent('Center')
        }
        uiCancelOrder(t) {
          this._uiState.isTradable &&
            null !== t &&
            ((0, d.ensureNotNull)(
              this._trading.brokerCommandsUI() || null,
            ).cancelOrder(t),
            this._trackEvent('Cancel Order'))
        }
        uiModifyOrder(t, e = null) {
          if (
            !t ||
            !this._uiState.isTradable ||
            void 0 === this._configFlags ||
            !(0, g.isModifyOrderSupported)(t, this._configFlags)
          )
            return Promise.resolve()
          let i = !0
          null === e && ((e = {}), (i = !1))
          const s = (0, d.ensureNotNull)(
            this._trading.brokerCommandsUI() || null,
          ).modifyOrder({ ...t, ...e }, i, void 0, !0)
          return (
            this._lockTimerUntilSettled(s),
            this._trackEvent('Modify Order'),
            Promise.resolve()
          )
        }
        uiPlaceOrder({
          side: t,
          type: e,
          price: i = Number.NaN,
          altPrice: s = Number.NaN,
        }) {
          var o
          if (!this._realtimeProvider.activeBroker())
            return void this._trading.toggleTradingWidget().then(() => {
              this._trading.onNeedSelectBroker.fire()
            })
          if (
            !(null === (o = this._subscription) || void 0 === o
              ? void 0
              : o.broker)
          )
            return void this._trading.toggleTradingWidget()
          if (2 !== e && !isFinite(i)) return
          null === e && (e = this._content.guessOrderType(i, t))
          let r = !0
          if (
            (null === e && ((r = !1), (e = 1)), !this._isOrderTypeSupported(e))
          )
            return
          const n = {}
          for (const [t, e] of this._domDetails.getSelectedComboBoxValues())
            n[t] = e.getValue()
          for (const [t, e] of this._domDetails.getCheckboxFieldsStates())
            n[t] = e.getValue()
          const a = this._calcData.ask(),
            l = this._calcData.bid(),
            h = 1 === t ? a : l,
            u = {
              symbol: this._tradingLinking.value().symbol,
              qty: this._calcData.qty.value(),
              side: t,
              type: e,
              seenPrice: null != h ? h : null,
              duration: this._currentDuration.value(),
              customFields: n,
            }
          void 0 !== a &&
            void 0 !== l &&
            (u.currentQuotes = { ask: a, bid: l }),
            3 === u.type && (u.stopPrice = i),
            1 === u.type && (u.limitPrice = i),
            4 === u.type &&
              ((u.stopPrice = i), isFinite(s) ? (u.limitPrice = s) : (r = !1)),
            this._lockTimerUntilSettled(
              (0, d.ensureNotNull)(
                this._trading.brokerCommandsUI() || null,
              ).placeOrder(u, r, !0),
            ),
            this._trackEvent('Place Order', zt[e])
        }
        uiCancelAllOrders(t) {
          const e = this._uiState
          if (
            !e.isTradable ||
            (!e.hasBuyOrders && !e.hasSellOrders) ||
            (1 === t && !e.hasBuyOrders) ||
            (-1 === t && !e.hasSellOrders)
          )
            return Promise.resolve()
          const i = (0, d.ensureNotNull)(
            this._trading.brokerCommandsUI() || null,
          ).cancelOrders(this._tradingLinking.value().symbol, t)
          return (
            this._lockTimerUntilSettled(i),
            t
              ? this._trackEvent(
                  'Cancel All ' + (1 === t ? 'Buy' : 'Sell') + ' Orders',
                )
              : this._trackEvent('Cancel All Orders'),
            Promise.resolve()
          )
        }
        async uiClosePosition() {
          if (
            this._uiState.isPositionBlocked ||
            !this._uiState.isTradable ||
            !this._uiState.hasPosition ||
            !this._uiState.hasFlatten
          )
            return
          const t = this._realtimeProvider.activeBroker()
          if (!t) return
          this._mergeUiState({ isPositionBlocked: !0 })
          const e = t
            .positions(this._tradingLinking.value().symbol)
            .then((t) => {
              for (const e of t)
                if (0 !== e.qty)
                  return (0, d.ensureNotNull)(
                    this._trading.brokerCommandsUI(),
                  ).closePosition(e.id)
              return Promise.resolve(!1)
            })
            .finally(() => this._mergeUiState({ isPositionBlocked: !1 }))
          this._lockTimerUntilSettled(e), this._trackEvent('Close Position')
        }
        async uiReversePosition() {
          if (
            this._uiState.isPositionBlocked ||
            !this._uiState.isTradable ||
            !this._uiState.hasPosition ||
            !this._uiState.hasReverse
          )
            return
          const t = this._realtimeProvider.activeBroker()
          if (!t) return
          this._mergeUiState({ isPositionBlocked: !0 })
          const e = t
            .positions(this._tradingLinking.value().symbol)
            .then((t) => {
              for (const e of t)
                if (0 !== e.qty)
                  return (0, d.ensureNotNull)(
                    this._trading.brokerCommandsUI(),
                  ).reversePosition(e.id)
              return Promise.resolve(!1)
            })
            .finally(() => this._mergeUiState({ isPositionBlocked: !1 }))
          this._lockTimerUntilSettled(e), this._trackEvent('Reverse')
        }
        uiOrderMousedown(t, e, i) {
          if (
            1 !== t.buttons ||
            null === e ||
            null === this._mainBlock ||
            null === this._subscription
          )
            return
          this.uiStopOrderDrag()
          const s = e[i],
            o = this._subscription
          let r = Number.NaN
          ;(o.orderMouseRoot = document.documentElement),
            (o.orderMousemoveHandler = (t) => {
              if (
                (t.preventDefault(),
                1 !== (t.buttons || t.which) ||
                  void 0 === this._configFlags ||
                  !(0, g.isMoveOrderSupported)(e, this._configFlags))
              )
                return void this.uiStopOrderDrag()
              const s = (0, d.ensureNotNull)(
                  this._mainBlock,
                ).getBoundingClientRect().y,
                o = Gt(t) - s,
                n = -Math.floor(o / 20),
                a = this._content.correctIndex(this._content.topIndex, n)
              ;(r = this._content.indexToPrice(a)),
                this._content.setDragShield(!0, !0),
                this._mergeTimerLockState({ drag: !0 }),
                this._content.setOrderGhost({
                  order: e,
                  pricePropertyName: i,
                  price: r,
                })
            }),
            (o.orderMouseupHandler = () => {
              this.uiStopOrderDrag()
              this._realtimeProvider.activeBroker() &&
                isFinite(r) &&
                r !== s &&
                (this._content.setOrderGhost({
                  order: e,
                  pricePropertyName: i,
                  price: r,
                }),
                this._content.setDragShield(!0, !0),
                this._trackEvent('Move Order'),
                this.uiModifyOrder(e, { [i]: r })
                  .then(() => this.uiStopOrderDrag())
                  .catch(() => this.uiStopOrderDrag()))
            }),
            (o.orderMousedownHandler = () => {
              this.uiStopOrderDrag()
            }),
            o.orderMouseRoot.addEventListener(
              'mousemove',
              o.orderMousemoveHandler,
            ),
            o.orderMouseRoot.addEventListener('mouseup', o.orderMouseupHandler),
            setTimeout(() => {
              const { orderMouseRoot: t, orderMousedownHandler: e } = o
              t && e && t.addEventListener('mousedown', e)
            }, 0)
        }
        uiStopOrderDrag() {
          if (
            (this._content.setDragShield(!1, !1),
            this._content.resetOrderGhost(),
            this._mergeTimerLockState({ drag: !1 }),
            !this._subscription)
          )
            return
          const {
            orderMousemoveHandler: t,
            orderMouseupHandler: e,
            orderMousedownHandler: i,
            orderMouseRoot: s,
          } = this._subscription
          delete this._subscription.orderMousemoveHandler,
            delete this._subscription.orderMouseupHandler,
            delete this._subscription.orderMousedownHandler,
            delete this._subscription.orderMouseRoot,
            s && t && s.removeEventListener('mousemove', t),
            s && e && s.removeEventListener('mouseup', e),
            s && i && s.removeEventListener('mousedown', i)
        }
        uiContextMenu(t, e, s) {
          if (!this._uiState.isTradable) return
          if (1 !== e && -1 !== e) return
          const r = this._uiState.qty || Number.NaN,
            n = this._tradingLinking.value().symbol.split(':')[1],
            a = (0, x.abbreviatedNumber)(r),
            l = [],
            d =
              (this._symbolData && this._symbolData.priceFormatter) ||
              new f.PriceFormatter()
          if ((this._trackEvent('Context Menu'), isFinite(s))) {
            const t = d.format(s)
            if (this._isOrderTypeSupported(3)) {
              const r = { stopPrice: t, qty: a, symbol: n }
              let d = ''
              d =
                1 === e
                  ? o.t(null, { replace: r }, i(812458))
                  : o.t(null, { replace: r }, i(793711))
              const h = new S.Action({
                actionId: 'Trading.DOMPlaceStopOrder',
                options: {
                  label: d,
                  onExecute: () => {
                    this.uiPlaceOrder({ side: e, price: s, type: 3 })
                  },
                },
              })
              l.push(h)
            }
            if (this._isOrderTypeSupported(1)) {
              const r = { limitPrice: t, qty: a, symbol: n }
              let d = ''
              d =
                1 === e
                  ? o.t(null, { replace: r }, i(222821))
                  : o.t(null, { replace: r }, i(596283))
              const h = new S.Action({
                actionId: 'Trading.DOMPlaceLimitOrder',
                options: {
                  label: d,
                  onExecute: () => {
                    this.uiPlaceOrder({ side: e, price: s, type: 1 })
                  },
                },
              })
              l.push(h)
            }
            if (this._symbolData && this._isOrderTypeSupported(4)) {
              const r = (0, T.getMinTick)({
                  minTick: this._symbolData.minTick,
                  price: s,
                  variableMinTickData: this._symbolData.variableMinTickData,
                }),
                h = new (_())(r)
                  .mul(1 === e ? 1 : -1)
                  .plus(s)
                  .toNumber(),
                u = { stopPrice: t, limitPrice: d.format(h), qty: a, symbol: n }
              let c = ''
              c =
                1 === e
                  ? o.t(null, { replace: u }, i(832023))
                  : o.t(null, { replace: u }, i(81078))
              const m = new S.Action({
                actionId: 'Trading.DOMPlaceStopLimitOrder',
                options: {
                  label: c,
                  onExecute: () => {
                    this.uiPlaceOrder({
                      side: e,
                      price: s,
                      altPrice: h,
                      type: 4,
                    })
                  },
                },
              })
              l.push(m)
            }
          }
          if (this._isOrderTypeSupported(2)) {
            const t = { qty: a, symbol: n }
            let s = ''
            s =
              1 === e
                ? o.t(null, { replace: t }, i(503491))
                : o.t(null, { replace: t }, i(331840))
            const r = new S.Action({
              actionId: 'Trading.DOMPlaceMarketOrder',
              options: {
                label: s,
                onExecute: () => {
                  this.uiPlaceOrder({ side: e, type: 2 })
                },
              },
            })
            l.push(r)
          }
          l.length &&
            P.ContextMenuManager.showMenu(l, t, void 0, {
              menuName: 'DOMWidgetContextMenu',
            })
        }
        _recreateLayout(t) {
          null !== this._container && (this._container.innerHTML = '')
          const e = document.createElement('div'),
            o = document.createElement('div')
          this._upperBlockResizeObserver.disconnect(),
            this._upperBlockResizeObserver.observe(e),
            e.classList.add(At.upperBlock),
            o.classList.add(At.bottomBlock),
            (this._container = t)
          const r = ((t) => {
            const e = document.createElement('span'),
              o = document.createElement('span')
            return (
              (e.className = `${N['tv-dom-widget-main__offscreen-arrow']} ${N['tv-dom-widget-main__offscreen-arrow--higher']} js-hidden`),
              (o.className = `${N['tv-dom-widget-main__offscreen-arrow']} ${N['tv-dom-widget-main__offscreen-arrow--lower']} js-hidden`),
              (e.innerHTML = i(355482)),
              (o.innerHTML = i(482075)),
              t.append(e),
              t.append(o),
              (t) => {
                e.classList.toggle('js-hidden', t !== s.Higher),
                  o.classList.toggle('js-hidden', t !== s.Lower)
              }
            )
          })(e)
          this._content.getOffscreenIndexLocationObservable().subscribe(r),
            this._createMainBlock(e),
            this._createNavBlock(o),
            this._createDOMBottomWidget(o),
            this._container.append(e),
            this._container.append(o),
            this._calcData.reset()
        }
        _createMainBlock(t) {
          const e = document.createElement('div')
          ;(e.className = N['tv-dom-widget-main']), t.append(e)
          const s = (this._warning = document.createElement('div'))
          ;(s.className = `${Et['tv-dom-panel__warning']} i-hidden`),
            (s.textContent = o.t(null, void 0, i(180526))),
            e.append(s),
            this._content.setContainer(e)
          let r = 0
          e.addEventListener('wheel', (t) => {
            if (
              !this._content.getDynamicModeState() &&
              (t.deltaMode !== t.DOM_DELTA_PAGE
                ? (r -= (0, b.getPixelsFromEvent)(t).y / 100)
                : (r -= (0, w.clamp)(t.deltaY, -1, 1)),
              Math.abs(r) >= 1)
            ) {
              const t = r % 1
              this.uiScroll(r - t), (r = t)
            }
          })
          let n = !1
          const a = (t) => {
            if (n) return
            const e = 'touches' in t
            if (!e && 1 !== (t.buttons || t.which)) return
            const i = this._content.topIndex
            if (!isFinite(i)) return
            if (e && 1 !== t.touches.length) return
            if (!(t.target instanceof Element)) return
            if (!t.target.closest(`.${N['tv-dom-widget-main__value--price']}`))
              return
            n = !0
            const s = Gt(t),
              o = document.documentElement,
              r = () => {
                ;[
                  'mouseup',
                  'mousedown',
                  'touchend',
                  'touchstart',
                  'touchcancel',
                ].forEach((t) => o.removeEventListener(t, r)),
                  o.removeEventListener('mousemove', a),
                  o.removeEventListener('touchmove', a),
                  (n = !1),
                  this._content.setDragShield(!1, !1),
                  this._mergeTimerLockState({ scroll: !1 })
              },
              a = (t) => {
                if (!this._content.getDynamicModeState()) {
                  if (!e && 1 !== (t.buttons || t.which)) return void r()
                  const o = Gt(t) - s,
                    n = Math.round(o / 20)
                  n &&
                    (this._content.setDragShield(!0, !1),
                    this._mergeTimerLockState({ scroll: !0 })),
                    this._content.shiftTopIndexRelativeToIndex(i, n)
                }
              }
            o.addEventListener(e ? 'touchmove' : 'mousemove', a),
              o.addEventListener(e ? 'touchend' : 'mouseup', r),
              e && o.addEventListener('touchcancel', r),
              setTimeout(() => {
                n && o.addEventListener(e ? 'touchstart' : 'mousedown', r)
              }, 0)
          }
          e.addEventListener('mousedown', a),
            e.addEventListener('touchstart', a),
            e.addEventListener('dblclick', (t) => {
              if (!(t.target instanceof Element)) return
              t.target.closest(`.${N['tv-dom-widget-main__value--price']}`) &&
                this.uiCenter()
            }),
            (this._mainBlock = e)
        }
        _createDOMBottomWidget(t) {
          var e
          const i = document.createElement('div')
          t.append(i)
          const s = {
              domDetails: this._domDetails,
              currentDuration: this._currentDuration,
              durationMetaInfoList: this._durationMetaInfoList,
              onDurationChanged: this._onDurationChanged,
              openState: this._detailsOpenState,
            },
            o = { calcData: this._calcData },
            a = { uiPlaceOrder: (t) => this.uiPlaceOrder(t) },
            l = {
              uiClosePosition: () => this.uiClosePosition(),
              uiCancelAllOrders: () => this.uiCancelAllOrders(),
              uiReversePosition: () => this.uiReversePosition(),
            },
            d = {
              plState: this._calcData.plState$,
              positionState: this._calcData.positionState$,
              changePLViewType: this._calcData.changePLViewType,
              compareQty: this._calcData.compareQty,
            }
          !((t, e) => {
            r.render(n.createElement(Dt, { ...e }), t)
          })(i, {
            uiState$: this._uiState$.asObservable(),
            warningMessage$:
              null === (e = this._warningMessage$) || void 0 === e
                ? void 0
                : e.asObservable(),
            tradingActionBlockControllers: l,
            domDetailsDropdownProps: s,
            domNumberContainerProps: o,
            domMarketActionBlockProps: a,
            domCalcBlockProps: d,
          })
        }
        _createNavBlock(t) {
          const e = { on: qt, off: Wt },
            s = (0, d.ensureNotNull)(
              (0, I.parseHtmlElement)(
                `\n\t\t\t<div class="tv-dom-widget-nav-wrapper">\n\t\t\t\t<div class="${Ft['tv-dom-widget-nav']}">\n\t\t\t\t\t<div class="${Ft['tv-dom-widget-nav__button-block']} ${Ft['tv-dom-widget-nav__button-block--orders']}">\n\t\t\t\t\t\t<span class="apply-common-tooltip ${Ft['tv-dom-widget-nav__button']} ${Ft['tv-dom-widget-nav__button--clear-ask']} js-clear-ask">\n\t\t\t\t\t\t\t${$t}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span class="${Ft['tv-dom-widget-nav_count-volume']} js-count-volume-buy"></span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="${Ft['tv-dom-widget-nav__button-block']} ${Ft['tv-dom-widget-nav__button-block--price']}">\n\t\t\t\t\t\t<div class="${Ft['tv-dom-widget-nav_overall-volume']} ${Ft['tv-dom-widget-nav_overall-volume--bid']}">\n\t\t\t\t\t\t\t<span class="apply-common-tooltip js-total-volume-bid"></span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="${Ft['tv-dom-widget-nav_center']} apply-common-tooltip js-center">\n\t\t\t\t\t\t\t<svg class="${Ft['tv-dom-widget-nav__timer']}" viewBox="-1 -1 2 2" width="2" height="2">\n\t\t\t\t\t\t\t\t<path d="M 0,0" class="js-timer-path"></path>\n\t\t\t\t\t\t\t</svg>\n\t\t\t\t\t\t\t<span class="${Ft['tv-dom-widget-nav__button']} ${Ft['tv-dom-widget-nav__button--center']} js-center-target">\n\t\t\t\t\t\t\t\t${e.off}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="${Ft['tv-dom-widget-nav_overall-volume']} ${Ft['tv-dom-widget-nav_overall-volume--ask']}">\n\t\t\t\t\t\t\t<span class="apply-common-tooltip js-total-volume-ask"></span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class="${Ft['tv-dom-widget-nav__button-block']} ${Ft['tv-dom-widget-nav__button-block--orders']}">\n\t\t\t\t\t\t<span class="${Ft['tv-dom-widget-nav_count-volume']} js-count-volume-sell"></span>\n\t\t\t\t\t\t<span class="apply-common-tooltip ${Ft['tv-dom-widget-nav__button']} ${Ft['tv-dom-widget-nav__button--clear-bid']} js-clear-bid">\n\t\t\t\t\t\t\t${$t}\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t`,
              ),
            ),
            r = (0, d.ensureNotNull)(s.querySelector('.js-clear-ask')),
            n = (0, d.ensureNotNull)(s.querySelector('.js-clear-bid')),
            a = (0, d.ensureNotNull)(s.querySelector('.js-center')),
            l = (0, d.ensureNotNull)(s.querySelector('.js-center-target'))
          ;(this._totalVolumeBidTextNode = document.createTextNode('-')),
            (this._totalVolumeAskTextNode = document.createTextNode('-')),
            (this._countVolumeBuyTextNode = document.createTextNode('')),
            (this._countVolumeSellTextNode = document.createTextNode(''))
          const h = (0, d.ensureNotNull)(
              s.querySelector('.js-total-volume-bid'),
            ),
            u = (0, d.ensureNotNull)(s.querySelector('.js-total-volume-ask')),
            c = (0, d.ensureNotNull)(
              (this._countVolumeBid = s.querySelector('.js-count-volume-buy')),
            ),
            _ = (0, d.ensureNotNull)(
              (this._countVolumeAsk = s.querySelector('.js-count-volume-sell')),
            )
          h.appendChild(this._totalVolumeBidTextNode),
            h.setAttribute('title', o.t(null, void 0, i(353723))),
            u.appendChild(this._totalVolumeAskTextNode),
            u.setAttribute('title', o.t(null, void 0, i(977088))),
            c.appendChild(this._countVolumeBuyTextNode),
            _.appendChild(this._countVolumeSellTextNode),
            r.setAttribute('title', o.t(null, void 0, i(702333))),
            n.setAttribute('title', o.t(null, void 0, i(139710))),
            a.setAttribute('title', o.t(null, void 0, i(785663))),
            r.addEventListener('click', (t) => {
              t.preventDefault(), this.uiCancelAllOrders(1)
            }),
            n.addEventListener('click', (t) => {
              t.preventDefault(), this.uiCancelAllOrders(-1)
            }),
            a.addEventListener('click', (t) => {
              t.preventDefault(), this.uiCenter()
              const s = this._content.toggleDynamicModeState(),
                r = s ? e.on : e.off,
                n = s
                  ? o.t(null, void 0, i(44316))
                  : o.t(null, void 0, i(785663))
              a.setAttribute('title', n),
                l.removeChild(l.children[0]),
                l.appendChild((0, d.ensureNotNull)((0, I.parseHtmlElement)(r)))
            }),
            (this._svgTimerPath = s.querySelector('.js-timer-path')),
            (this._navButtons = { clearBuy: r, clearSell: n }),
            t.append(s)
        }
        _showNoDataNotice() {}
        _hideNoDataNotice() {}
        _syncActionButtons() {
          const {
            isPositionBlocked: t,
            isTradable: e,
            hasPosition: i,
            hasBuyOrders: s,
            hasSellOrders: o,
            hasFlatten: r,
            hasReverse: n,
          } = this._uiState
          if (this._actionPositionButtons && this._actionMarketButtons) {
            const a = {
                ...this._actionPositionButtons,
                ...this._actionMarketButtons,
              },
              l = 'i-disabled'
            ;(a.flatten.disabled = t || !e || !i || !r),
              (a.reverse.disabled = t || !e || !i || !n),
              (a.clear.disabled = !e || !(s || o)),
              (a.flatten.title = this._flattenTitle),
              (a.reverse.title = this._reverseTitle),
              (a.clear.title = this._csxAllTitle)
            const d = this._isOrderTypeSupported(2)
            a.buyMarket.classList.toggle(l, !d),
              a.sellMarket.classList.toggle(l, !d)
          }
          if (this._navButtons) {
            const t = this._navButtons,
              i = Ft['tv-dom-widget-nav__button--disabled']
            t.clearBuy.classList.toggle(i, !e || !s),
              t.clearSell.classList.toggle(i, !e || !o)
          }
        }
        _mergeUiState(t) {
          const e = this._uiState
          let i,
            s = !1
          for (i in t) e[i] !== t[i] && ((e[i] = t[i]), (s = !0))
          s &&
            (this._uiState$.next({ ...e }),
            this._headerState.setIsTradable(e.isTradable),
            this._syncActionButtons())
        }
        _handlers() {
          return {
            closeButtonClick: (t, e) => {
              t.preventDefault(), this.uiCancelOrder(e && e.id)
            },
            qtyClick: (t, e) => {
              t.preventDefault(), this.uiModifyOrder(e)
            },
            bidAskClick: (t, { side: e, price: i, type: s }) => {
              t.preventDefault(),
                this.uiPlaceOrder({ side: e, price: i, type: s || null })
            },
            bidAskContextMenu: (t, { side: e, price: i }) => {
              t.preventDefault(), this.uiContextMenu(t, e, i)
            },
            qtyChange: (t) => {
              !isFinite(t) ||
                t < 0 ||
                (this._qtySuggester.setQty(
                  this._tradingLinking.value().symbol,
                  t,
                ),
                this._mergeUiState({ qty: t }))
            },
            qtyInput: (t) => {
              !isFinite(t) || t < 0 || this._mergeUiState({ qty: t })
            },
            orderMousedown: (t, { order: e, pricePropertyName: i }) => {
              this.uiOrderMousedown(t, e, i)
            },
          }
        }
        _mergeTimerLockState(t) {
          const e = this._timerLockState
          let i,
            s = !1
          for (i in t) e[i] !== t[i] && ((e[i] = t[i]), (s = !0))
          s &&
            (!e.autoCenterRequired || e.scroll || e.drag || e.dialog
              ? this._timer.abort()
              : this._timer.run())
        }
        _lockTimerUntilSettled(t) {
          if (!t) return
          this._mergeTimerLockState({ dialog: t })
          const e = () => {
            this._timerLockState.dialog === t &&
              this._mergeTimerLockState({ dialog: null })
          }
          t.then(e, e)
        }
        _updateTimerUi(t) {
          ;(t = t || 0),
            (0, d.ensureNotNull)(this._svgTimerPath).setAttribute(
              'd',
              ((t) => {
                let e = 'M 0 0'
                return (
                  t > 0 &&
                    (t >= 1 ? (e = 'M 0 -1') : (e += 'L 0 -1'),
                    t > 0.5 && (e += 'A 1 1 0 0 1 0 1'),
                    (e +=
                      'A 1 1 0 0 1 ' +
                      Math.sin(2 * t * Math.PI) +
                      ' ' +
                      -Math.cos(2 * t * Math.PI) +
                      'Z')),
                  e
                )
              })(t),
            )
        }
        async _getSymbolData(t) {
          const e = this._realtimeProvider.activeBroker(),
            [i, s, o, r] = await Promise.all([
              this._realtimeProvider.symbolInfo(t),
              this._realtimeProvider.quantityFormatter(t),
              null == e ? void 0 : e.getPositionCurrency(t),
              null == e ? void 0 : e.formatter(t, !0),
            ]),
            n = null != r ? r : await this._realtimeProvider.formatter(t),
            a = Math.ceil(-Math.log10(i.qty.step)),
            l = new k.VolumeFormatter(a)
          return {
            brokerSymbol: i.brokerSymbol,
            minTick: i.minTick,
            pipSize: i.pipSize,
            priceFormatter: n,
            volumeFormatter: l,
            quantityFormatter: s,
            qtyProperties: i.qty,
            lotSize: i.lotSize,
            positionCurrency: o,
            variableMinTickData: i.variableMinTick
              ? (0, T.makeVariableMinTickData)(i.minTick, i.variableMinTick)
              : void 0,
          }
        }
        _unsubscribeData() {
          var t
          if (!this._subscription) return
          const {
            broker: e,
            symbol: i,
            domHandler: s,
            realtimeHandler: o,
            orderHandler: r,
            positionHandler: n,
            plHandler: a,
            plPositionId: l,
            fullUpdateOrders: d,
            fullUpdatePosition: h,
          } = this._subscription
          ;(this._subscription = null),
            i && o && this._realtimeProvider.unsubscribeRealtime(i, o),
            i && s && this._realtimeProvider.unsubscribeDOM(i, s),
            e && r && e.orderUpdate.unsubscribe(null, r),
            e && n && e.positionUpdate.unsubscribe(null, n),
            e && a && l && e.unsubscribePL(l, a),
            e && d && e.currentAccountUpdate.unsubscribe(null, d),
            e && h && e.currentAccountUpdate.unsubscribe(null, h),
            null === (t = this._suggestedQtySubscription) ||
              void 0 === t ||
              t.unsubscribe()
        }
        _trackEvent(t, e) {
          this._trading.trackEvent('DOM', t, e)
        }
        _processOrders(t) {
          const e = []
          let i = !1,
            s = !1
          for (let o = 0; o < t.length; o++) {
            const r = t[o]
            if (4 === r.status || 3 === r.status || 6 === r.status)
              switch ((e.push(r), r.side)) {
                case 1:
                  i = !0
                  break
                case -1:
                  s = !0
              }
          }
          this._content.updateOrders(e),
            this._updateValueBuySellOrders(),
            this._mergeUiState({ hasBuyOrders: i, hasSellOrders: s })
        }
        _processPositions(t, e, i) {
          const s = i.find((t) => 0 !== t.qty)
          this._mergeUiState({ hasPosition: !!s }),
            (void 0 !== s && s.id === e.plPositionId) ||
              (e.plPositionId &&
                e.plHandler &&
                t.unsubscribePL &&
                (t.unsubscribePL(e.plPositionId, e.plHandler),
                delete e.plPositionId,
                (e.plHandler = null))),
            void 0 === s ||
              (e.plPositionId === s.id && e.plHandler) ||
              ((e.plHandler = (t, i) => {
                this._subscription === e && this._calcData.updatePL(i)
              }),
              (e.plPositionId = s.id),
              t.subscribePL(e.plPositionId, e.plHandler)),
            this._content.updatePosition(s),
            this._calcData.updatePosition(s),
            this._calcData.updatePL()
        }
        _updateDurationMetainfo(t, e, i) {
          const s = null == t ? void 0 : t.metainfo().durations
          if (
            (this._durationMetaInfoList.setValue(
              void 0 !== s
                ? (0, g.filterDurationsBySymbolDurations)(s, i)
                : void 0,
            ),
            null === t || void 0 === this._durationMetaInfoList.value())
          )
            return
          const o = Ht(t.metainfo().id, e),
            r = h.getValue(o),
            n =
              void 0 !== r
                ? this._makeOrderDuration(r)
                : this._makeDefaultOrderDuration()
          this._currentDuration.setValue(n),
            void 0 !== n &&
              this._domDetails.setDurationsInfo(
                n,
                this._durationMetaInfoList.value(),
              )
        }
        _makeDefaultOrderDuration() {
          const t = this._durationMetaInfoList.value()
          if (void 0 === t || 0 === t.length) return
          const e = t.find((t) => !0 === t.default) || t[0]
          return (0, g.makeOrderDuration)(e)
        }
        _makeOrderDuration(t) {
          var e
          const i =
            null === (e = this._durationMetaInfoList.value()) || void 0 === e
              ? void 0
              : e.find((e) => e.value === t)
          return void 0 !== i ? (0, g.makeOrderDuration)(i) : void 0
        }
        async _onStateChange() {
          const { symbol: t } = this._tradingLinking.value(),
            e = this._realtimeProvider.activeBroker(),
            i =
              null == e ? void 0 : e.metainfo().configFlags.calculatePLUsingLast
          if (!this._visible.value()) return void this._unsubscribeData()
          this._noDataTimeout && clearTimeout(this._noDataTimeout),
            (this._noDataTimeout = setTimeout(() => {
              var t
              null === (t = this._warning) ||
                void 0 === t ||
                t.classList.remove('i-hidden')
            }, 3e3)),
            this._domSymbolInfo$.next({
              symbol: t,
              brokerName: null == e ? void 0 : e.metainfo().title,
            }),
            this._headerState.setTitle(t),
            this._headerState.setDescription(
              null == e ? void 0 : e.metainfo().title,
            ),
            this._headerState.setSymbol(t),
            (this._symbolData = null),
            this._unsubscribeData(),
            this._content.reset(),
            this._calcData.setBrokerConfigFlags({
              calculatePLUsingLast: !0 === i,
            }),
            this._calcData.reset()
          const s =
            null === e ||
            (null == e ? void 0 : e.metainfo().configFlags.supportDOM)
          ;(this._configFlags = null == e ? void 0 : e.metainfo().configFlags),
            this._mergeUiState({
              isTradable: !1,
              hasPosition: !1,
              hasBuyOrders: !1,
              hasSellOrders: !1,
              qty: void 0,
              hasFlatten:
                null !== e && !e.metainfo().configFlags.supportMultiposition,
            }),
            this._mergeTimerLockState({ scroll: !1, drag: !1, dialog: null }),
            this.uiStopOrderDrag()
          let o = [],
            r = []
          if (!t || !s) return
          const n = {
            broker: e,
            symbol: t,
            domHandler: null,
            realtimeHandler: null,
            orderHandler: null,
            positionHandler: null,
            plHandler: null,
            plPositionId: void 0,
            fullUpdateOrders: null,
            fullUpdatePosition: null,
          }
          this._subscription = n
          const a = await this._qtySuggester.getQty(t)
          this._onSuggestedQtyChange(a),
            (this._suggestedQtySubscription = this._qtySuggester
              .suggestedQtyChanged(t)
              .subscribe(this._onSuggestedQtyChange))
          const l = await this._getSymbolData(t)
          if ((this._calcData.setHasLotSize(void 0 !== l.lotSize), !l)) return
          if (this._subscription !== n) return
          ;(this._symbolData = l),
            this._content.setSymbolInfo(l),
            this._calcData.setSymbolInfo(l),
            this._domSymbolInfo$.next({
              symbol: t,
              brokerName: null == e ? void 0 : e.metainfo().title,
              brokerSymbol: l.brokerSymbol,
            }),
            this._headerState.setTitle(l.brokerSymbol || t),
            this._headerState.setDescription(
              null == e ? void 0 : e.metainfo().title,
            ),
            this.isBats.setValue(!1),
            (n.realtimeHandler = (t, e) => {
              var i
              const s = e.trade || e.bid || e.ask
              s &&
                this._noDataTimeout &&
                (null === (i = this._warning) ||
                  void 0 === i ||
                  i.classList.add('i-hidden'),
                clearTimeout(this._noDataTimeout),
                (this._noDataTimeout = null)),
                this._content.updateLast(s || Number.NaN),
                this._calcData.updateLast(
                  e.trade || Number.NaN,
                  e.bid || Number.NaN,
                  e.ask || Number.NaN,
                ),
                this.delayedData.setValue(Boolean(e.isDelayed)),
                this._headerState.setHasDelayedQuotes(Boolean(e.isDelayed)),
                this._headerState.setHasBatsQuotes((0, g.isBatsQuotes)(e)),
                !this.isBats.value() &&
                  (0, g.isBatsQuotes)(e) &&
                  this.isBats.setValue(!0)
            }),
            (n.domHandler = (t, e) => {
              this._content.updateData(e), this._scheduleUpdateViewTotalVolume()
            })
          const [{ tradable: d }, h] = await Promise.all([
            this._realtimeProvider.isTradable(t),
            null == e ? void 0 : e.getSymbolSpecificTradingOptions(t),
          ])
          this._updateDurationMetainfo(
            e,
            t,
            null == h ? void 0 : h.allowedDurations,
          ),
            this._mergeUiState({
              isTradable: d,
              symbolSpecificWarningMessage:
                null == h ? void 0 : h.warningMessage,
              hasReverse: null == h ? void 0 : h.supportReversePosition,
            }),
            this._realtimeProvider.subscribeRealtime(t, n.realtimeHandler),
            this._realtimeProvider.subscribeDOM(t, n.domHandler),
            (this._supportedOrderTypes = this._getSupportedOrderTypes(
              e,
              null == h ? void 0 : h.allowedOrderTypes,
            )),
            this._isOrderTypeSupported(3)
              ? (document.addEventListener(
                  'keydown',
                  this._handleModKeyStateChange,
                  !1,
                ),
                document.addEventListener(
                  'keyup',
                  this._handleModKeyStateChange,
                  !1,
                ))
              : (document.removeEventListener(
                  'keydown',
                  this._handleModKeyStateChange,
                ),
                document.removeEventListener(
                  'keyup',
                  this._handleModKeyStateChange,
                )),
            e &&
              d &&
              ((n.orderHandler = (t) => {
                if (t.symbol !== n.symbol) return
                const e = o.findIndex((e) => e.id === t.id)
                ;-1 !== e ? (o[e] = t) : o.push(t), this._processOrders(o)
              }),
              (n.positionHandler = (t) => {
                if (t.symbol !== n.symbol) return
                const i = r.findIndex((e) => e.id === t.id)
                ;-1 !== i ? (r[i] = t) : r.push(t),
                  this._processPositions(e, n, r)
              }),
              (n.fullUpdateOrders = () => {
                const i = e.orders(t)
                ;(n.orderPromise = i),
                  i.then((t) => {
                    this._subscription === n &&
                      n.orderPromise === i &&
                      ((o = t), this._processOrders(t))
                  })
              }),
              (n.fullUpdatePosition = () => {
                const i = e.positions(t)
                ;(n.positionPromise = i),
                  i.then((t) => {
                    this._subscription === n &&
                      n.positionPromise === i &&
                      ((r = t), this._processPositions(e, n, t))
                  })
              }),
              e.orderUpdate.subscribe(null, n.orderHandler),
              e.positionUpdate.subscribe(null, n.positionHandler),
              e.currentAccountUpdate.subscribe(null, n.fullUpdateOrders),
              e.currentAccountUpdate.subscribe(null, n.fullUpdatePosition),
              n.fullUpdateOrders(),
              n.fullUpdatePosition()),
            this._updateViewTotalVolume(),
            this._updateValueBuySellOrders()
        }
        async _updateDetails() {
          var t, e
          const i = await (null ===
              (t = this._realtimeProvider.activeBroker()) || void 0 === t
              ? void 0
              : t.getOrderDialogOptions(this._tradingLinking.value().symbol)),
            s =
              null !== (e = null == i ? void 0 : i.customFields) && void 0 !== e
                ? e
                : []
          this._domDetails.setCustomFields(s)
        }
        _getSupportedOrderTypes(t, e) {
          const i = []
          return null === t || 1 !== t.connectionStatus()
            ? [2]
            : (t.metainfo().configFlags.supportMarketOrders &&
                (0, g.isOrderTypeAllowed)(2, e) &&
                i.push(2),
              t.metainfo().configFlags.supportLimitOrders &&
                (0, g.isOrderTypeAllowed)(1, e) &&
                i.push(1),
              t.metainfo().configFlags.supportStopOrders &&
                (0, g.isOrderTypeAllowed)(3, e) &&
                i.push(3),
              t.metainfo().configFlags.supportStopLimitOrders &&
                (0, g.isOrderTypeAllowed)(4, e) &&
                i.push(4),
              i)
        }
        _isOrderTypeSupported(t) {
          return -1 !== this._supportedOrderTypes.indexOf(t)
        }
        _scheduleUpdateViewTotalVolume() {
          this._viewTotalVolumeScheduled ||
            ((this._viewTotalVolumeScheduled = !0),
            window.requestAnimationFrame(() => this._updateViewTotalVolume()))
        }
        _updateViewTotalVolume() {
          if (((this._viewTotalVolumeScheduled = !1), this._symbolData)) {
            const t = this._content.totalVolumeBid(),
              e = this._content.totalVolumeAsk(),
              i = (0, d.ensureNotNull)(this._totalVolumeBidTextNode),
              s = (0, d.ensureNotNull)(this._totalVolumeAskTextNode)
            ;(i.nodeValue = isFinite(t) ? this._content.formatVolume(t) : '-'),
              (s.nodeValue = isFinite(e) ? this._content.formatVolume(e) : '-')
          }
        }
        _updateValueBuySellOrders() {
          const t = this._content.buyOrdersValue(),
            e = this._content.sellOrdersValue(),
            i = this._content.buyInactiveOrdersValue(),
            s = this._content.sellInactiveOrdersValue(),
            o = this._content.buyOrdersQuantity(),
            r = this._content.sellOrdersQuantity(),
            n = (0, d.ensureNotNull)(this._countVolumeBid),
            a = (0, d.ensureNotNull)(this._countVolumeAsk),
            l = (0, d.ensureNotNull)(this._countVolumeBuyTextNode),
            h = (0, d.ensureNotNull)(this._countVolumeSellTextNode)
          0 !== t || 0 !== i
            ? (n.setAttribute(
                'title',
                this._setFormattingTextForCountVolume(t, i, +o),
              ),
              n.classList.add('apply-common-tooltip'))
            : (n.setAttribute('title', ''),
              n.classList.remove('apply-common-tooltip')),
            0 !== e || 0 !== s
              ? (a.setAttribute(
                  'title',
                  this._setFormattingTextForCountVolume(e, s, +r),
                ),
                a.classList.add('apply-common-tooltip'))
              : (a.setAttribute('title', ''),
                a.classList.remove('apply-common-tooltip')),
            (l.nodeValue = String(i > 0 ? t : t || '')),
            (h.nodeValue = String(s > 0 ? e : e || ''))
        }
        _setFormattingTextForCountVolume(t, e, s) {
          const r = o
              .t(
                null,
                {
                  plural: '{countOrders} active orders x {countQuantity}',
                  count: t,
                },
                i(726965),
              )
              .format({ countOrders: String(t), countQuantity: String(s) }),
            n = o
              .t(
                null,
                { plural: '{countInactiveOrders} inactive orders', count: e },
                i(373797),
              )
              .format({ countInactiveOrders: String(e) })
          return r + (e > 0 ? `, ${n}` : '')
        }
      }
      var Ut = i(80423)
      class jt {
        constructor(t, e, s, d, h) {
          var u
          ;(this._container = document.createElement('div')),
            (this._syncEnabled = () => {
              const t = this._trading.activeBroker()
              return 1 === (null == t ? void 0 : t.connectionStatus()) &&
                !t.metainfo().configFlags.supportDOM
                ? this._showEmptyState()
                : this._hideEmptyState()
            }),
            (this._hideEmptyState = () => {
              var t
              void 0 !== this._emptyStateContainer &&
                (r.unmountComponentAtNode(this._emptyStateContainer),
                this._emptyStateContainer.remove(),
                (this._emptyStateContainer = void 0),
                null === (t = this._content) ||
                  void 0 === t ||
                  t.classList.remove('js-hidden'))
            }),
            (this._showEmptyState = () => {
              var t
              void 0 === this._emptyStateContainer &&
                (null === (t = this._content) ||
                  void 0 === t ||
                  t.classList.add('js-hidden'),
                (this._emptyStateContainer = document.createElement('div')),
                this._emptyStateContainer.classList.add(
                  Et['tv-dom-panel__disabled'],
                ),
                r.render(
                  n.createElement(a.EmptyStateBlock, {
                    iconClass: Et.emptyStateImage,
                    title: o.t(null, void 0, i(749117)),
                    titleSize: 'normal',
                    text: o.t(null, void 0, i(90714)),
                  }),
                  this._emptyStateContainer,
                ),
                this._container.appendChild(this._emptyStateContainer))
            }),
            (this._syncVisibility = (t) => {
              t ? this._body.append(this._container) : this._container.remove()
            }),
            (this._resizerBridge = e),
            (this._widgetBody = new l.WatchedValue()),
            (this._visible = new l.WatchedValue(!1)),
            (this._trading = t),
            (this._qtySuggester = s),
            (this._tradingLinking = d),
            (this._headerState = h),
            this._headerState.setSettings(
              ((u = t.showPricesWith()),
              [
                {
                  settingType: 0,
                  label: o.t(null, void 0, i(573712)),
                  value$: (0, Ut.makeObservableFromWatchedValue)(u.zeroVolume),
                  onClick: () => u.zeroVolume.setValue(!u.zeroVolume.value()),
                },
                {
                  settingType: 0,
                  label: o.t(null, void 0, i(747987)),
                  value$: (0, Ut.makeObservableFromWatchedValue)(u.spread),
                  onClick: () => u.spread.setValue(!u.spread.value()),
                },
              ]),
            ),
            (this._body = this._resizerBridge.container
              .value()
              .querySelector('.trading-panel-content')),
            (this._container = document.createElement('div')),
            this._trading.onConnectionStatusChange.subscribe(
              null,
              this._syncEnabled,
            ),
            this._syncEnabled(),
            this._visible.when(() => {
              this._resizerBridge.container.subscribe(
                (t) => {
                  ;(this._body = t.querySelector('.trading-panel-content')),
                    this._createLayout(),
                    this._syncEnabled()
                },
                { callWithLast: !0 },
              ),
                new Rt(
                  this._widgetBody,
                  this._visible,
                  this._trading,
                  this._qtySuggester,
                  this._tradingLinking,
                  this._headerState,
                ),
                this._visible.subscribe(this._syncVisibility)
            })
        }
        setCloseHandler(t) {
          this._headerState.setCloseFunction(t)
        }
        setVisibility(t) {
          this._visible.setValue(t)
        }
        _createLayout() {
          this._container.classList.add(Et['tv-dom-panel'])
          const t = (this._content = document.createElement('div'))
          t.classList.add(Et['tv-dom-panel__content'], Et.mainblock),
            this._container.append(t),
            this._container.addEventListener('contextmenu', (t) => {
              ;(t.target instanceof HTMLElement &&
                t.target.matches('input, textarea')) ||
                t.preventDefault()
            }),
            this._body.append(this._container),
            this._widgetBody.setValue(t)
        }
      }
    },
    901317: (t, e, i) => {
      i.d(e, { useWatchedValue: () => o })
      var s = i(50959)
      const o = (t) => {
        const [e, i] = (0, s.useState)(t.value())
        return (
          (0, s.useEffect)(() => {
            const e = (t) => i(t)
            return t.subscribe(e), () => t.unsubscribe(e)
          }, [t]),
          [e, (e) => t.setValue(e)]
        )
      }
    },
    181436: (t, e, i) => {
      i.d(e, { getPixelsFromEvent: () => o })
      const s = [
        () =>
          navigator.userAgent.includes('Win') &&
          navigator.userAgent.includes('Chrome')
            ? 1 / window.devicePixelRatio
            : 1,
        () => 16,
        (t = () => 0) => {
          var e
          return 0.8 * (null !== (e = t()) && void 0 !== e ? e : 0)
        },
      ]
      function o(t, e = () => ({})) {
        return {
          x: t.deltaX * s[t.deltaMode](() => e().width),
          y: t.deltaY * s[t.deltaMode](() => e().height),
        }
      }
    },
    80423: (t, e, i) => {
      i.d(e, { makeObservableFromWatchedValue: () => o })
      var s = i(275734)
      function o(t) {
        return (0, s.fromEventPattern)(
          (e) => t.subscribe(e, { callWithLast: !0 }),
          (e) => t.unsubscribe(e),
        )
      }
    },
    476007: (t, e, i) => {
      i.d(e, { SplitThousandsFormatter: () => r })
      var s = i(793361),
        o = i(710263)
      class r {
        constructor(t = ' ') {
          this._divider = t
        }
        format(t) {
          const e = (0, s.splitThousands)(t, this._divider)
          return (0, o.isRtl)() ? (0, o.startWithLTR)(e) : e
        }
        parse(t) {
          const e = (0, o.stripLTRMarks)(t).split(this._divider).join(''),
            i = Number(e)
          return isNaN(i) || /e/i.test(e)
            ? { res: !1 }
            : { res: !0, value: i, suggest: this.format(i) }
        }
      }
    },
    611902: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18" fill="none"><path stroke="currentcolor" stroke-linecap="round" d="M4 7l5 4 5-4"/></svg>'
    },
    488263: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18 18" width="18" height="18" fill="none"><path stroke="currentcolor" stroke-linecap="round" d="M4 11l5-4 5 4"/></svg>'
    },
    11728: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9 9" width="9" height="9"><path stroke="currentcolor" stroke-width="1.2" d="M1 1l7 7m0-7L1 8"/></svg>'
    },
    781957: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 17" width="16" height="17" fill="none"><rect width="15" height="9" stroke="currentcolor" rx="2.5" x=".5" y="7.5"/><circle stroke="currentcolor" cx="8" cy="12" r=".5"/><path stroke="currentcolor" d="M3.5 7c0 .28.22.5.5.5h8a.5.5 0 0 0 .5-.5V5a4.5 4.5 0 1 0-9 0v2z"/></svg>'
    },
    943145: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 17" width="16" height="17" fill="none"><path fill="currentcolor" fill-rule="evenodd" clip-rule="evenodd" d="M4 5v2h9a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V5a5 5 0 0 1 8.66-3.4l-.74.66A3.99 3.99 0 0 0 4 5z"/><rect width="15" height="9" stroke="currentcolor" rx="2.5" x=".5" y="7.5"/><circle stroke="currentcolor" cx="8" cy="12" r=".5"/></svg>'
    },
    482075: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 7" width="12" height="7"><path d="M1 0a1 1 0 0 0-1 1c0 .276.1.538.28.72l5 5c.182.18.444.28.72.28.276 0 .538-.1.72-.28l5-5c.18-.182.28-.444.28-.72a1 1 0 0 0-1-1c-.276 0-.538.1-.72.28L6 4.563 1.72.282C1.537.1 1.275 0 1 0z"/></svg>'
    },
    355482: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 7" width="12" height="7"><path d="M1 7a1 1 0 0 1-1-1c0-.276.1-.538.28-.72l5-5C5.463.1 5.725 0 6 0c.276 0 .538.1.72.28l5 5c.18.182.28.444.28.72a1 1 0 0 1-1 1c-.276 0-.538-.1-.72-.28L6 2.437l-4.28 4.28C1.537 6.9 1.275 7 1 7z"/></svg>'
    },
    548927: (t) => {
      t.exports =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9 9" width="9px" height="9px"><path d="M2 1L1 2l2.5 2.5L1 7l1 1 2.5-2.5L7 8l1-1-2.5-2.5L8 2 7 1 4.5 3.5z"/></svg>'
    },
  },
])
