'use client'

import { createToast } from '@sushiswap/notifications'
import { useCallback, useMemo, useState } from 'react'
import type { Token } from 'sushi/currency'
import { usePublicClient, useSimulateContract, useWriteContract } from 'wagmi'
import type { z } from 'zod'

import type { Address } from 'viem'
import type { SendTransactionReturnType } from 'wagmi/actions'
import { SushiFundsReturnerAbi } from '../abis/SushiFundsReturnerAbi'
import { RP2ClaimAddress, type RP2MerkleTreeClaimSchema } from '../constants'
import type { RP2ClaimChainId } from '../types'

interface UseRP2ExploitCheck {
  token: Token | undefined
  account: Address | undefined
  chainId: RP2ClaimChainId
  claim: z.TypeOf<typeof RP2MerkleTreeClaimSchema>
}

export const ClaimContractConfig = (chainId: RP2ClaimChainId) => ({
  address: RP2ClaimAddress[chainId] as Address,
  abi: SushiFundsReturnerAbi,
})

export const useRP2ExploitClaim = ({
  account,
  token,
  chainId,
  claim,
}: UseRP2ExploitCheck) => {
  const [isPending, setIsPending] = useState(false)
  const client = usePublicClient()
  const { data: simulation } = useSimulateContract({
    ...ClaimContractConfig(chainId),
    chainId,
    functionName: 'claim',
    args: [
      BigInt(claim.index),
      BigInt(claim.amount.hex),
      claim.token,
      claim.proof,
    ],
    query: { enabled: Boolean(chainId) },
  })

  const onSuccess = useCallback(
    async (data: SendTransactionReturnType) => {
      if (!account || !token) return

      setIsPending(true)
      try {
        const ts = new Date().getTime()
        const receiptPromise = client.waitForTransactionReceipt({ hash: data })

        void createToast({
          account,
          type: 'swap',
          chainId: chainId,
          txHash: data,
          promise: receiptPromise,
          summary: {
            pending: `Claiming ${token.symbol}`,
            completed: `Successfully revoked approval for ${token.symbol}`,
            failed: `Failed to revoke approval for ${token.symbol}`,
          },
          timestamp: ts,
          groupTimestamp: ts,
        })

        await receiptPromise
      } finally {
        setIsPending(false)
      }
    },
    [account, chainId, token, client],
  )

  const { writeContractAsync, ...rest } = useWriteContract({
    ...simulation?.request,
    mutation: {
      onSuccess,
    },
  })

  const write = useMemo(() => {
    if (!simulation) return undefined

    return async () => {
      try {
        await writeContractAsync(simulation.request)
      } catch {}
    }
  }, [simulation, writeContractAsync])

  return {
    ...rest,
    write,
    isPending: isPending || rest.isPending,
  }
}
