import { Token } from '@sushiswap/currency'
import { createToast } from '@sushiswap/ui/components/toast'
import { SendTransactionResult, waitForTransaction } from '@wagmi/core'
import { useCallback, useMemo, useState } from 'react'
import { Address, useContractWrite, usePrepareContractWrite } from 'wagmi'
import { z } from 'zod'

import { SushiFundsReturnerAbi } from '../abis/SushiFundsReturnerAbi'
import { RP2ClaimAddress, RP2MerkleTreeClaimSchema } from '../constants'
import { RP2ClaimChainId } from '../types'

interface UseRP2ExploitCheck {
  token: Token | undefined
  account: Address | undefined
  chainId: RP2ClaimChainId
  claim: z.TypeOf<typeof RP2MerkleTreeClaimSchema>
}

export const ClaimContractConfig = (chainId: RP2ClaimChainId) => ({
  address: RP2ClaimAddress[chainId] as Address,
  abi: SushiFundsReturnerAbi,
})

export const useRP2ExploitClaim = ({ account, token, chainId, claim }: UseRP2ExploitCheck) => {
  const [isPending, setIsPending] = useState(false)
  const { config } = usePrepareContractWrite({
    ...ClaimContractConfig(chainId),
    chainId,
    functionName: 'claim',
    args: [BigInt(claim.index), BigInt(claim.amount.hex), claim.token, claim.proof],
    enabled: Boolean(chainId),
  })

  const onSettled = useCallback(
    (data: SendTransactionResult | undefined) => {
      if (account && data && token) {
        const ts = new Date().getTime()
        void createToast({
          account,
          type: 'swap',
          chainId: chainId,
          txHash: data.hash,
          promise: waitForTransaction({ hash: data.hash }),
          summary: {
            pending: `Claiming ${token.symbol}`,
            completed: `Successfully revoked approval for ${token.symbol}`,
            failed: `Failed to revoke approval for ${token.symbol}`,
          },
          timestamp: ts,
          groupTimestamp: ts,
        })

        waitForTransaction({ hash: data.hash }).finally(() => {
          setIsPending(false)
        })
      }
    },
    [account, chainId, token]
  )

  const write = useContractWrite({
    ...config,
    onSettled,
    onSuccess: () => setIsPending(true),
  })

  return useMemo(() => {
    return {
      ...write,
      isPending,
    }
  }, [isPending, write])
}
