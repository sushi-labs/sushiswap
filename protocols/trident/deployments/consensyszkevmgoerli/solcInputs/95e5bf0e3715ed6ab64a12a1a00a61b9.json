{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private reentrancyStatus = 1;\n\n    modifier nonReentrant() {\n        require(reentrancyStatus == 1, \"REENTRANCY\");\n\n        reentrancyStatus = 2;\n\n        _;\n\n        reentrancyStatus = 1;\n    }\n}\n"
    },
    "contracts/abstract/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Helper utility that enables calling multiple local methods in a single call.\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\n/// License-Identifier: GPL-2.0-or-later\nabstract contract Multicall {\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        \n        for (uint256 i; i < data.length;) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n\n            // cannot realistically overflow on human timescales\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/abstract/PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later-only\n\npragma solidity >=0.8.0;\n\n/// @dev Custom Errors\nerror UnauthorisedDeployer();\nerror ZeroAddress();\nerror InvalidTokenOrder();\n\n/// @notice Trident pool deployer for whitelisted template factories.\n/// @author Mudit Gupta.\nabstract contract PoolDeployer {\n    address public immutable masterDeployer;\n\n    mapping(address => mapping(address => address[])) public pools;\n    mapping(bytes32 => address) public configAddress;\n\n    modifier onlyMaster() {\n        if (msg.sender != masterDeployer) revert UnauthorisedDeployer();\n        _;\n    }\n\n    constructor(address _masterDeployer) {\n        if (_masterDeployer == address(0)) revert ZeroAddress();\n        masterDeployer = _masterDeployer;\n    }\n\n    function _registerPool(\n        address pool,\n        address[] memory tokens,\n        bytes32 salt\n    ) internal onlyMaster {\n        // Store the address of the deployed contract.\n        configAddress[salt] = pool;\n        // Attacker used underflow, it was not very effective. poolimon!\n        // null token array would cause deployment to fail via out of bounds memory axis/gas limit.\n        unchecked {\n            for (uint256 i; i < tokens.length - 1; ++i) {\n                if (tokens[i] >= tokens[i + 1]) revert InvalidTokenOrder();\n                for (uint256 j = i + 1; j < tokens.length; ++j) {\n                    pools[tokens[i]][tokens[j]].push(pool);\n                    pools[tokens[j]][tokens[i]].push(pool);\n                }\n            }\n        }\n    }\n\n    function poolsCount(address token0, address token1) external view returns (uint256 count) {\n        count = pools[token0][token1].length;\n    }\n\n    function getPools(\n        address token0,\n        address token1,\n        uint256 startIndex,\n        uint256 count\n    ) external view returns (address[] memory pairPools) {\n        pairPools = new address[](count);\n        for (uint256 i = 0; i < count; i++) {\n            pairPools[i] = pools[token0][token1][startIndex + i];\n        }\n    }\n}\n"
    },
    "contracts/abstract/SelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport \"../interfaces/IERC20PermitAllowed.sol\";\n\nabstract contract SelfPermit {\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\n    }\n\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        if (IERC20(token).allowance(msg.sender, address(this)) < value) selfPermit(token, value, deadline, v, r, s);\n    }\n\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n    }\n\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\n            selfPermitAllowed(token, nonce, expiry, v, r, s);\n    }\n}"
    },
    "contracts/deployer/MasterDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IPoolFactory.sol\";\n\n/// @dev Custom Errors\nerror InvalidBarFee();\nerror ZeroAddress();\nerror NotWhitelisted();\n\n/// @notice Trident pool deployer contract with template factory whitelist.\n/// @author Mudit Gupta.\ncontract MasterDeployer is Ownable {\n    event DeployPool(address indexed factory, address indexed pool, bytes deployData);\n    event AddToWhitelist(address indexed factory);\n    event RemoveFromWhitelist(address indexed factory);\n    event BarFeeUpdated(uint256 indexed barFee);\n    event BarFeeToUpdated(address indexed barFeeTo);\n\n    uint256 public barFee;\n    address public barFeeTo;\n    address public immutable bento;\n\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n\n    mapping(address => bool) public pools;\n    mapping(address => bool) public whitelistedFactories;\n\n    constructor(\n        uint256 _barFee,\n        address _barFeeTo,\n        address _bento\n    ) {\n        if (_barFee > MAX_FEE) revert InvalidBarFee();\n        if (_barFeeTo == address(0)) revert ZeroAddress();\n        if (_bento == address(0)) revert ZeroAddress();\n\n        barFee = _barFee;\n        barFeeTo = _barFeeTo;\n        bento = _bento;\n    }\n\n    function deployPool(address _factory, bytes calldata _deployData) external returns (address pool) {\n        if (!whitelistedFactories[_factory]) revert NotWhitelisted();\n        pool = IPoolFactory(_factory).deployPool(_deployData);\n        pools[pool] = true;\n        emit DeployPool(_factory, pool, _deployData);\n    }\n\n    function addToWhitelist(address _factory) external onlyOwner {\n        whitelistedFactories[_factory] = true;\n        emit AddToWhitelist(_factory);\n    }\n\n    function removeFromWhitelist(address _factory) external onlyOwner {\n        whitelistedFactories[_factory] = false;\n        emit RemoveFromWhitelist(_factory);\n    }\n\n    function setBarFee(uint256 _barFee) external onlyOwner {\n        if (_barFee > MAX_FEE) revert InvalidBarFee();\n        barFee = _barFee;\n        emit BarFeeUpdated(_barFee);\n    }\n\n    function setBarFeeTo(address _barFeeTo) external onlyOwner {\n        barFeeTo = _barFeeTo;\n        emit BarFeeToUpdated(_barFeeTo);\n    }\n}\n"
    },
    "contracts/examples/PoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\n\nimport \"./PoolTemplate.sol\";\n\n/**\n * @author Mudit Gupta\n */\nabstract contract PoolFactory is IPoolFactory {\n    // Consider deploying via an upgradable proxy to allow upgrading pools in the future\n\n    function deployPool(bytes memory _deployData) external override returns (address) {\n        return address(new PoolTemplate(_deployData));\n    }\n}\n"
    },
    "contracts/examples/PoolTemplate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.2;\n\n/**\n * @author Mudit Gupta\n */\ncontract PoolTemplate {\n    uint256 public immutable configValue;\n    address public immutable anotherConfigValue;\n\n    constructor(bytes memory _data) {\n        (configValue, anotherConfigValue) = abi.decode(_data, (uint256, address));\n    }\n}\n"
    },
    "contracts/interfaces/IBentoBoxMinimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../libraries/RebaseLibrary.sol\";\n\n/// @notice Minimal BentoBox vault interface.\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\ninterface IBentoBoxMinimal {\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    /// @dev Approves users' BentoBox assets to a \"master\" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function harvest(\n        address token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IConstantProductPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IPool.sol\";\n\ninterface IConstantProductPool is IPool, IERC20 {\n    function getNativeReserves()\n        external\n        view\n        returns (\n            uint256 _nativeReserve0,\n            uint256 _nativeReserve1,\n            uint32\n        );\n}\n"
    },
    "contracts/interfaces/IConstantProductPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./IMasterDeployer.sol\";\n\ninterface IConstantProductPoolFactory {\n    function getDeployData() external view returns (bytes memory, IMasterDeployer);\n}\n"
    },
    "contracts/interfaces/IERC20PermitAllowed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\ninterface IERC20PermitAllowed {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}"
    },
    "contracts/interfaces/IMasterDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool deployer interface.\ninterface IMasterDeployer {\n    function barFee() external view returns (uint256);\n\n    function barFeeTo() external view returns (address);\n\n    function bento() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function pools(address pool) external view returns (bool);\n\n    function deployPool(address factory, bytes calldata deployData) external returns (address);\n}\n"
    },
    "contracts/interfaces/IMasterDeployerV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./IMasterDeployer.sol\";\n\n/// @notice Trident pool deployer interface.\ninterface IMasterDeployerV2 is IMasterDeployer {\n    function barFee() external view returns (uint256);\n\n    function barFeeTo() external view returns (address);\n\n    function bento() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function pools(address pool) external view returns (bool);\n\n    function deployPool(address factory, bytes calldata deployData) external returns (address);\n\n    function owner() external returns (address);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.0;\npragma experimental ABIEncoderV2;\n\n/// @notice Trident pool interface.\ninterface IPool {\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}\n"
    },
    "contracts/interfaces/IPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool deployment interface.\ninterface IPoolFactory {\n    function deployPool(bytes calldata _deployData) external returns (address pool);\n\n    function configAddress(bytes32 data) external returns (address pool);\n}\n"
    },
    "contracts/interfaces/IStablePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IPool.sol\";\n\ninterface IStablePool is IPool, IERC20 {\n    function getNativeReserves()\n        external\n        view\n        returns (\n            uint256 _nativeReserve0,\n            uint256 _nativeReserve1,\n            uint32\n        );\n}\n"
    },
    "contracts/interfaces/IStablePoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./IMasterDeployerV2.sol\";\n\ninterface IStablePoolFactory {\n    function getDeployData() external view returns (bytes memory, IMasterDeployerV2);\n}\n"
    },
    "contracts/interfaces/ITridentCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool callback interface.\ninterface ITridentCallee {\n    function tridentSwapCallback(bytes calldata data) external;\n\n    function tridentMintCallback(bytes calldata data) external;\n}\n"
    },
    "contracts/interfaces/ITridentRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool router interface.\ninterface ITridentRouter {\n    struct Path {\n        address pool;\n        bytes data;\n    }\n\n    struct ExactInputSingleParams {\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        address pool;\n        address tokenIn;\n        bytes data;\n    }\n\n    struct ExactInputParams {\n        address tokenIn;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        Path[] path;\n    }\n\n    struct TokenInput {\n        address token;\n        bool native;\n        uint256 amount;\n    }\n\n    struct InitialPath {\n        address tokenIn;\n        address pool;\n        bool native;\n        uint256 amount;\n        bytes data;\n    }\n\n    struct PercentagePath {\n        address tokenIn;\n        address pool;\n        uint64 balancePercentage; // Multiplied by 10^6. 100% = 100_000_000\n        bytes data;\n    }\n\n    struct Output {\n        address token;\n        address to;\n        bool unwrapBento;\n        uint256 minAmount;\n    }\n\n    struct ComplexPathParams {\n        InitialPath[] initialPath;\n        PercentagePath[] percentagePath;\n        Output[] output;\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Minimal Uniswap V2 LP interface.\ninterface IUniswapV2Minimal is IERC20 {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ninterface IWETH9 is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}"
    },
    "contracts/libraries/RebaseLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8;\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.8.0;\n\nlibrary SafeCast {\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    function toUint128(uint256 y) internal pure returns (uint128 z) {\n        require((z = uint128(y)) == y);\n    }\n}\n"
    },
    "contracts/libraries/Transfer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary Transfer {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"STF\");\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ST\");\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SA\");\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"STE\");\n    }\n}"
    },
    "contracts/libraries/TridentMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident sqrt helper library.\nlibrary TridentMath {\n    /// @dev Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // This segment is to get a reasonable initial estimate for the Babylonian method.\n            // If the initial estimate is bad, the number of correct bits increases ~linearly\n            // each iteration instead of ~quadratically.\n            // The idea is to get z*z*y within a small factor of x.\n            // More iterations here gets y in a tighter range. Currently, we will have\n            // y in [256, 256*2^16). We ensure y>= 256 so that the relative difference\n            // between y and y+1 is small. If x < 256 this is not possible, but those cases\n            // are easy enough to verify exhaustively.\n            z := 181 // The 'correct' value is 1, but this saves a multiply later\n            let y := x\n            // Note that we check y>= 2^(k + 8) but shift right by k bits each branch,\n            // this is to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8),\n            // and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1)\n            // is in the range (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s=1\n            // and when s = 256 or 1/256. Since y is in [256, 256*2^16), let a = y/65536, so\n            // that a is in [1/256, 256). Then we can estimate sqrt(y) as\n            // sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A multiply is saved from the initial z := 181\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            // Possibly with a quadratic/cubic polynomial above we could get 4-6.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // See https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division.\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This check ensures we return floor.\n            // Since this case is rare, we choose to save gas on the assignment and\n            // repeat division in the rare case.\n            // If you don't care whether floor or ceil is returned, you can skip this.\n            if lt(div(x, z), z) {\n                z := div(x, z)\n            }\n        }\n    }\n}\n"
    },
    "contracts/pool/constant-product/ConstantProductPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\nimport {IBentoBoxMinimal} from \"../../interfaces/IBentoBoxMinimal.sol\";\nimport {IPool} from \"../../interfaces/IPool.sol\";\nimport {ITridentCallee} from \"../../interfaces/ITridentCallee.sol\";\nimport {IConstantProductPoolFactory} from \"../../interfaces/IConstantProductPoolFactory.sol\";\nimport {IMasterDeployer} from \"../../interfaces/IMasterDeployer.sol\";\n\nimport {TridentMath} from \"../../libraries/TridentMath.sol\";\n\n/// @dev Custom Errors\nerror ZeroAddress();\nerror IdenticalAddress();\nerror InvalidSwapFee();\nerror InvalidAmounts();\nerror InsufficientLiquidityMinted();\nerror InvalidOutputToken();\nerror InvalidInputToken();\nerror PoolUninitialized();\nerror InsufficientAmountIn();\nerror Overflow();\n\n/// @notice Trident exchange pool template with constant product formula for swapping between an ERC-20 token pair.\n/// @dev The reserves are stored as bento shares.\n///      The curve is applied to shares as well. This pool does not care about the underlying amounts.\ncontract ConstantProductPool is IPool, ERC20, ReentrancyGuard {\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 1000;\n\n    uint8 internal constant PRECISION = 112;\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n    uint256 public immutable swapFee;\n    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;\n\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n    address public immutable token0;\n    address public immutable token1;\n\n    uint256 public barFee;\n    address public barFeeTo;\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast;\n\n    uint112 internal reserve0;\n    uint112 internal reserve1;\n    uint32 internal blockTimestampLast;\n\n    bytes32 public constant override poolIdentifier = \"Trident:ConstantProduct\";\n\n    constructor() ERC20(\"Sushi Constant Product LP Token\", \"SCPLP\", 18) {\n        (bytes memory _deployData, IMasterDeployer _masterDeployer) = IConstantProductPoolFactory(msg.sender).getDeployData();\n\n        (address _token0, address _token1, uint256 _swapFee, bool _twapSupport) = abi.decode(\n            _deployData,\n            (address, address, uint256, bool)\n        );\n\n        // Factory ensures that the tokens are sorted.\n        if (_token0 == address(0)) revert ZeroAddress();\n        if (_token0 == _token1) revert IdenticalAddress();\n        if (_swapFee > MAX_FEE) revert InvalidSwapFee();\n\n        token0 = _token0;\n        token1 = _token1;\n        swapFee = _swapFee;\n        // This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.\n        unchecked {\n            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;\n        }\n        barFee = _masterDeployer.barFee();\n        barFeeTo = _masterDeployer.barFeeTo();\n        bento = IBentoBoxMinimal(_masterDeployer.bento());\n        masterDeployer = _masterDeployer;\n        if (_twapSupport) blockTimestampLast = uint32(block.timestamp);\n    }\n\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override nonReentrant returns (uint256 liquidity) {\n        address recipient = abi.decode(data, (address));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n\n        uint256 computed = TridentMath.sqrt(balance0 * balance1);\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n        _reserve0 += uint112(fee0);\n        _reserve1 += uint112(fee1);\n\n        (uint256 _totalSupply, uint256 k) = _mintFee(_reserve0, _reserve1);\n\n        if (_totalSupply == 0) {\n            if (amount0 == 0 || amount1 == 0) revert InvalidAmounts();\n            liquidity = computed - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        } else {\n            uint256 kIncrease;\n            unchecked {\n                kIncrease = computed - k;\n            }\n            liquidity = (kIncrease * _totalSupply) / k;\n        }\n        if (liquidity == 0) revert InsufficientLiquidityMinted();\n        _mint(recipient, liquidity);\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = computed;\n        emit Mint(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override nonReentrant returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        _transfer(token0, amount0, recipient, unwrapBento);\n        _transfer(token1, amount1, recipient, unwrapBento);\n        // This is safe from underflow - amounts are lesser figures derived from balances.\n        unchecked {\n            balance0 -= amount0;\n            balance1 -= amount1;\n        }\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\n\n        uint256 amount0 = (liquidity * _reserve0) / _totalSupply;\n        uint256 amount1 = (liquidity * _reserve1) / _totalSupply;\n\n        kLast = TridentMath.sqrt((_reserve0 - amount0) * (_reserve1 - amount1));\n\n        _burn(address(this), liquidity);\n\n        // Swap one token for another\n        unchecked {\n            if (tokenOut == token1) {\n                // Swap `token0` for `token1`\n                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\n                _transfer(token1, amount1, recipient, unwrapBento);\n                amountOut = amount1;\n                amount0 = 0;\n            } else {\n                // Swap `token1` for `token0`.\n                if (tokenOut != token0) revert InvalidOutputToken();\n                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\n                _transfer(token0, amount0, recipient, unwrapBento);\n                amountOut = amount0;\n                amount1 = 0;\n            }\n        }\n\n        (uint256 balance0, uint256 balance1) = _balance();\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        if (_reserve0 == 0) revert PoolUninitialized();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 amountIn;\n        address tokenOut;\n        unchecked {\n            if (tokenIn == token0) {\n                tokenOut = token1;\n                amountIn = balance0 - _reserve0;\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n                balance1 -= amountOut;\n            } else {\n                if (tokenIn != token1) revert InvalidInputToken();\n                tokenOut = token0;\n                amountIn = balance1 - reserve1;\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n                balance0 -= amountOut;\n            }\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.\n    function flashSwap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(\n            data,\n            (address, address, bool, uint256, bytes)\n        );\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        if (_reserve0 == 0) revert PoolUninitialized();\n        unchecked {\n            if (tokenIn == token0) {\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n                _transfer(token1, amountOut, recipient, unwrapBento);\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\n                (uint256 balance0, uint256 balance1) = _balance();\n                if (balance0 - _reserve0 < amountIn) revert InsufficientAmountIn();\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);\n            } else {\n                if (tokenIn != token1) revert InvalidInputToken();\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n                _transfer(token0, amountOut, recipient, unwrapBento);\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\n                (uint256 balance0, uint256 balance1) = _balance();\n                if (balance1 - _reserve1 < amountIn) revert InsufficientAmountIn();\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);\n            }\n        }\n    }\n\n    /// @dev Updates `barFee` and `barFeeTo` for Trident protocol.\n    function updateBarParameters() public {\n        barFee = masterDeployer.barFee();\n        barFeeTo = masterDeployer.barFeeTo();\n    }\n\n    function _getReserves()\n        internal\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _balance() internal view returns (uint256 balance0, uint256 balance1) {\n        balance0 = bento.balanceOf(token0, address(this));\n        balance1 = bento.balanceOf(token1, address(this));\n    }\n\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1,\n        uint32 _blockTimestampLast\n    ) internal {\n        if (balance0 > type(uint112).max || balance1 > type(uint112).max) revert Overflow();\n        if (_blockTimestampLast == 0) {\n            // TWAP support is disabled for gas efficiency.\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n        } else {\n            uint32 blockTimestamp = uint32(block.timestamp);\n            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {\n                unchecked {\n                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;\n                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;\n                    price0CumulativeLast += price0 * timeElapsed;\n                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;\n                    price1CumulativeLast += price1 * timeElapsed;\n                }\n            }\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n            blockTimestampLast = blockTimestamp;\n        }\n        emit Sync(balance0, balance1);\n    }\n\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) internal returns (uint256 _totalSupply, uint256 computed) {\n        _totalSupply = totalSupply;\n        uint256 _kLast = kLast;\n        if (_kLast != 0) {\n            computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);\n            if (computed > _kLast) {\n                // `barFee` % of increase in liquidity.\n                uint256 _barFee = barFee;\n                uint256 numerator = _totalSupply * (computed - _kLast) * _barFee;\n                uint256 denominator = (MAX_FEE - _barFee) * computed + _barFee * _kLast;\n                uint256 liquidity = numerator / denominator;\n\n                if (liquidity != 0) {\n                    _mint(barFeeTo, liquidity);\n                    _totalSupply += liquidity;\n                }\n            }\n        }\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveAmountIn,\n        uint256 reserveAmountOut\n    ) internal view returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;\n        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);\n    }\n\n    function _getAmountIn(\n        uint256 amountOut,\n        uint256 reserveAmountIn,\n        uint256 reserveAmountOut\n    ) internal view returns (uint256 amountIn) {\n        amountIn = (reserveAmountIn * amountOut * MAX_FEE) / ((reserveAmountOut - amountOut) * MAX_FEE_MINUS_SWAP_FEE) + 1;\n    }\n\n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, 0, shares);\n        } else {\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.\n    function _nonOptimalMintFee(\n        uint256 _amount0,\n        uint256 _amount1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {\n        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);\n        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;\n        if (amount1Optimal <= _amount1) {\n            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);\n        } else {\n            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;\n            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);\n        }\n    }\n\n    function getAssets() public view override returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {\n        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();\n        if (tokenIn == token0) {\n            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n        } else {\n            if (tokenIn != token1) revert InvalidInputToken();\n            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n        }\n    }\n\n    function getAmountIn(bytes calldata data) public view override returns (uint256 finalAmountIn) {\n        (address tokenOut, uint256 amountOut) = abi.decode(data, (address, uint256));\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();\n        if (tokenOut == token1) {\n            finalAmountIn = _getAmountIn(amountOut, _reserve0, _reserve1);\n        } else {\n            if (tokenOut != token0) revert InvalidOutputToken();\n            finalAmountIn = _getAmountIn(amountOut, _reserve1, _reserve0);\n        }\n    }\n\n    /// @dev Returned values are in terms of BentoBox \"shares\".\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        return _getReserves();\n    }\n\n    /// @dev Returned values are the native ERC20 token amounts.\n    function getNativeReserves()\n        public\n        view\n        returns (\n            uint256 _nativeReserve0,\n            uint256 _nativeReserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        (uint112 _reserve0, uint112 _reserve1, uint32 __blockTimestampLast) = _getReserves();\n        _nativeReserve0 = bento.toAmount(token0, _reserve0, false);\n        _nativeReserve1 = bento.toAmount(token1, _reserve1, false);\n        _blockTimestampLast = __blockTimestampLast;\n    }\n}\n"
    },
    "contracts/pool/constant-product/ConstantProductPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {PoolDeployer} from \"../../abstract/PoolDeployer.sol\";\nimport {ConstantProductPool} from \"./ConstantProductPool.sol\";\nimport {IConstantProductPoolFactory} from \"../../interfaces/IConstantProductPoolFactory.sol\";\nimport {IMasterDeployer} from \"../../interfaces/IMasterDeployer.sol\";\n\n/// @notice Contract for deploying Trident exchange Constant Product Pool with configurations.\n/// @author Mudit Gupta.\ncontract ConstantProductPoolFactory is IConstantProductPoolFactory, PoolDeployer {\n    bytes32 public constant bytecodeHash = keccak256(type(ConstantProductPool).creationCode);\n\n    bytes private cachedDeployData;\n\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB, uint256 swapFee, bool twapSupport) = abi.decode(_deployData, (address, address, uint256, bool));\n\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB, swapFee, twapSupport);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        bytes32 salt = keccak256(_deployData);\n\n        cachedDeployData = _deployData;\n\n        pool = address(new ConstantProductPool{salt: salt}());\n\n        cachedDeployData = \"\";\n\n        _registerPool(pool, tokens, salt);\n    }\n\n    // This called in the ConstantProductPool constructor.\n    function getDeployData() external view override returns (bytes memory, IMasterDeployer) {\n        return (cachedDeployData, IMasterDeployer(masterDeployer));\n    }\n\n    function calculatePoolAddress(\n        address token0,\n        address token1,\n        uint256 swapFee,\n        bool twapSupport\n    ) external view returns (address) {\n        bytes32 salt = keccak256(abi.encode(token0, token1, swapFee, twapSupport));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, bytecodeHash));\n        return address(uint160(uint256(hash)));\n    }\n}\n"
    },
    "contracts/pool/constant-product/ConstantProductPoolFactoryHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./ConstantProductPool.sol\";\nimport \"./ConstantProductPoolFactory.sol\";\n\n/// @notice Helper Contract for fetching info for several pools\n/// @author Ilya Lyalin\ncontract ConstantProductPoolFactoryHelper {\n    struct ConstantProductPoolInfo {\n        uint8 tokenA;\n        uint8 tokenB;\n        uint112 reserve0;\n        uint112 reserve1;\n        uint16 swapFeeAndTwapSupport;\n    }\n\n    // @dev tokens MUST be sorted i < j => token[i] < token[j]\n    // @dev tokens.length < 256\n    function getPoolsForTokens(address constantProductPoolFactory, address[] calldata tokens)\n        external\n        view\n        returns (ConstantProductPoolInfo[] memory poolInfos, uint256 length)\n    {\n        ConstantProductPoolFactory factory = ConstantProductPoolFactory(constantProductPoolFactory);\n        uint8 tokenNumber = uint8(tokens.length);\n        uint256[] memory poolLength = new uint256[]((tokenNumber * (tokenNumber + 1)) / 2);\n        uint256 pairNumber = 0;\n        for (uint8 i = 0; i < tokenNumber; i++) {\n            for (uint8 j = i + 1; j < tokenNumber; j++) {\n                uint256 count = factory.poolsCount(tokens[i], tokens[j]);\n                poolLength[pairNumber++] = count;\n                length += count;\n            }\n        }\n        poolInfos = new ConstantProductPoolInfo[](length);\n        pairNumber = 0;\n        uint256 poolNumber = 0;\n        for (uint8 i = 0; i < tokenNumber; i++) {\n            for (uint8 j = i + 1; j < tokenNumber; j++) {\n                address[] memory pools = factory.getPools(tokens[i], tokens[j], 0, poolLength[pairNumber++]);\n                for (uint256 k = 0; k < pools.length; k++) {\n                    ConstantProductPoolInfo memory poolInfo = poolInfos[poolNumber++];\n                    poolInfo.tokenA = i;\n                    poolInfo.tokenB = j;\n                    ConstantProductPool pool = ConstantProductPool(pools[k]);\n                    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pool.getReserves();\n                    poolInfo.reserve0 = reserve0;\n                    poolInfo.reserve1 = reserve1;\n                    poolInfo.swapFeeAndTwapSupport = uint16(pool.swapFee());\n                    if (blockTimestampLast != 0) poolInfo.swapFeeAndTwapSupport += 1 << 15;\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/pool/stable/StablePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport {IBentoBoxMinimal} from \"../../interfaces/IBentoBoxMinimal.sol\";\nimport {IMasterDeployerV2} from \"../../interfaces/IMasterDeployerV2.sol\";\nimport {IPool} from \"../../interfaces/IPool.sol\";\nimport {IStablePoolFactory} from \"../../interfaces/IStablePoolFactory.sol\";\nimport {IERC20, SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {TridentMath} from \"../../libraries/TridentMath.sol\";\nimport \"../../libraries/RebaseLibrary.sol\";\n\n/// @dev Custom Errors\nerror ZeroAddress();\nerror IdenticalAddress();\nerror InvalidSwapFee();\nerror InsufficientLiquidityMinted();\nerror InvalidAmounts();\nerror InvalidInputToken();\nerror PoolUninitialized();\nerror InvalidOutputToken();\n\n/// @notice Trident exchange pool template with stable swap (solidly exchange) for swapping between tightly correlated assets\n\ncontract StablePool is IPool, ERC20, ReentrancyGuard {\n    using RebaseLibrary for Rebase;\n    using SafeERC20 for IERC20;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 1000;\n\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n    uint256 public immutable swapFee;\n    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;\n\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployerV2 public immutable masterDeployer;\n    address public immutable token0;\n    address public immutable token1;\n\n    uint256 public barFee;\n    address public barFeeTo;\n    uint256 public kLast;\n\n    uint256 internal reserve0;\n    uint256 internal reserve1;\n\n    uint256 public immutable decimals0;\n    uint256 public immutable decimals1;\n\n    bytes32 public constant poolIdentifier = \"Trident:StablePool\";\n\n    constructor() ERC20(\"Sushi Stable LP Token\", \"SSLP\", 18) {\n        (bytes memory _deployData, IMasterDeployerV2 _masterDeployer) = IStablePoolFactory(msg.sender).getDeployData();\n\n        (address _token0, address _token1, uint256 _swapFee) = abi.decode(_deployData, (address, address, uint256));\n\n        // Factory ensures that the tokens are sorted.\n        if (_token0 == address(0)) revert ZeroAddress();\n        if (_token0 == _token1) revert IdenticalAddress();\n        if (_swapFee > MAX_FEE) revert InvalidSwapFee();\n\n        token0 = _token0;\n        token1 = _token1;\n        swapFee = _swapFee;\n\n        // This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.\n        unchecked {\n            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;\n        }\n\n        decimals0 = uint256(10)**(ERC20(_token0).decimals());\n        decimals1 = uint256(10)**(ERC20(_token1).decimals());\n\n        barFee = _masterDeployer.barFee();\n        barFeeTo = _masterDeployer.barFeeTo();\n        bento = IBentoBoxMinimal(_masterDeployer.bento());\n        masterDeployer = _masterDeployer;\n    }\n\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override nonReentrant returns (uint256 liquidity) {\n        address recipient = abi.decode(data, (address));\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n\n        uint256 newLiq = _computeLiquidity(balance0, balance1);\n\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n\n        _reserve0 += uint112(fee0);\n        _reserve1 += uint112(fee1);\n\n        (uint256 _totalSupply, uint256 oldLiq) = _mintFee(_reserve0, _reserve1);\n\n        if (_totalSupply == 0) {\n            if (amount0 == 0 || amount1 == 0) revert InvalidAmounts();\n            liquidity = newLiq - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        } else {\n            liquidity = ((newLiq - oldLiq) * _totalSupply) / oldLiq;\n        }\n\n        if (liquidity == 0) revert InsufficientLiquidityMinted();\n\n        _mint(recipient, liquidity);\n\n        _updateReserves();\n\n        kLast = newLiq;\n        emit Mint(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override nonReentrant returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(balance0, balance1);\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        _transfer(token0, amount0, recipient, unwrapBento);\n        _transfer(token1, amount1, recipient, unwrapBento);\n\n        _updateReserves();\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        kLast = _computeLiquidity(balance0 - amount0, balance1 - amount1);\n\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    function burnSingle(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(balance0, balance1);\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        kLast = _computeLiquidity(balance0 - amount0, balance1 - amount1);\n        _burn(address(this), liquidity);\n\n        unchecked {\n            if (tokenOut == token1) {\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1, true);\n                _transfer(token1, amount1, recipient, unwrapBento);\n                amountOut = amount1;\n                amount0 = 0;\n            } else {\n                if (tokenOut != token0) revert InvalidOutputToken();\n                amount0 += _getAmountOut(amount1, _reserve0 - amount0, _reserve1 - amount1, false);\n                _transfer(token0, amount0, recipient, unwrapBento);\n                amountOut = amount0;\n                amount1 = 0;\n            }\n        }\n\n        _updateReserves();\n\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint256 _reserve0, uint256 _reserve1, uint256 balance0, uint256 balance1) = _getReservesAndBalances();\n        uint256 amountIn;\n        address tokenOut;\n\n        if (tokenIn == token0) {\n            tokenOut = token1;\n            unchecked {\n                amountIn = balance0 - _reserve0;\n            }\n            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);\n        } else {\n            if (tokenIn != token1) revert InvalidInputToken();\n            tokenOut = token0;\n            unchecked {\n                amountIn = balance1 - _reserve1;\n            }\n            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        _updateReserves();\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Updates `barFee` and `barFeeTo` for Trident protocol.\n    function updateBarParameters() public {\n        barFee = masterDeployer.barFee();\n        barFeeTo = masterDeployer.barFeeTo();\n    }\n\n    function _balance() internal view returns (uint256 balance0, uint256 balance1) {\n        balance0 = bento.toAmount(token0, bento.balanceOf(token0, address(this)), false);\n        balance1 = bento.toAmount(token1, bento.balanceOf(token1, address(this)), false);\n    }\n\n    function _getReservesAndBalances()\n        internal\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 balance0,\n            uint256 balance1\n        )\n    {\n        (_reserve0, _reserve1) = (reserve0, reserve1);\n        balance0 = bento.balanceOf(token0, address(this));\n        balance1 = bento.balanceOf(token1, address(this));\n        Rebase memory total0 = bento.totals(token0);\n        Rebase memory total1 = bento.totals(token1);\n\n        balance0 = total0.toElastic(balance0);\n        balance1 = total1.toElastic(balance1);\n    }\n\n    function _updateReserves() internal {\n        (uint256 _reserve0, uint256 _reserve1) = _balance();\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n        emit Sync(_reserve0, _reserve1);\n    }\n\n    function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {\n        unchecked {\n            uint256 adjustedReserve0 = (_reserve0 * 1e12) / decimals0;\n            uint256 adjustedReserve1 = (_reserve1 * 1e12) / decimals1;\n            liquidity = _computeLiquidityFromAdjustedBalances(adjustedReserve0, adjustedReserve1);\n        }\n    }\n\n    function _computeLiquidityFromAdjustedBalances(uint256 x, uint256 y) internal pure returns (uint256 computed) {\n        return TridentMath.sqrt(TridentMath.sqrt(_k(x, y)));\n    }\n\n    function _mintFee(uint256 _reserve0, uint256 _reserve1) internal returns (uint256 _totalSupply, uint256 computed) {\n        _totalSupply = totalSupply;\n        uint256 _kLast = kLast;\n        if (_kLast != 0) {\n            computed = _computeLiquidity(_reserve0, _reserve1);\n            if (computed > _kLast) {\n                // `barFee` % of increase in liquidity.\n                uint256 _barFee = barFee;\n                uint256 numerator = _totalSupply * (computed - _kLast) * _barFee;\n                uint256 denominator = (MAX_FEE - _barFee) * computed + _barFee * _kLast;\n                uint256 liquidity = numerator / denominator;\n\n                if (liquidity != 0) {\n                    _mint(barFeeTo, liquidity);\n                    _totalSupply += liquidity;\n                }\n            }\n        }\n    }\n\n    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.\n    function _nonOptimalMintFee(\n        uint256 _amount0,\n        uint256 _amount1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {\n        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);\n        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;\n\n        if (amount1Optimal <= _amount1) {\n            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);\n        } else {\n            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;\n            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);\n        }\n    }\n\n    function _k(uint256 x, uint256 y) internal pure returns (uint256) {\n        uint256 _a = (x * y) / 1e12;\n        uint256 _b = ((x * x) / 1e12 + (y * y) / 1e12);\n        return ((_a * _b) / 1e12); // x3y+y3x >= k\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return (x0 * ((((y * y) / 1e12) * y) / 1e12)) / 1e12 + (((((x0 * x0) / 1e12) * x0) / 1e12) * y) / 1e12;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return (3 * x0 * ((y * y) / 1e12)) / 1e12 + ((((x0 * x0) / 1e12) * x0) / 1e12);\n    }\n\n    function _get_y(\n        uint256 x0,\n        uint256 xy,\n        uint256 y\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 y_prev = y;\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                uint256 dy = ((xy - k) * 1e12) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e12) / _d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 _reserve0,\n        uint256 _reserve1,\n        bool token0In\n    ) internal view returns (uint256 dy) {\n        unchecked {\n            uint256 adjustedReserve0 = (_reserve0 * 1e12) / decimals0;\n            uint256 adjustedReserve1 = (_reserve1 * 1e12) / decimals1;\n            uint256 feeDeductedAmountIn = amountIn - (amountIn * swapFee) / MAX_FEE;\n            uint256 xy = _k(adjustedReserve0, adjustedReserve1);\n            if (token0In) {\n                uint256 x0 = adjustedReserve0 + ((feeDeductedAmountIn * 1e12) / decimals0);\n                uint256 y = _get_y(x0, xy, adjustedReserve1);\n                dy = adjustedReserve1 - y;\n                dy = (dy * decimals1) / 1e12;\n            } else {\n                uint256 x0 = adjustedReserve1 + ((feeDeductedAmountIn * 1e12) / decimals1);\n                uint256 y = _get_y(x0, xy, adjustedReserve0);\n                dy = adjustedReserve0 - y;\n                dy = (dy * decimals0) / 1e12;\n            }\n        }\n    }\n\n    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {\n        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        amountIn = bento.toAmount(tokenIn, amountIn, false);\n\n        if (tokenIn == token0) {\n            finalAmountOut = bento.toShare(token1, _getAmountOut(amountIn, _reserve0, _reserve1, true), false);\n        } else {\n            if (tokenIn != token1) revert InvalidInputToken();\n            finalAmountOut = bento.toShare(token0, _getAmountOut(amountIn, _reserve0, _reserve1, false), false);\n        }\n    }\n\n    function _transfer(\n        address token,\n        uint256 amount,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, amount, 0);\n        } else {\n            uint256 shares = bento.toShare(token, amount, false);\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    function getAssets() public view returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    function skim() public nonReentrant {\n        address _token0 = token0;\n        address _token1 = token1;\n        address receiver = masterDeployer.owner();\n        IERC20(_token0).safeTransfer(receiver, IERC20(_token0).balanceOf(address(this)));\n        IERC20(_token1).safeTransfer(receiver, IERC20(_token1).balanceOf(address(this)));\n    }\n\n    function _getReserves() internal view returns (uint256 _reserve0, uint256 _reserve1) {\n        (_reserve0, _reserve1) = (reserve0, reserve1);\n    }\n\n    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1) {\n        return _getReserves();\n    }\n\n    function getNativeReserves() public view returns (uint256 _nativeReserve0, uint256 _nativeReserve1) {\n        return _getReserves();\n    }\n\n    function flashSwap(bytes calldata) external pure override returns (uint256) {\n        revert();\n    }\n\n    function getAmountIn(bytes calldata) external pure override returns (uint256) {\n        revert();\n    }\n}\n"
    },
    "contracts/pool/stable/StablePoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {PoolDeployer} from \"../../abstract/PoolDeployer.sol\";\nimport {StablePool} from \"./StablePool.sol\";\nimport {IStablePoolFactory} from \"../../interfaces/IStablePoolFactory.sol\";\nimport {IMasterDeployerV2} from \"../../interfaces/IMasterDeployerV2.sol\";\n\ncontract StablePoolFactory is IStablePoolFactory, PoolDeployer {\n    bytes32 public constant bytecodeHash = keccak256(type(StablePool).creationCode);\n\n    bytes private cachedDeployData;\n\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB, uint256 swapFee) = abi.decode(_deployData, (address, address, uint256));\n\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB, swapFee);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        bytes32 salt = keccak256(_deployData);\n\n        cachedDeployData = _deployData;\n\n        pool = address(new StablePool{salt: salt}());\n\n        cachedDeployData = \"\";\n\n        _registerPool(pool, tokens, salt);\n    }\n\n    // This called in the StablePool constructor.\n    function getDeployData() external view override returns (bytes memory, IMasterDeployerV2) {\n        return (cachedDeployData, IMasterDeployerV2(masterDeployer));\n    }\n\n    function calculatePoolAddress(\n        address token0,\n        address token1,\n        uint256 swapFee\n    ) external view returns (address) {\n        bytes32 salt = keccak256(abi.encode(token0, token1, swapFee));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, bytecodeHash));\n        return address(uint160(uint256(hash)));\n    }\n}\n"
    },
    "contracts/TridentRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {Multicall} from \"./abstract/Multicall.sol\";\nimport {SelfPermit} from \"./abstract/SelfPermit.sol\";\nimport {Transfer} from \"./libraries/Transfer.sol\";\nimport {IBentoBoxMinimal} from \"./interfaces/IBentoBoxMinimal.sol\";\nimport {IMasterDeployer} from \"./interfaces/IMasterDeployer.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {ITridentRouter} from \"./interfaces/ITridentRouter.sol\";\nimport {IWETH9} from \"./interfaces/IWETH9.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @dev Custom Errors\nerror NotWethSender();\nerror TooLittleReceived();\nerror NotEnoughLiquidityMinted();\nerror IncorrectTokenWithdrawn();\nerror IncorrectSlippageParams();\nerror InsufficientWETH();\nerror InvalidPool();\n\n/// @notice Router contract that helps in swapping across Trident pools.\ncontract TridentRouter is ITridentRouter, SelfPermit, Multicall {\n    using Transfer for address;\n\n    /// @notice BentoBox token vault.\n    IBentoBoxMinimal public immutable bento;\n\n    /// @notice Master deployer.\n    IMasterDeployer public immutable masterDeployer;\n\n    /// @notice ERC-20 token for wrapped ETH (v9).\n    address internal immutable wETH;\n\n    /// @notice The user should use 0x0 if they want to use native currency, e.g., ETH.\n    address constant USE_NATIVE = address(0);\n\n    constructor(\n        IBentoBoxMinimal _bento,\n        IMasterDeployer _masterDeployer,\n        address _wETH\n    ) {\n        bento = _bento;\n        masterDeployer = _masterDeployer;\n        wETH = _wETH;\n        _bento.registerProtocol();\n    }\n\n    receive() external payable {\n        if (msg.sender != wETH) revert NotWethSender();\n    }\n\n    /// @notice Swaps token A to token B directly. Swaps are done on `bento` tokens.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingle(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // Prefund the pool with token A.\n        bento.transfer(params.tokenIn, msg.sender, params.pool, params.amountIn);\n        // Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInput(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // Pay the first pool directly.\n        bento.transfer(params.tokenIn, msg.sender, params.path[0].pool, params.amountIn);\n        // Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        // If the user wants to unwrap `wETH`, the final destination should be this contract and\n        // a batch call should be made to `unwrapWETH`.\n        uint256 n = params.path.length;\n        for (uint256 i = 0; i < n; i = _increment(i)) {\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n        }\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps token A to token B directly. It's the same as `exactInputSingle` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingleWithNativeToken(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.pool, params.amountIn);\n        // Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops. It's the same as `exactInput` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInputWithNativeToken(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.path[0].pool, params.amountIn);\n        // Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        uint256 n = params.path.length;\n        for (uint256 i = 0; i < n; i = _increment(i)) {\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n        }\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps multiple input tokens to multiple output tokens using multiple paths, in different percentages.\n    /// For example, you can swap 50 DAI + 100 USDC into 60% ETH and 40% BTC.\n    /// @param params This includes everything needed for the swap. Look at the `ComplexPathParams` struct for more details.\n    /// @dev This function is not optimized for single swaps and should only be used in complex cases where\n    /// the amounts are large enough that minimizing slippage by using multiple paths is worth the extra gas.\n    function complexPath(ComplexPathParams calldata params) public payable {\n        // Deposit all initial tokens to respective pools and initiate the swaps.\n        // Input tokens come from the user - output goes to following pools.\n        uint256 n = params.initialPath.length;\n        for (uint256 i = 0; i < n; i = _increment(i)) {\n            if (params.initialPath[i].native) {\n                _depositToBentoBox(params.initialPath[i].tokenIn, params.initialPath[i].pool, params.initialPath[i].amount);\n            } else {\n                bento.transfer(params.initialPath[i].tokenIn, msg.sender, params.initialPath[i].pool, params.initialPath[i].amount);\n            }\n            IPool(params.initialPath[i].pool).swap(params.initialPath[i].data);\n        }\n        // Do all the middle swaps. Input comes from previous pools.\n        n = params.percentagePath.length;\n        for (uint256 i = 0; i < n; i = _increment(i)) {\n            uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));\n            uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)**8;\n            bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);\n            IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);\n        }\n        // Ensure enough was received and transfer the ouput to the recipient.\n        n = params.output.length;\n        for (uint256 i = 0; i < n; i = _increment(i)) {\n            uint256 balanceShares = bento.balanceOf(params.output[i].token, address(this));\n            if (balanceShares < params.output[i].minAmount) revert TooLittleReceived();\n            if (params.output[i].unwrapBento) {\n                bento.withdraw(params.output[i].token, address(this), params.output[i].to, 0, balanceShares);\n            } else {\n                bento.transfer(params.output[i].token, address(this), params.output[i].to, balanceShares);\n            }\n        }\n    }\n\n    /// @notice Add liquidity to a pool.\n    /// @param tokenInput Token address and amount to add as liquidity.\n    /// @param pool Pool address to add liquidity to.\n    /// @param minLiquidity Minimum output liquidity - caps slippage.\n    /// @param data Data required by the pool to add liquidity.\n    function addLiquidity(\n        TokenInput[] calldata tokenInput,\n        address pool,\n        uint256 minLiquidity,\n        bytes calldata data\n    ) public payable returns (uint256 liquidity) {\n        // Send all input tokens to the pool.\n        uint256 n = tokenInput.length;\n        for (uint256 i = 0; i < n; i = _increment(i)) {\n            if (tokenInput[i].native) {\n                _depositToBentoBox(tokenInput[i].token, pool, tokenInput[i].amount);\n            } else {\n                bento.transfer(tokenInput[i].token, msg.sender, pool, tokenInput[i].amount);\n            }\n        }\n        liquidity = IPool(pool).mint(data);\n        if (liquidity < minLiquidity) revert NotEnoughLiquidityMinted();\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawals Minimum amount of `bento` tokens to be returned.\n    function burnLiquidity(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        IPool.TokenAmount[] calldata minWithdrawals\n    ) public payable {\n        pool.safeTransferFrom(msg.sender, pool, liquidity);\n        IPool.TokenAmount[] memory withdrawnLiquidity = IPool(pool).burn(data);\n        uint256 n = minWithdrawals.length;\n        for (uint256 i = 0; i < n; i = _increment(i)) {\n            if (minWithdrawals[i].token != withdrawnLiquidity[i].token) revert IncorrectSlippageParams();\n            if (withdrawnLiquidity[i].amount < minWithdrawals[i].amount) revert TooLittleReceived();\n        }\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @dev The tokens are swapped automatically and the output is in a single token.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawal Minimum amount of tokens to be returned.\n    function burnLiquiditySingle(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        uint256 minWithdrawal\n    ) public payable {\n        // Use 'liquidity = 0' for prefunding.\n        pool.safeTransferFrom(msg.sender, pool, liquidity);\n        uint256 withdrawn = IPool(pool).burnSingle(data);\n        if (withdrawn < minWithdrawal) revert TooLittleReceived();\n    }\n\n    /// @notice Recover mistakenly sent tokens.\n    function sweep(\n        address token,\n        address recipient,\n        bool fromBento\n    ) external payable {\n        if (fromBento) {\n            uint256 shares = bento.balanceOf(token, address(this));\n            bento.transfer(token, address(this), recipient, shares);\n        } else {\n            uint256 amount = token == USE_NATIVE ? address(this).balance : (IERC20(token).balanceOf(address(this)) - 1);\n            token == USE_NATIVE ? recipient.safeTransferETH(amount) : token.safeTransfer(recipient, amount);\n        }\n    }\n\n    /// @notice Unwrap this contract's wETH into ETH.\n    function unwrapWETH(address recipient) external payable {\n        uint256 balance = IWETH9(wETH).balanceOf(address(this));\n        IWETH9(wETH).withdraw(balance);\n        recipient.safeTransferETH(balance);\n    }\n\n    /// @notice Wrapper function to allow pool deployment to be batched.\n    function deployPool(address factory, bytes calldata deployData) external payable returns (address) {\n        return masterDeployer.deployPool(factory, deployData);\n    }\n\n    /// @notice Wrapper function to allow bento set master contract approval to be batched, so the first trade can happen in one transaction.\n    function approveMasterContract(\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        bento.setMasterContractApproval(msg.sender, address(this), true, v, r, s);\n    }\n\n    /// @notice Call BentoBox harvest function to rebalance a BentoBox token strategy and ensure there are enough tokens available to withdraw a swap output.\n    /// @dev Should be batched in before a swap.\n    function harvest(address token, uint256 maxChangeAmount) external payable {\n        bento.harvest(token, true, maxChangeAmount);\n    }\n\n    /// @notice Deposit from the user's wallet into BentoBox.\n    /// @dev Amount is the native token amount. We let BentoBox do the conversion into shares.\n    function _depositToBentoBox(\n        address token,\n        address recipient,\n        uint256 amount\n    ) internal {\n        bento.deposit{value: token == USE_NATIVE ? amount : 0}(token, msg.sender, recipient, amount, 0);\n    }\n\n    function _increment(uint256 i) internal pure returns (uint256) {\n        unchecked {\n            return i + 1;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}